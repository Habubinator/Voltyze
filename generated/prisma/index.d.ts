
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model api_source
 * 
 */
export type api_source = $Result.DefaultSelection<Prisma.$api_sourcePayload>
/**
 * Model comments
 * 
 */
export type comments = $Result.DefaultSelection<Prisma.$commentsPayload>
/**
 * Model images
 * 
 */
export type images = $Result.DefaultSelection<Prisma.$imagesPayload>
/**
 * Model station_connector
 * 
 */
export type station_connector = $Result.DefaultSelection<Prisma.$station_connectorPayload>
/**
 * Model station_desc_api
 * 
 */
export type station_desc_api = $Result.DefaultSelection<Prisma.$station_desc_apiPayload>
/**
 * Model station_description
 * 
 */
export type station_description = $Result.DefaultSelection<Prisma.$station_descriptionPayload>
/**
 * Model station_marker
 * 
 */
export type station_marker = $Result.DefaultSelection<Prisma.$station_markerPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SavedStations
 * 
 */
export type SavedStations = $Result.DefaultSelection<Prisma.$SavedStationsPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model RecoveryToken
 * 
 */
export type RecoveryToken = $Result.DefaultSelection<Prisma.$RecoveryTokenPayload>
/**
 * Model UserPermissions
 * 
 */
export type UserPermissions = $Result.DefaultSelection<Prisma.$UserPermissionsPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model UserActivity
 * 
 */
export type UserActivity = $Result.DefaultSelection<Prisma.$UserActivityPayload>
/**
 * Model UserBan
 * 
 */
export type UserBan = $Result.DefaultSelection<Prisma.$UserBanPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Api_sources
 * const api_sources = await prisma.api_source.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Api_sources
   * const api_sources = await prisma.api_source.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.api_source`: Exposes CRUD operations for the **api_source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Api_sources
    * const api_sources = await prisma.api_source.findMany()
    * ```
    */
  get api_source(): Prisma.api_sourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.commentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.images`: Exposes CRUD operations for the **images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.images.findMany()
    * ```
    */
  get images(): Prisma.imagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.station_connector`: Exposes CRUD operations for the **station_connector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Station_connectors
    * const station_connectors = await prisma.station_connector.findMany()
    * ```
    */
  get station_connector(): Prisma.station_connectorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.station_desc_api`: Exposes CRUD operations for the **station_desc_api** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Station_desc_apis
    * const station_desc_apis = await prisma.station_desc_api.findMany()
    * ```
    */
  get station_desc_api(): Prisma.station_desc_apiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.station_description`: Exposes CRUD operations for the **station_description** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Station_descriptions
    * const station_descriptions = await prisma.station_description.findMany()
    * ```
    */
  get station_description(): Prisma.station_descriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.station_marker`: Exposes CRUD operations for the **station_marker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Station_markers
    * const station_markers = await prisma.station_marker.findMany()
    * ```
    */
  get station_marker(): Prisma.station_markerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedStations`: Exposes CRUD operations for the **SavedStations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedStations
    * const savedStations = await prisma.savedStations.findMany()
    * ```
    */
  get savedStations(): Prisma.SavedStationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recoveryToken`: Exposes CRUD operations for the **RecoveryToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecoveryTokens
    * const recoveryTokens = await prisma.recoveryToken.findMany()
    * ```
    */
  get recoveryToken(): Prisma.RecoveryTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPermissions`: Exposes CRUD operations for the **UserPermissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPermissions
    * const userPermissions = await prisma.userPermissions.findMany()
    * ```
    */
  get userPermissions(): Prisma.UserPermissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userActivity`: Exposes CRUD operations for the **UserActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivities
    * const userActivities = await prisma.userActivity.findMany()
    * ```
    */
  get userActivity(): Prisma.UserActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBan`: Exposes CRUD operations for the **UserBan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBans
    * const userBans = await prisma.userBan.findMany()
    * ```
    */
  get userBan(): Prisma.UserBanDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    api_source: 'api_source',
    comments: 'comments',
    images: 'images',
    station_connector: 'station_connector',
    station_desc_api: 'station_desc_api',
    station_description: 'station_description',
    station_marker: 'station_marker',
    User: 'User',
    SavedStations: 'SavedStations',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    RecoveryToken: 'RecoveryToken',
    UserPermissions: 'UserPermissions',
    UserSession: 'UserSession',
    UserActivity: 'UserActivity',
    UserBan: 'UserBan'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "api_source" | "comments" | "images" | "station_connector" | "station_desc_api" | "station_description" | "station_marker" | "user" | "savedStations" | "role" | "permission" | "rolePermission" | "recoveryToken" | "userPermissions" | "userSession" | "userActivity" | "userBan"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      api_source: {
        payload: Prisma.$api_sourcePayload<ExtArgs>
        fields: Prisma.api_sourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.api_sourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_sourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.api_sourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_sourcePayload>
          }
          findFirst: {
            args: Prisma.api_sourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_sourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.api_sourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_sourcePayload>
          }
          findMany: {
            args: Prisma.api_sourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_sourcePayload>[]
          }
          create: {
            args: Prisma.api_sourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_sourcePayload>
          }
          createMany: {
            args: Prisma.api_sourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.api_sourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_sourcePayload>
          }
          update: {
            args: Prisma.api_sourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_sourcePayload>
          }
          deleteMany: {
            args: Prisma.api_sourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.api_sourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.api_sourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_sourcePayload>
          }
          aggregate: {
            args: Prisma.Api_sourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApi_source>
          }
          groupBy: {
            args: Prisma.api_sourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Api_sourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.api_sourceCountArgs<ExtArgs>
            result: $Utils.Optional<Api_sourceCountAggregateOutputType> | number
          }
        }
      }
      comments: {
        payload: Prisma.$commentsPayload<ExtArgs>
        fields: Prisma.commentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findFirst: {
            args: Prisma.commentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findMany: {
            args: Prisma.commentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          create: {
            args: Prisma.commentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          createMany: {
            args: Prisma.commentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.commentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          update: {
            args: Prisma.commentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          deleteMany: {
            args: Prisma.commentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.commentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.commentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.commentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      images: {
        payload: Prisma.$imagesPayload<ExtArgs>
        fields: Prisma.imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.imagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.imagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          findFirst: {
            args: Prisma.imagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.imagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          findMany: {
            args: Prisma.imagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>[]
          }
          create: {
            args: Prisma.imagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          createMany: {
            args: Prisma.imagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.imagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          update: {
            args: Prisma.imagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          deleteMany: {
            args: Prisma.imagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.imagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.imagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          aggregate: {
            args: Prisma.ImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImages>
          }
          groupBy: {
            args: Prisma.imagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.imagesCountArgs<ExtArgs>
            result: $Utils.Optional<ImagesCountAggregateOutputType> | number
          }
        }
      }
      station_connector: {
        payload: Prisma.$station_connectorPayload<ExtArgs>
        fields: Prisma.station_connectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.station_connectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_connectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.station_connectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_connectorPayload>
          }
          findFirst: {
            args: Prisma.station_connectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_connectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.station_connectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_connectorPayload>
          }
          findMany: {
            args: Prisma.station_connectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_connectorPayload>[]
          }
          create: {
            args: Prisma.station_connectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_connectorPayload>
          }
          createMany: {
            args: Prisma.station_connectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.station_connectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_connectorPayload>
          }
          update: {
            args: Prisma.station_connectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_connectorPayload>
          }
          deleteMany: {
            args: Prisma.station_connectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.station_connectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.station_connectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_connectorPayload>
          }
          aggregate: {
            args: Prisma.Station_connectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStation_connector>
          }
          groupBy: {
            args: Prisma.station_connectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Station_connectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.station_connectorCountArgs<ExtArgs>
            result: $Utils.Optional<Station_connectorCountAggregateOutputType> | number
          }
        }
      }
      station_desc_api: {
        payload: Prisma.$station_desc_apiPayload<ExtArgs>
        fields: Prisma.station_desc_apiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.station_desc_apiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_desc_apiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.station_desc_apiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_desc_apiPayload>
          }
          findFirst: {
            args: Prisma.station_desc_apiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_desc_apiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.station_desc_apiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_desc_apiPayload>
          }
          findMany: {
            args: Prisma.station_desc_apiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_desc_apiPayload>[]
          }
          create: {
            args: Prisma.station_desc_apiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_desc_apiPayload>
          }
          createMany: {
            args: Prisma.station_desc_apiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.station_desc_apiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_desc_apiPayload>
          }
          update: {
            args: Prisma.station_desc_apiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_desc_apiPayload>
          }
          deleteMany: {
            args: Prisma.station_desc_apiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.station_desc_apiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.station_desc_apiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_desc_apiPayload>
          }
          aggregate: {
            args: Prisma.Station_desc_apiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStation_desc_api>
          }
          groupBy: {
            args: Prisma.station_desc_apiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Station_desc_apiGroupByOutputType>[]
          }
          count: {
            args: Prisma.station_desc_apiCountArgs<ExtArgs>
            result: $Utils.Optional<Station_desc_apiCountAggregateOutputType> | number
          }
        }
      }
      station_description: {
        payload: Prisma.$station_descriptionPayload<ExtArgs>
        fields: Prisma.station_descriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.station_descriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_descriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.station_descriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_descriptionPayload>
          }
          findFirst: {
            args: Prisma.station_descriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_descriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.station_descriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_descriptionPayload>
          }
          findMany: {
            args: Prisma.station_descriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_descriptionPayload>[]
          }
          create: {
            args: Prisma.station_descriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_descriptionPayload>
          }
          createMany: {
            args: Prisma.station_descriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.station_descriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_descriptionPayload>
          }
          update: {
            args: Prisma.station_descriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_descriptionPayload>
          }
          deleteMany: {
            args: Prisma.station_descriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.station_descriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.station_descriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_descriptionPayload>
          }
          aggregate: {
            args: Prisma.Station_descriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStation_description>
          }
          groupBy: {
            args: Prisma.station_descriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Station_descriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.station_descriptionCountArgs<ExtArgs>
            result: $Utils.Optional<Station_descriptionCountAggregateOutputType> | number
          }
        }
      }
      station_marker: {
        payload: Prisma.$station_markerPayload<ExtArgs>
        fields: Prisma.station_markerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.station_markerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_markerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.station_markerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_markerPayload>
          }
          findFirst: {
            args: Prisma.station_markerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_markerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.station_markerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_markerPayload>
          }
          findMany: {
            args: Prisma.station_markerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_markerPayload>[]
          }
          create: {
            args: Prisma.station_markerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_markerPayload>
          }
          createMany: {
            args: Prisma.station_markerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.station_markerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_markerPayload>
          }
          update: {
            args: Prisma.station_markerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_markerPayload>
          }
          deleteMany: {
            args: Prisma.station_markerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.station_markerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.station_markerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$station_markerPayload>
          }
          aggregate: {
            args: Prisma.Station_markerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStation_marker>
          }
          groupBy: {
            args: Prisma.station_markerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Station_markerGroupByOutputType>[]
          }
          count: {
            args: Prisma.station_markerCountArgs<ExtArgs>
            result: $Utils.Optional<Station_markerCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SavedStations: {
        payload: Prisma.$SavedStationsPayload<ExtArgs>
        fields: Prisma.SavedStationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedStationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedStationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedStationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedStationsPayload>
          }
          findFirst: {
            args: Prisma.SavedStationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedStationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedStationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedStationsPayload>
          }
          findMany: {
            args: Prisma.SavedStationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedStationsPayload>[]
          }
          create: {
            args: Prisma.SavedStationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedStationsPayload>
          }
          createMany: {
            args: Prisma.SavedStationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SavedStationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedStationsPayload>
          }
          update: {
            args: Prisma.SavedStationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedStationsPayload>
          }
          deleteMany: {
            args: Prisma.SavedStationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedStationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SavedStationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedStationsPayload>
          }
          aggregate: {
            args: Prisma.SavedStationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedStations>
          }
          groupBy: {
            args: Prisma.SavedStationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedStationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedStationsCountArgs<ExtArgs>
            result: $Utils.Optional<SavedStationsCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      RecoveryToken: {
        payload: Prisma.$RecoveryTokenPayload<ExtArgs>
        fields: Prisma.RecoveryTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecoveryTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecoveryTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryTokenPayload>
          }
          findFirst: {
            args: Prisma.RecoveryTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecoveryTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryTokenPayload>
          }
          findMany: {
            args: Prisma.RecoveryTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryTokenPayload>[]
          }
          create: {
            args: Prisma.RecoveryTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryTokenPayload>
          }
          createMany: {
            args: Prisma.RecoveryTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecoveryTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryTokenPayload>
          }
          update: {
            args: Prisma.RecoveryTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryTokenPayload>
          }
          deleteMany: {
            args: Prisma.RecoveryTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecoveryTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecoveryTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecoveryTokenPayload>
          }
          aggregate: {
            args: Prisma.RecoveryTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecoveryToken>
          }
          groupBy: {
            args: Prisma.RecoveryTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecoveryTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecoveryTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RecoveryTokenCountAggregateOutputType> | number
          }
        }
      }
      UserPermissions: {
        payload: Prisma.$UserPermissionsPayload<ExtArgs>
        fields: Prisma.UserPermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionsPayload>
          }
          findFirst: {
            args: Prisma.UserPermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionsPayload>
          }
          findMany: {
            args: Prisma.UserPermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionsPayload>[]
          }
          create: {
            args: Prisma.UserPermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionsPayload>
          }
          createMany: {
            args: Prisma.UserPermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserPermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionsPayload>
          }
          update: {
            args: Prisma.UserPermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionsPayload>
          }
          deleteMany: {
            args: Prisma.UserPermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionsPayload>
          }
          aggregate: {
            args: Prisma.UserPermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPermissions>
          }
          groupBy: {
            args: Prisma.UserPermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<UserPermissionsCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      UserActivity: {
        payload: Prisma.$UserActivityPayload<ExtArgs>
        fields: Prisma.UserActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          findFirst: {
            args: Prisma.UserActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          findMany: {
            args: Prisma.UserActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>[]
          }
          create: {
            args: Prisma.UserActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          createMany: {
            args: Prisma.UserActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          update: {
            args: Prisma.UserActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          deleteMany: {
            args: Prisma.UserActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          aggregate: {
            args: Prisma.UserActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserActivity>
          }
          groupBy: {
            args: Prisma.UserActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserActivityCountArgs<ExtArgs>
            result: $Utils.Optional<UserActivityCountAggregateOutputType> | number
          }
        }
      }
      UserBan: {
        payload: Prisma.$UserBanPayload<ExtArgs>
        fields: Prisma.UserBanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBanPayload>
          }
          findFirst: {
            args: Prisma.UserBanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBanPayload>
          }
          findMany: {
            args: Prisma.UserBanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBanPayload>[]
          }
          create: {
            args: Prisma.UserBanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBanPayload>
          }
          createMany: {
            args: Prisma.UserBanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserBanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBanPayload>
          }
          update: {
            args: Prisma.UserBanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBanPayload>
          }
          deleteMany: {
            args: Prisma.UserBanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBanPayload>
          }
          aggregate: {
            args: Prisma.UserBanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBan>
          }
          groupBy: {
            args: Prisma.UserBanGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBanGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBanCountArgs<ExtArgs>
            result: $Utils.Optional<UserBanCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    api_source?: api_sourceOmit
    comments?: commentsOmit
    images?: imagesOmit
    station_connector?: station_connectorOmit
    station_desc_api?: station_desc_apiOmit
    station_description?: station_descriptionOmit
    station_marker?: station_markerOmit
    user?: UserOmit
    savedStations?: SavedStationsOmit
    role?: RoleOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
    recoveryToken?: RecoveryTokenOmit
    userPermissions?: UserPermissionsOmit
    userSession?: UserSessionOmit
    userActivity?: UserActivityOmit
    userBan?: UserBanOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Api_sourceCountOutputType
   */

  export type Api_sourceCountOutputType = {
    station_desc_api: number
  }

  export type Api_sourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    station_desc_api?: boolean | Api_sourceCountOutputTypeCountStation_desc_apiArgs
  }

  // Custom InputTypes
  /**
   * Api_sourceCountOutputType without action
   */
  export type Api_sourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Api_sourceCountOutputType
     */
    select?: Api_sourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Api_sourceCountOutputType without action
   */
  export type Api_sourceCountOutputTypeCountStation_desc_apiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: station_desc_apiWhereInput
  }


  /**
   * Count Type Station_descriptionCountOutputType
   */

  export type Station_descriptionCountOutputType = {
    comments: number
    images: number
    station_connector: number
    station_desc_api: number
  }

  export type Station_descriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Station_descriptionCountOutputTypeCountCommentsArgs
    images?: boolean | Station_descriptionCountOutputTypeCountImagesArgs
    station_connector?: boolean | Station_descriptionCountOutputTypeCountStation_connectorArgs
    station_desc_api?: boolean | Station_descriptionCountOutputTypeCountStation_desc_apiArgs
  }

  // Custom InputTypes
  /**
   * Station_descriptionCountOutputType without action
   */
  export type Station_descriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station_descriptionCountOutputType
     */
    select?: Station_descriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Station_descriptionCountOutputType without action
   */
  export type Station_descriptionCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }

  /**
   * Station_descriptionCountOutputType without action
   */
  export type Station_descriptionCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
  }

  /**
   * Station_descriptionCountOutputType without action
   */
  export type Station_descriptionCountOutputTypeCountStation_connectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: station_connectorWhereInput
  }

  /**
   * Station_descriptionCountOutputType without action
   */
  export type Station_descriptionCountOutputTypeCountStation_desc_apiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: station_desc_apiWhereInput
  }


  /**
   * Count Type Station_markerCountOutputType
   */

  export type Station_markerCountOutputType = {
    station_description: number
    savedStations: number
  }

  export type Station_markerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    station_description?: boolean | Station_markerCountOutputTypeCountStation_descriptionArgs
    savedStations?: boolean | Station_markerCountOutputTypeCountSavedStationsArgs
  }

  // Custom InputTypes
  /**
   * Station_markerCountOutputType without action
   */
  export type Station_markerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station_markerCountOutputType
     */
    select?: Station_markerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Station_markerCountOutputType without action
   */
  export type Station_markerCountOutputTypeCountStation_descriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: station_descriptionWhereInput
  }

  /**
   * Station_markerCountOutputType without action
   */
  export type Station_markerCountOutputTypeCountSavedStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedStationsWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    permissions: number
    activities: number
    RecoveryToken: number
    comments: number
    savedStations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | UserCountOutputTypeCountPermissionsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    RecoveryToken?: boolean | UserCountOutputTypeCountRecoveryTokenArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    savedStations?: boolean | UserCountOutputTypeCountSavedStationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecoveryTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedStationsWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type RolePermissionCountOutputType
   */

  export type RolePermissionCountOutputType = {
    users: number
  }

  export type RolePermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RolePermissionCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RolePermissionCountOutputType without action
   */
  export type RolePermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissionCountOutputType
     */
    select?: RolePermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolePermissionCountOutputType without action
   */
  export type RolePermissionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model api_source
   */

  export type AggregateApi_source = {
    _count: Api_sourceCountAggregateOutputType | null
    _avg: Api_sourceAvgAggregateOutputType | null
    _sum: Api_sourceSumAggregateOutputType | null
    _min: Api_sourceMinAggregateOutputType | null
    _max: Api_sourceMaxAggregateOutputType | null
  }

  export type Api_sourceAvgAggregateOutputType = {
    api_id: number | null
    last_update: number | null
    next_update: number | null
    update_interval_ms: number | null
  }

  export type Api_sourceSumAggregateOutputType = {
    api_id: number | null
    last_update: bigint | null
    next_update: bigint | null
    update_interval_ms: bigint | null
  }

  export type Api_sourceMinAggregateOutputType = {
    api_id: number | null
    link: string | null
    detailed_link: string | null
    last_update: bigint | null
    next_update: bigint | null
    update_interval_ms: bigint | null
    comments_link: string | null
  }

  export type Api_sourceMaxAggregateOutputType = {
    api_id: number | null
    link: string | null
    detailed_link: string | null
    last_update: bigint | null
    next_update: bigint | null
    update_interval_ms: bigint | null
    comments_link: string | null
  }

  export type Api_sourceCountAggregateOutputType = {
    api_id: number
    link: number
    detailed_link: number
    last_update: number
    next_update: number
    update_interval_ms: number
    comments_link: number
    _all: number
  }


  export type Api_sourceAvgAggregateInputType = {
    api_id?: true
    last_update?: true
    next_update?: true
    update_interval_ms?: true
  }

  export type Api_sourceSumAggregateInputType = {
    api_id?: true
    last_update?: true
    next_update?: true
    update_interval_ms?: true
  }

  export type Api_sourceMinAggregateInputType = {
    api_id?: true
    link?: true
    detailed_link?: true
    last_update?: true
    next_update?: true
    update_interval_ms?: true
    comments_link?: true
  }

  export type Api_sourceMaxAggregateInputType = {
    api_id?: true
    link?: true
    detailed_link?: true
    last_update?: true
    next_update?: true
    update_interval_ms?: true
    comments_link?: true
  }

  export type Api_sourceCountAggregateInputType = {
    api_id?: true
    link?: true
    detailed_link?: true
    last_update?: true
    next_update?: true
    update_interval_ms?: true
    comments_link?: true
    _all?: true
  }

  export type Api_sourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_source to aggregate.
     */
    where?: api_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_sources to fetch.
     */
    orderBy?: api_sourceOrderByWithRelationInput | api_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: api_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned api_sources
    **/
    _count?: true | Api_sourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Api_sourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Api_sourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Api_sourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Api_sourceMaxAggregateInputType
  }

  export type GetApi_sourceAggregateType<T extends Api_sourceAggregateArgs> = {
        [P in keyof T & keyof AggregateApi_source]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApi_source[P]>
      : GetScalarType<T[P], AggregateApi_source[P]>
  }




  export type api_sourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: api_sourceWhereInput
    orderBy?: api_sourceOrderByWithAggregationInput | api_sourceOrderByWithAggregationInput[]
    by: Api_sourceScalarFieldEnum[] | Api_sourceScalarFieldEnum
    having?: api_sourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Api_sourceCountAggregateInputType | true
    _avg?: Api_sourceAvgAggregateInputType
    _sum?: Api_sourceSumAggregateInputType
    _min?: Api_sourceMinAggregateInputType
    _max?: Api_sourceMaxAggregateInputType
  }

  export type Api_sourceGroupByOutputType = {
    api_id: number
    link: string
    detailed_link: string
    last_update: bigint | null
    next_update: bigint | null
    update_interval_ms: bigint | null
    comments_link: string | null
    _count: Api_sourceCountAggregateOutputType | null
    _avg: Api_sourceAvgAggregateOutputType | null
    _sum: Api_sourceSumAggregateOutputType | null
    _min: Api_sourceMinAggregateOutputType | null
    _max: Api_sourceMaxAggregateOutputType | null
  }

  type GetApi_sourceGroupByPayload<T extends api_sourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Api_sourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Api_sourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Api_sourceGroupByOutputType[P]>
            : GetScalarType<T[P], Api_sourceGroupByOutputType[P]>
        }
      >
    >


  export type api_sourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    api_id?: boolean
    link?: boolean
    detailed_link?: boolean
    last_update?: boolean
    next_update?: boolean
    update_interval_ms?: boolean
    comments_link?: boolean
    station_desc_api?: boolean | api_source$station_desc_apiArgs<ExtArgs>
    _count?: boolean | Api_sourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["api_source"]>



  export type api_sourceSelectScalar = {
    api_id?: boolean
    link?: boolean
    detailed_link?: boolean
    last_update?: boolean
    next_update?: boolean
    update_interval_ms?: boolean
    comments_link?: boolean
  }

  export type api_sourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"api_id" | "link" | "detailed_link" | "last_update" | "next_update" | "update_interval_ms" | "comments_link", ExtArgs["result"]["api_source"]>
  export type api_sourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    station_desc_api?: boolean | api_source$station_desc_apiArgs<ExtArgs>
    _count?: boolean | Api_sourceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $api_sourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "api_source"
    objects: {
      station_desc_api: Prisma.$station_desc_apiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      api_id: number
      link: string
      detailed_link: string
      last_update: bigint | null
      next_update: bigint | null
      update_interval_ms: bigint | null
      comments_link: string | null
    }, ExtArgs["result"]["api_source"]>
    composites: {}
  }

  type api_sourceGetPayload<S extends boolean | null | undefined | api_sourceDefaultArgs> = $Result.GetResult<Prisma.$api_sourcePayload, S>

  type api_sourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<api_sourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Api_sourceCountAggregateInputType | true
    }

  export interface api_sourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['api_source'], meta: { name: 'api_source' } }
    /**
     * Find zero or one Api_source that matches the filter.
     * @param {api_sourceFindUniqueArgs} args - Arguments to find a Api_source
     * @example
     * // Get one Api_source
     * const api_source = await prisma.api_source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends api_sourceFindUniqueArgs>(args: SelectSubset<T, api_sourceFindUniqueArgs<ExtArgs>>): Prisma__api_sourceClient<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Api_source that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {api_sourceFindUniqueOrThrowArgs} args - Arguments to find a Api_source
     * @example
     * // Get one Api_source
     * const api_source = await prisma.api_source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends api_sourceFindUniqueOrThrowArgs>(args: SelectSubset<T, api_sourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__api_sourceClient<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Api_source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_sourceFindFirstArgs} args - Arguments to find a Api_source
     * @example
     * // Get one Api_source
     * const api_source = await prisma.api_source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends api_sourceFindFirstArgs>(args?: SelectSubset<T, api_sourceFindFirstArgs<ExtArgs>>): Prisma__api_sourceClient<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Api_source that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_sourceFindFirstOrThrowArgs} args - Arguments to find a Api_source
     * @example
     * // Get one Api_source
     * const api_source = await prisma.api_source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends api_sourceFindFirstOrThrowArgs>(args?: SelectSubset<T, api_sourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__api_sourceClient<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Api_sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_sourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Api_sources
     * const api_sources = await prisma.api_source.findMany()
     * 
     * // Get first 10 Api_sources
     * const api_sources = await prisma.api_source.findMany({ take: 10 })
     * 
     * // Only select the `api_id`
     * const api_sourceWithApi_idOnly = await prisma.api_source.findMany({ select: { api_id: true } })
     * 
     */
    findMany<T extends api_sourceFindManyArgs>(args?: SelectSubset<T, api_sourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Api_source.
     * @param {api_sourceCreateArgs} args - Arguments to create a Api_source.
     * @example
     * // Create one Api_source
     * const Api_source = await prisma.api_source.create({
     *   data: {
     *     // ... data to create a Api_source
     *   }
     * })
     * 
     */
    create<T extends api_sourceCreateArgs>(args: SelectSubset<T, api_sourceCreateArgs<ExtArgs>>): Prisma__api_sourceClient<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Api_sources.
     * @param {api_sourceCreateManyArgs} args - Arguments to create many Api_sources.
     * @example
     * // Create many Api_sources
     * const api_source = await prisma.api_source.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends api_sourceCreateManyArgs>(args?: SelectSubset<T, api_sourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Api_source.
     * @param {api_sourceDeleteArgs} args - Arguments to delete one Api_source.
     * @example
     * // Delete one Api_source
     * const Api_source = await prisma.api_source.delete({
     *   where: {
     *     // ... filter to delete one Api_source
     *   }
     * })
     * 
     */
    delete<T extends api_sourceDeleteArgs>(args: SelectSubset<T, api_sourceDeleteArgs<ExtArgs>>): Prisma__api_sourceClient<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Api_source.
     * @param {api_sourceUpdateArgs} args - Arguments to update one Api_source.
     * @example
     * // Update one Api_source
     * const api_source = await prisma.api_source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends api_sourceUpdateArgs>(args: SelectSubset<T, api_sourceUpdateArgs<ExtArgs>>): Prisma__api_sourceClient<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Api_sources.
     * @param {api_sourceDeleteManyArgs} args - Arguments to filter Api_sources to delete.
     * @example
     * // Delete a few Api_sources
     * const { count } = await prisma.api_source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends api_sourceDeleteManyArgs>(args?: SelectSubset<T, api_sourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Api_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_sourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Api_sources
     * const api_source = await prisma.api_source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends api_sourceUpdateManyArgs>(args: SelectSubset<T, api_sourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Api_source.
     * @param {api_sourceUpsertArgs} args - Arguments to update or create a Api_source.
     * @example
     * // Update or create a Api_source
     * const api_source = await prisma.api_source.upsert({
     *   create: {
     *     // ... data to create a Api_source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Api_source we want to update
     *   }
     * })
     */
    upsert<T extends api_sourceUpsertArgs>(args: SelectSubset<T, api_sourceUpsertArgs<ExtArgs>>): Prisma__api_sourceClient<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Api_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_sourceCountArgs} args - Arguments to filter Api_sources to count.
     * @example
     * // Count the number of Api_sources
     * const count = await prisma.api_source.count({
     *   where: {
     *     // ... the filter for the Api_sources we want to count
     *   }
     * })
    **/
    count<T extends api_sourceCountArgs>(
      args?: Subset<T, api_sourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Api_sourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Api_source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Api_sourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Api_sourceAggregateArgs>(args: Subset<T, Api_sourceAggregateArgs>): Prisma.PrismaPromise<GetApi_sourceAggregateType<T>>

    /**
     * Group by Api_source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_sourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends api_sourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: api_sourceGroupByArgs['orderBy'] }
        : { orderBy?: api_sourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, api_sourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApi_sourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the api_source model
   */
  readonly fields: api_sourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for api_source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__api_sourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    station_desc_api<T extends api_source$station_desc_apiArgs<ExtArgs> = {}>(args?: Subset<T, api_source$station_desc_apiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the api_source model
   */
  interface api_sourceFieldRefs {
    readonly api_id: FieldRef<"api_source", 'Int'>
    readonly link: FieldRef<"api_source", 'String'>
    readonly detailed_link: FieldRef<"api_source", 'String'>
    readonly last_update: FieldRef<"api_source", 'BigInt'>
    readonly next_update: FieldRef<"api_source", 'BigInt'>
    readonly update_interval_ms: FieldRef<"api_source", 'BigInt'>
    readonly comments_link: FieldRef<"api_source", 'String'>
  }
    

  // Custom InputTypes
  /**
   * api_source findUnique
   */
  export type api_sourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    /**
     * Filter, which api_source to fetch.
     */
    where: api_sourceWhereUniqueInput
  }

  /**
   * api_source findUniqueOrThrow
   */
  export type api_sourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    /**
     * Filter, which api_source to fetch.
     */
    where: api_sourceWhereUniqueInput
  }

  /**
   * api_source findFirst
   */
  export type api_sourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    /**
     * Filter, which api_source to fetch.
     */
    where?: api_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_sources to fetch.
     */
    orderBy?: api_sourceOrderByWithRelationInput | api_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_sources.
     */
    cursor?: api_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_sources.
     */
    distinct?: Api_sourceScalarFieldEnum | Api_sourceScalarFieldEnum[]
  }

  /**
   * api_source findFirstOrThrow
   */
  export type api_sourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    /**
     * Filter, which api_source to fetch.
     */
    where?: api_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_sources to fetch.
     */
    orderBy?: api_sourceOrderByWithRelationInput | api_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_sources.
     */
    cursor?: api_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_sources.
     */
    distinct?: Api_sourceScalarFieldEnum | Api_sourceScalarFieldEnum[]
  }

  /**
   * api_source findMany
   */
  export type api_sourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    /**
     * Filter, which api_sources to fetch.
     */
    where?: api_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_sources to fetch.
     */
    orderBy?: api_sourceOrderByWithRelationInput | api_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing api_sources.
     */
    cursor?: api_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_sources.
     */
    skip?: number
    distinct?: Api_sourceScalarFieldEnum | Api_sourceScalarFieldEnum[]
  }

  /**
   * api_source create
   */
  export type api_sourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    /**
     * The data needed to create a api_source.
     */
    data: XOR<api_sourceCreateInput, api_sourceUncheckedCreateInput>
  }

  /**
   * api_source createMany
   */
  export type api_sourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many api_sources.
     */
    data: api_sourceCreateManyInput | api_sourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * api_source update
   */
  export type api_sourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    /**
     * The data needed to update a api_source.
     */
    data: XOR<api_sourceUpdateInput, api_sourceUncheckedUpdateInput>
    /**
     * Choose, which api_source to update.
     */
    where: api_sourceWhereUniqueInput
  }

  /**
   * api_source updateMany
   */
  export type api_sourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update api_sources.
     */
    data: XOR<api_sourceUpdateManyMutationInput, api_sourceUncheckedUpdateManyInput>
    /**
     * Filter which api_sources to update
     */
    where?: api_sourceWhereInput
    /**
     * Limit how many api_sources to update.
     */
    limit?: number
  }

  /**
   * api_source upsert
   */
  export type api_sourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    /**
     * The filter to search for the api_source to update in case it exists.
     */
    where: api_sourceWhereUniqueInput
    /**
     * In case the api_source found by the `where` argument doesn't exist, create a new api_source with this data.
     */
    create: XOR<api_sourceCreateInput, api_sourceUncheckedCreateInput>
    /**
     * In case the api_source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<api_sourceUpdateInput, api_sourceUncheckedUpdateInput>
  }

  /**
   * api_source delete
   */
  export type api_sourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    /**
     * Filter which api_source to delete.
     */
    where: api_sourceWhereUniqueInput
  }

  /**
   * api_source deleteMany
   */
  export type api_sourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_sources to delete
     */
    where?: api_sourceWhereInput
    /**
     * Limit how many api_sources to delete.
     */
    limit?: number
  }

  /**
   * api_source.station_desc_api
   */
  export type api_source$station_desc_apiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    where?: station_desc_apiWhereInput
    orderBy?: station_desc_apiOrderByWithRelationInput | station_desc_apiOrderByWithRelationInput[]
    cursor?: station_desc_apiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Station_desc_apiScalarFieldEnum | Station_desc_apiScalarFieldEnum[]
  }

  /**
   * api_source without action
   */
  export type api_sourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
  }


  /**
   * Model comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    comment_id: number | null
    description_id: number | null
    user_id: number | null
    rating: number | null
  }

  export type CommentsSumAggregateOutputType = {
    comment_id: number | null
    description_id: number | null
    user_id: number | null
    rating: number | null
  }

  export type CommentsMinAggregateOutputType = {
    comment_id: number | null
    description_id: number | null
    comment_href: string | null
    author_name: string | null
    user_id: number | null
    rating: number | null
    comment_text: string | null
  }

  export type CommentsMaxAggregateOutputType = {
    comment_id: number | null
    description_id: number | null
    comment_href: string | null
    author_name: string | null
    user_id: number | null
    rating: number | null
    comment_text: string | null
  }

  export type CommentsCountAggregateOutputType = {
    comment_id: number
    description_id: number
    comment_href: number
    author_name: number
    user_id: number
    rating: number
    comment_text: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    comment_id?: true
    description_id?: true
    user_id?: true
    rating?: true
  }

  export type CommentsSumAggregateInputType = {
    comment_id?: true
    description_id?: true
    user_id?: true
    rating?: true
  }

  export type CommentsMinAggregateInputType = {
    comment_id?: true
    description_id?: true
    comment_href?: true
    author_name?: true
    user_id?: true
    rating?: true
    comment_text?: true
  }

  export type CommentsMaxAggregateInputType = {
    comment_id?: true
    description_id?: true
    comment_href?: true
    author_name?: true
    user_id?: true
    rating?: true
    comment_text?: true
  }

  export type CommentsCountAggregateInputType = {
    comment_id?: true
    description_id?: true
    comment_href?: true
    author_name?: true
    user_id?: true
    rating?: true
    comment_text?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to aggregate.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithAggregationInput | commentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    comment_id: number
    description_id: number | null
    comment_href: string | null
    author_name: string | null
    user_id: number | null
    rating: number | null
    comment_text: string | null
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends commentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    description_id?: boolean
    comment_href?: boolean
    author_name?: boolean
    user_id?: boolean
    rating?: boolean
    comment_text?: boolean
    user?: boolean | comments$userArgs<ExtArgs>
    station_description?: boolean | comments$station_descriptionArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>



  export type commentsSelectScalar = {
    comment_id?: boolean
    description_id?: boolean
    comment_href?: boolean
    author_name?: boolean
    user_id?: boolean
    rating?: boolean
    comment_text?: boolean
  }

  export type commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"comment_id" | "description_id" | "comment_href" | "author_name" | "user_id" | "rating" | "comment_text", ExtArgs["result"]["comments"]>
  export type commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | comments$userArgs<ExtArgs>
    station_description?: boolean | comments$station_descriptionArgs<ExtArgs>
  }

  export type $commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comments"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      station_description: Prisma.$station_descriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      comment_id: number
      description_id: number | null
      comment_href: string | null
      author_name: string | null
      user_id: number | null
      rating: number | null
      comment_text: string | null
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }

  type commentsGetPayload<S extends boolean | null | undefined | commentsDefaultArgs> = $Result.GetResult<Prisma.$commentsPayload, S>

  type commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commentsFindUniqueArgs>(args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs>(args: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commentsFindFirstArgs>(args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs>(args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `comment_id`
     * const commentsWithComment_idOnly = await prisma.comments.findMany({ select: { comment_id: true } })
     * 
     */
    findMany<T extends commentsFindManyArgs>(args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comments.
     * @param {commentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
     */
    create<T extends commentsCreateArgs>(args: SelectSubset<T, commentsCreateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {commentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends commentsCreateManyArgs>(args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comments.
     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
     */
    delete<T extends commentsDeleteArgs>(args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comments.
     * @param {commentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends commentsUpdateArgs>(args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends commentsDeleteManyArgs>(args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends commentsUpdateManyArgs>(args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comments.
     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends commentsUpsertArgs>(args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentsCountArgs>(
      args?: Subset<T, commentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentsGroupByArgs['orderBy'] }
        : { orderBy?: commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comments model
   */
  readonly fields: commentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends comments$userArgs<ExtArgs> = {}>(args?: Subset<T, comments$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    station_description<T extends comments$station_descriptionArgs<ExtArgs> = {}>(args?: Subset<T, comments$station_descriptionArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comments model
   */
  interface commentsFieldRefs {
    readonly comment_id: FieldRef<"comments", 'Int'>
    readonly description_id: FieldRef<"comments", 'Int'>
    readonly comment_href: FieldRef<"comments", 'String'>
    readonly author_name: FieldRef<"comments", 'String'>
    readonly user_id: FieldRef<"comments", 'Int'>
    readonly rating: FieldRef<"comments", 'Float'>
    readonly comment_text: FieldRef<"comments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * comments findUnique
   */
  export type commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findUniqueOrThrow
   */
  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findFirst
   */
  export type commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findFirstOrThrow
   */
  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findMany
   */
  export type commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments create
   */
  export type commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to create a comments.
     */
    data?: XOR<commentsCreateInput, commentsUncheckedCreateInput>
  }

  /**
   * comments createMany
   */
  export type commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comments update
   */
  export type commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to update a comments.
     */
    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
    /**
     * Choose, which comments to update.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments updateMany
   */
  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
  }

  /**
   * comments upsert
   */
  export type commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The filter to search for the comments to update in case it exists.
     */
    where: commentsWhereUniqueInput
    /**
     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.
     */
    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>
    /**
     * In case the comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
  }

  /**
   * comments delete
   */
  export type commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter which comments to delete.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments deleteMany
   */
  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to delete.
     */
    limit?: number
  }

  /**
   * comments.user
   */
  export type comments$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * comments.station_description
   */
  export type comments$station_descriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    where?: station_descriptionWhereInput
  }

  /**
   * comments without action
   */
  export type commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
  }


  /**
   * Model images
   */

  export type AggregateImages = {
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  export type ImagesAvgAggregateOutputType = {
    image_id: number | null
    description_id: number | null
  }

  export type ImagesSumAggregateOutputType = {
    image_id: number | null
    description_id: number | null
  }

  export type ImagesMinAggregateOutputType = {
    image_id: number | null
    description_id: number | null
    image_href: string | null
  }

  export type ImagesMaxAggregateOutputType = {
    image_id: number | null
    description_id: number | null
    image_href: string | null
  }

  export type ImagesCountAggregateOutputType = {
    image_id: number
    description_id: number
    image_href: number
    _all: number
  }


  export type ImagesAvgAggregateInputType = {
    image_id?: true
    description_id?: true
  }

  export type ImagesSumAggregateInputType = {
    image_id?: true
    description_id?: true
  }

  export type ImagesMinAggregateInputType = {
    image_id?: true
    description_id?: true
    image_href?: true
  }

  export type ImagesMaxAggregateInputType = {
    image_id?: true
    description_id?: true
    image_href?: true
  }

  export type ImagesCountAggregateInputType = {
    image_id?: true
    description_id?: true
    image_href?: true
    _all?: true
  }

  export type ImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images to aggregate.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned images
    **/
    _count?: true | ImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagesMaxAggregateInputType
  }

  export type GetImagesAggregateType<T extends ImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImages[P]>
      : GetScalarType<T[P], AggregateImages[P]>
  }




  export type imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithAggregationInput | imagesOrderByWithAggregationInput[]
    by: ImagesScalarFieldEnum[] | ImagesScalarFieldEnum
    having?: imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagesCountAggregateInputType | true
    _avg?: ImagesAvgAggregateInputType
    _sum?: ImagesSumAggregateInputType
    _min?: ImagesMinAggregateInputType
    _max?: ImagesMaxAggregateInputType
  }

  export type ImagesGroupByOutputType = {
    image_id: number
    description_id: number | null
    image_href: string | null
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  type GetImagesGroupByPayload<T extends imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ImagesGroupByOutputType[P]>
        }
      >
    >


  export type imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    image_id?: boolean
    description_id?: boolean
    image_href?: boolean
    station_description?: boolean | images$station_descriptionArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>



  export type imagesSelectScalar = {
    image_id?: boolean
    description_id?: boolean
    image_href?: boolean
  }

  export type imagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"image_id" | "description_id" | "image_href", ExtArgs["result"]["images"]>
  export type imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    station_description?: boolean | images$station_descriptionArgs<ExtArgs>
  }

  export type $imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "images"
    objects: {
      station_description: Prisma.$station_descriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      image_id: number
      description_id: number | null
      image_href: string | null
    }, ExtArgs["result"]["images"]>
    composites: {}
  }

  type imagesGetPayload<S extends boolean | null | undefined | imagesDefaultArgs> = $Result.GetResult<Prisma.$imagesPayload, S>

  type imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<imagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImagesCountAggregateInputType | true
    }

  export interface imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['images'], meta: { name: 'images' } }
    /**
     * Find zero or one Images that matches the filter.
     * @param {imagesFindUniqueArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends imagesFindUniqueArgs>(args: SelectSubset<T, imagesFindUniqueArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Images that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {imagesFindUniqueOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends imagesFindUniqueOrThrowArgs>(args: SelectSubset<T, imagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends imagesFindFirstArgs>(args?: SelectSubset<T, imagesFindFirstArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends imagesFindFirstOrThrowArgs>(args?: SelectSubset<T, imagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.images.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.images.findMany({ take: 10 })
     * 
     * // Only select the `image_id`
     * const imagesWithImage_idOnly = await prisma.images.findMany({ select: { image_id: true } })
     * 
     */
    findMany<T extends imagesFindManyArgs>(args?: SelectSubset<T, imagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Images.
     * @param {imagesCreateArgs} args - Arguments to create a Images.
     * @example
     * // Create one Images
     * const Images = await prisma.images.create({
     *   data: {
     *     // ... data to create a Images
     *   }
     * })
     * 
     */
    create<T extends imagesCreateArgs>(args: SelectSubset<T, imagesCreateArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {imagesCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const images = await prisma.images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends imagesCreateManyArgs>(args?: SelectSubset<T, imagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Images.
     * @param {imagesDeleteArgs} args - Arguments to delete one Images.
     * @example
     * // Delete one Images
     * const Images = await prisma.images.delete({
     *   where: {
     *     // ... filter to delete one Images
     *   }
     * })
     * 
     */
    delete<T extends imagesDeleteArgs>(args: SelectSubset<T, imagesDeleteArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Images.
     * @param {imagesUpdateArgs} args - Arguments to update one Images.
     * @example
     * // Update one Images
     * const images = await prisma.images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends imagesUpdateArgs>(args: SelectSubset<T, imagesUpdateArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {imagesDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends imagesDeleteManyArgs>(args?: SelectSubset<T, imagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends imagesUpdateManyArgs>(args: SelectSubset<T, imagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Images.
     * @param {imagesUpsertArgs} args - Arguments to update or create a Images.
     * @example
     * // Update or create a Images
     * const images = await prisma.images.upsert({
     *   create: {
     *     // ... data to create a Images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Images we want to update
     *   }
     * })
     */
    upsert<T extends imagesUpsertArgs>(args: SelectSubset<T, imagesUpsertArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.images.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends imagesCountArgs>(
      args?: Subset<T, imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagesAggregateArgs>(args: Subset<T, ImagesAggregateArgs>): Prisma.PrismaPromise<GetImagesAggregateType<T>>

    /**
     * Group by Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: imagesGroupByArgs['orderBy'] }
        : { orderBy?: imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the images model
   */
  readonly fields: imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    station_description<T extends images$station_descriptionArgs<ExtArgs> = {}>(args?: Subset<T, images$station_descriptionArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the images model
   */
  interface imagesFieldRefs {
    readonly image_id: FieldRef<"images", 'Int'>
    readonly description_id: FieldRef<"images", 'Int'>
    readonly image_href: FieldRef<"images", 'String'>
  }
    

  // Custom InputTypes
  /**
   * images findUnique
   */
  export type imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images findUniqueOrThrow
   */
  export type imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images findFirst
   */
  export type imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * images findFirstOrThrow
   */
  export type imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * images findMany
   */
  export type imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * images create
   */
  export type imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a images.
     */
    data?: XOR<imagesCreateInput, imagesUncheckedCreateInput>
  }

  /**
   * images createMany
   */
  export type imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many images.
     */
    data: imagesCreateManyInput | imagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * images update
   */
  export type imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a images.
     */
    data: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
    /**
     * Choose, which images to update.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images updateMany
   */
  export type imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update images.
     */
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyInput>
    /**
     * Filter which images to update
     */
    where?: imagesWhereInput
    /**
     * Limit how many images to update.
     */
    limit?: number
  }

  /**
   * images upsert
   */
  export type imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the images to update in case it exists.
     */
    where: imagesWhereUniqueInput
    /**
     * In case the images found by the `where` argument doesn't exist, create a new images with this data.
     */
    create: XOR<imagesCreateInput, imagesUncheckedCreateInput>
    /**
     * In case the images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
  }

  /**
   * images delete
   */
  export type imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter which images to delete.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images deleteMany
   */
  export type imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images to delete
     */
    where?: imagesWhereInput
    /**
     * Limit how many images to delete.
     */
    limit?: number
  }

  /**
   * images.station_description
   */
  export type images$station_descriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    where?: station_descriptionWhereInput
  }

  /**
   * images without action
   */
  export type imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
  }


  /**
   * Model station_connector
   */

  export type AggregateStation_connector = {
    _count: Station_connectorCountAggregateOutputType | null
    _avg: Station_connectorAvgAggregateOutputType | null
    _sum: Station_connectorSumAggregateOutputType | null
    _min: Station_connectorMinAggregateOutputType | null
    _max: Station_connectorMaxAggregateOutputType | null
  }

  export type Station_connectorAvgAggregateOutputType = {
    connector_id: number | null
    description_id: number | null
    connector_type_id: number | null
    connector_status_id: number | null
    power_kw: number | null
    current_amp: number | null
    price_per_start: Decimal | null
    price: Decimal | null
    free_min_after_charging: number | null
    price_per_min_after_charging: Decimal | null
  }

  export type Station_connectorSumAggregateOutputType = {
    connector_id: number | null
    description_id: number | null
    connector_type_id: number | null
    connector_status_id: number | null
    power_kw: number | null
    current_amp: number | null
    price_per_start: Decimal | null
    price: Decimal | null
    free_min_after_charging: number | null
    price_per_min_after_charging: Decimal | null
  }

  export type Station_connectorMinAggregateOutputType = {
    connector_id: number | null
    description_id: number | null
    connector_type_id: number | null
    connector_status_id: number | null
    connector_name: string | null
    power_kw: number | null
    current_amp: number | null
    price_per_start: Decimal | null
    price: Decimal | null
    currency: string | null
    free_min_after_charging: number | null
    price_per_min_after_charging: Decimal | null
  }

  export type Station_connectorMaxAggregateOutputType = {
    connector_id: number | null
    description_id: number | null
    connector_type_id: number | null
    connector_status_id: number | null
    connector_name: string | null
    power_kw: number | null
    current_amp: number | null
    price_per_start: Decimal | null
    price: Decimal | null
    currency: string | null
    free_min_after_charging: number | null
    price_per_min_after_charging: Decimal | null
  }

  export type Station_connectorCountAggregateOutputType = {
    connector_id: number
    description_id: number
    connector_type_id: number
    connector_status_id: number
    connector_name: number
    power_kw: number
    current_amp: number
    price_per_start: number
    price: number
    currency: number
    free_min_after_charging: number
    price_per_min_after_charging: number
    _all: number
  }


  export type Station_connectorAvgAggregateInputType = {
    connector_id?: true
    description_id?: true
    connector_type_id?: true
    connector_status_id?: true
    power_kw?: true
    current_amp?: true
    price_per_start?: true
    price?: true
    free_min_after_charging?: true
    price_per_min_after_charging?: true
  }

  export type Station_connectorSumAggregateInputType = {
    connector_id?: true
    description_id?: true
    connector_type_id?: true
    connector_status_id?: true
    power_kw?: true
    current_amp?: true
    price_per_start?: true
    price?: true
    free_min_after_charging?: true
    price_per_min_after_charging?: true
  }

  export type Station_connectorMinAggregateInputType = {
    connector_id?: true
    description_id?: true
    connector_type_id?: true
    connector_status_id?: true
    connector_name?: true
    power_kw?: true
    current_amp?: true
    price_per_start?: true
    price?: true
    currency?: true
    free_min_after_charging?: true
    price_per_min_after_charging?: true
  }

  export type Station_connectorMaxAggregateInputType = {
    connector_id?: true
    description_id?: true
    connector_type_id?: true
    connector_status_id?: true
    connector_name?: true
    power_kw?: true
    current_amp?: true
    price_per_start?: true
    price?: true
    currency?: true
    free_min_after_charging?: true
    price_per_min_after_charging?: true
  }

  export type Station_connectorCountAggregateInputType = {
    connector_id?: true
    description_id?: true
    connector_type_id?: true
    connector_status_id?: true
    connector_name?: true
    power_kw?: true
    current_amp?: true
    price_per_start?: true
    price?: true
    currency?: true
    free_min_after_charging?: true
    price_per_min_after_charging?: true
    _all?: true
  }

  export type Station_connectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which station_connector to aggregate.
     */
    where?: station_connectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_connectors to fetch.
     */
    orderBy?: station_connectorOrderByWithRelationInput | station_connectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: station_connectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_connectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_connectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned station_connectors
    **/
    _count?: true | Station_connectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Station_connectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Station_connectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Station_connectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Station_connectorMaxAggregateInputType
  }

  export type GetStation_connectorAggregateType<T extends Station_connectorAggregateArgs> = {
        [P in keyof T & keyof AggregateStation_connector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStation_connector[P]>
      : GetScalarType<T[P], AggregateStation_connector[P]>
  }




  export type station_connectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: station_connectorWhereInput
    orderBy?: station_connectorOrderByWithAggregationInput | station_connectorOrderByWithAggregationInput[]
    by: Station_connectorScalarFieldEnum[] | Station_connectorScalarFieldEnum
    having?: station_connectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Station_connectorCountAggregateInputType | true
    _avg?: Station_connectorAvgAggregateInputType
    _sum?: Station_connectorSumAggregateInputType
    _min?: Station_connectorMinAggregateInputType
    _max?: Station_connectorMaxAggregateInputType
  }

  export type Station_connectorGroupByOutputType = {
    connector_id: number
    description_id: number | null
    connector_type_id: number | null
    connector_status_id: number | null
    connector_name: string | null
    power_kw: number | null
    current_amp: number | null
    price_per_start: Decimal | null
    price: Decimal | null
    currency: string | null
    free_min_after_charging: number | null
    price_per_min_after_charging: Decimal | null
    _count: Station_connectorCountAggregateOutputType | null
    _avg: Station_connectorAvgAggregateOutputType | null
    _sum: Station_connectorSumAggregateOutputType | null
    _min: Station_connectorMinAggregateOutputType | null
    _max: Station_connectorMaxAggregateOutputType | null
  }

  type GetStation_connectorGroupByPayload<T extends station_connectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Station_connectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Station_connectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Station_connectorGroupByOutputType[P]>
            : GetScalarType<T[P], Station_connectorGroupByOutputType[P]>
        }
      >
    >


  export type station_connectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    connector_id?: boolean
    description_id?: boolean
    connector_type_id?: boolean
    connector_status_id?: boolean
    connector_name?: boolean
    power_kw?: boolean
    current_amp?: boolean
    price_per_start?: boolean
    price?: boolean
    currency?: boolean
    free_min_after_charging?: boolean
    price_per_min_after_charging?: boolean
    station_description?: boolean | station_connector$station_descriptionArgs<ExtArgs>
  }, ExtArgs["result"]["station_connector"]>



  export type station_connectorSelectScalar = {
    connector_id?: boolean
    description_id?: boolean
    connector_type_id?: boolean
    connector_status_id?: boolean
    connector_name?: boolean
    power_kw?: boolean
    current_amp?: boolean
    price_per_start?: boolean
    price?: boolean
    currency?: boolean
    free_min_after_charging?: boolean
    price_per_min_after_charging?: boolean
  }

  export type station_connectorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"connector_id" | "description_id" | "connector_type_id" | "connector_status_id" | "connector_name" | "power_kw" | "current_amp" | "price_per_start" | "price" | "currency" | "free_min_after_charging" | "price_per_min_after_charging", ExtArgs["result"]["station_connector"]>
  export type station_connectorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    station_description?: boolean | station_connector$station_descriptionArgs<ExtArgs>
  }

  export type $station_connectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "station_connector"
    objects: {
      station_description: Prisma.$station_descriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      connector_id: number
      description_id: number | null
      connector_type_id: number | null
      connector_status_id: number | null
      connector_name: string | null
      power_kw: number | null
      current_amp: number | null
      price_per_start: Prisma.Decimal | null
      price: Prisma.Decimal | null
      currency: string | null
      free_min_after_charging: number | null
      price_per_min_after_charging: Prisma.Decimal | null
    }, ExtArgs["result"]["station_connector"]>
    composites: {}
  }

  type station_connectorGetPayload<S extends boolean | null | undefined | station_connectorDefaultArgs> = $Result.GetResult<Prisma.$station_connectorPayload, S>

  type station_connectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<station_connectorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Station_connectorCountAggregateInputType | true
    }

  export interface station_connectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['station_connector'], meta: { name: 'station_connector' } }
    /**
     * Find zero or one Station_connector that matches the filter.
     * @param {station_connectorFindUniqueArgs} args - Arguments to find a Station_connector
     * @example
     * // Get one Station_connector
     * const station_connector = await prisma.station_connector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends station_connectorFindUniqueArgs>(args: SelectSubset<T, station_connectorFindUniqueArgs<ExtArgs>>): Prisma__station_connectorClient<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Station_connector that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {station_connectorFindUniqueOrThrowArgs} args - Arguments to find a Station_connector
     * @example
     * // Get one Station_connector
     * const station_connector = await prisma.station_connector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends station_connectorFindUniqueOrThrowArgs>(args: SelectSubset<T, station_connectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__station_connectorClient<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station_connector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_connectorFindFirstArgs} args - Arguments to find a Station_connector
     * @example
     * // Get one Station_connector
     * const station_connector = await prisma.station_connector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends station_connectorFindFirstArgs>(args?: SelectSubset<T, station_connectorFindFirstArgs<ExtArgs>>): Prisma__station_connectorClient<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station_connector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_connectorFindFirstOrThrowArgs} args - Arguments to find a Station_connector
     * @example
     * // Get one Station_connector
     * const station_connector = await prisma.station_connector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends station_connectorFindFirstOrThrowArgs>(args?: SelectSubset<T, station_connectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__station_connectorClient<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Station_connectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_connectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Station_connectors
     * const station_connectors = await prisma.station_connector.findMany()
     * 
     * // Get first 10 Station_connectors
     * const station_connectors = await prisma.station_connector.findMany({ take: 10 })
     * 
     * // Only select the `connector_id`
     * const station_connectorWithConnector_idOnly = await prisma.station_connector.findMany({ select: { connector_id: true } })
     * 
     */
    findMany<T extends station_connectorFindManyArgs>(args?: SelectSubset<T, station_connectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Station_connector.
     * @param {station_connectorCreateArgs} args - Arguments to create a Station_connector.
     * @example
     * // Create one Station_connector
     * const Station_connector = await prisma.station_connector.create({
     *   data: {
     *     // ... data to create a Station_connector
     *   }
     * })
     * 
     */
    create<T extends station_connectorCreateArgs>(args: SelectSubset<T, station_connectorCreateArgs<ExtArgs>>): Prisma__station_connectorClient<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Station_connectors.
     * @param {station_connectorCreateManyArgs} args - Arguments to create many Station_connectors.
     * @example
     * // Create many Station_connectors
     * const station_connector = await prisma.station_connector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends station_connectorCreateManyArgs>(args?: SelectSubset<T, station_connectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Station_connector.
     * @param {station_connectorDeleteArgs} args - Arguments to delete one Station_connector.
     * @example
     * // Delete one Station_connector
     * const Station_connector = await prisma.station_connector.delete({
     *   where: {
     *     // ... filter to delete one Station_connector
     *   }
     * })
     * 
     */
    delete<T extends station_connectorDeleteArgs>(args: SelectSubset<T, station_connectorDeleteArgs<ExtArgs>>): Prisma__station_connectorClient<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Station_connector.
     * @param {station_connectorUpdateArgs} args - Arguments to update one Station_connector.
     * @example
     * // Update one Station_connector
     * const station_connector = await prisma.station_connector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends station_connectorUpdateArgs>(args: SelectSubset<T, station_connectorUpdateArgs<ExtArgs>>): Prisma__station_connectorClient<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Station_connectors.
     * @param {station_connectorDeleteManyArgs} args - Arguments to filter Station_connectors to delete.
     * @example
     * // Delete a few Station_connectors
     * const { count } = await prisma.station_connector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends station_connectorDeleteManyArgs>(args?: SelectSubset<T, station_connectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Station_connectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_connectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Station_connectors
     * const station_connector = await prisma.station_connector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends station_connectorUpdateManyArgs>(args: SelectSubset<T, station_connectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Station_connector.
     * @param {station_connectorUpsertArgs} args - Arguments to update or create a Station_connector.
     * @example
     * // Update or create a Station_connector
     * const station_connector = await prisma.station_connector.upsert({
     *   create: {
     *     // ... data to create a Station_connector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Station_connector we want to update
     *   }
     * })
     */
    upsert<T extends station_connectorUpsertArgs>(args: SelectSubset<T, station_connectorUpsertArgs<ExtArgs>>): Prisma__station_connectorClient<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Station_connectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_connectorCountArgs} args - Arguments to filter Station_connectors to count.
     * @example
     * // Count the number of Station_connectors
     * const count = await prisma.station_connector.count({
     *   where: {
     *     // ... the filter for the Station_connectors we want to count
     *   }
     * })
    **/
    count<T extends station_connectorCountArgs>(
      args?: Subset<T, station_connectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Station_connectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Station_connector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Station_connectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Station_connectorAggregateArgs>(args: Subset<T, Station_connectorAggregateArgs>): Prisma.PrismaPromise<GetStation_connectorAggregateType<T>>

    /**
     * Group by Station_connector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_connectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends station_connectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: station_connectorGroupByArgs['orderBy'] }
        : { orderBy?: station_connectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, station_connectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStation_connectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the station_connector model
   */
  readonly fields: station_connectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for station_connector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__station_connectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    station_description<T extends station_connector$station_descriptionArgs<ExtArgs> = {}>(args?: Subset<T, station_connector$station_descriptionArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the station_connector model
   */
  interface station_connectorFieldRefs {
    readonly connector_id: FieldRef<"station_connector", 'Int'>
    readonly description_id: FieldRef<"station_connector", 'Int'>
    readonly connector_type_id: FieldRef<"station_connector", 'Int'>
    readonly connector_status_id: FieldRef<"station_connector", 'Int'>
    readonly connector_name: FieldRef<"station_connector", 'String'>
    readonly power_kw: FieldRef<"station_connector", 'Int'>
    readonly current_amp: FieldRef<"station_connector", 'Int'>
    readonly price_per_start: FieldRef<"station_connector", 'Decimal'>
    readonly price: FieldRef<"station_connector", 'Decimal'>
    readonly currency: FieldRef<"station_connector", 'String'>
    readonly free_min_after_charging: FieldRef<"station_connector", 'Int'>
    readonly price_per_min_after_charging: FieldRef<"station_connector", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * station_connector findUnique
   */
  export type station_connectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    /**
     * Filter, which station_connector to fetch.
     */
    where: station_connectorWhereUniqueInput
  }

  /**
   * station_connector findUniqueOrThrow
   */
  export type station_connectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    /**
     * Filter, which station_connector to fetch.
     */
    where: station_connectorWhereUniqueInput
  }

  /**
   * station_connector findFirst
   */
  export type station_connectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    /**
     * Filter, which station_connector to fetch.
     */
    where?: station_connectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_connectors to fetch.
     */
    orderBy?: station_connectorOrderByWithRelationInput | station_connectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for station_connectors.
     */
    cursor?: station_connectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_connectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_connectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of station_connectors.
     */
    distinct?: Station_connectorScalarFieldEnum | Station_connectorScalarFieldEnum[]
  }

  /**
   * station_connector findFirstOrThrow
   */
  export type station_connectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    /**
     * Filter, which station_connector to fetch.
     */
    where?: station_connectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_connectors to fetch.
     */
    orderBy?: station_connectorOrderByWithRelationInput | station_connectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for station_connectors.
     */
    cursor?: station_connectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_connectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_connectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of station_connectors.
     */
    distinct?: Station_connectorScalarFieldEnum | Station_connectorScalarFieldEnum[]
  }

  /**
   * station_connector findMany
   */
  export type station_connectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    /**
     * Filter, which station_connectors to fetch.
     */
    where?: station_connectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_connectors to fetch.
     */
    orderBy?: station_connectorOrderByWithRelationInput | station_connectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing station_connectors.
     */
    cursor?: station_connectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_connectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_connectors.
     */
    skip?: number
    distinct?: Station_connectorScalarFieldEnum | Station_connectorScalarFieldEnum[]
  }

  /**
   * station_connector create
   */
  export type station_connectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    /**
     * The data needed to create a station_connector.
     */
    data?: XOR<station_connectorCreateInput, station_connectorUncheckedCreateInput>
  }

  /**
   * station_connector createMany
   */
  export type station_connectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many station_connectors.
     */
    data: station_connectorCreateManyInput | station_connectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * station_connector update
   */
  export type station_connectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    /**
     * The data needed to update a station_connector.
     */
    data: XOR<station_connectorUpdateInput, station_connectorUncheckedUpdateInput>
    /**
     * Choose, which station_connector to update.
     */
    where: station_connectorWhereUniqueInput
  }

  /**
   * station_connector updateMany
   */
  export type station_connectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update station_connectors.
     */
    data: XOR<station_connectorUpdateManyMutationInput, station_connectorUncheckedUpdateManyInput>
    /**
     * Filter which station_connectors to update
     */
    where?: station_connectorWhereInput
    /**
     * Limit how many station_connectors to update.
     */
    limit?: number
  }

  /**
   * station_connector upsert
   */
  export type station_connectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    /**
     * The filter to search for the station_connector to update in case it exists.
     */
    where: station_connectorWhereUniqueInput
    /**
     * In case the station_connector found by the `where` argument doesn't exist, create a new station_connector with this data.
     */
    create: XOR<station_connectorCreateInput, station_connectorUncheckedCreateInput>
    /**
     * In case the station_connector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<station_connectorUpdateInput, station_connectorUncheckedUpdateInput>
  }

  /**
   * station_connector delete
   */
  export type station_connectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    /**
     * Filter which station_connector to delete.
     */
    where: station_connectorWhereUniqueInput
  }

  /**
   * station_connector deleteMany
   */
  export type station_connectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which station_connectors to delete
     */
    where?: station_connectorWhereInput
    /**
     * Limit how many station_connectors to delete.
     */
    limit?: number
  }

  /**
   * station_connector.station_description
   */
  export type station_connector$station_descriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    where?: station_descriptionWhereInput
  }

  /**
   * station_connector without action
   */
  export type station_connectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
  }


  /**
   * Model station_desc_api
   */

  export type AggregateStation_desc_api = {
    _count: Station_desc_apiCountAggregateOutputType | null
    _avg: Station_desc_apiAvgAggregateOutputType | null
    _sum: Station_desc_apiSumAggregateOutputType | null
    _min: Station_desc_apiMinAggregateOutputType | null
    _max: Station_desc_apiMaxAggregateOutputType | null
  }

  export type Station_desc_apiAvgAggregateOutputType = {
    id: number | null
    api_id: number | null
    og_api_pk: number | null
    description_id: number | null
  }

  export type Station_desc_apiSumAggregateOutputType = {
    id: number | null
    api_id: number | null
    og_api_pk: number | null
    description_id: number | null
  }

  export type Station_desc_apiMinAggregateOutputType = {
    id: number | null
    api_id: number | null
    og_api_pk: number | null
    description_id: number | null
  }

  export type Station_desc_apiMaxAggregateOutputType = {
    id: number | null
    api_id: number | null
    og_api_pk: number | null
    description_id: number | null
  }

  export type Station_desc_apiCountAggregateOutputType = {
    id: number
    api_id: number
    og_api_pk: number
    description_id: number
    _all: number
  }


  export type Station_desc_apiAvgAggregateInputType = {
    id?: true
    api_id?: true
    og_api_pk?: true
    description_id?: true
  }

  export type Station_desc_apiSumAggregateInputType = {
    id?: true
    api_id?: true
    og_api_pk?: true
    description_id?: true
  }

  export type Station_desc_apiMinAggregateInputType = {
    id?: true
    api_id?: true
    og_api_pk?: true
    description_id?: true
  }

  export type Station_desc_apiMaxAggregateInputType = {
    id?: true
    api_id?: true
    og_api_pk?: true
    description_id?: true
  }

  export type Station_desc_apiCountAggregateInputType = {
    id?: true
    api_id?: true
    og_api_pk?: true
    description_id?: true
    _all?: true
  }

  export type Station_desc_apiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which station_desc_api to aggregate.
     */
    where?: station_desc_apiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_desc_apis to fetch.
     */
    orderBy?: station_desc_apiOrderByWithRelationInput | station_desc_apiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: station_desc_apiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_desc_apis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_desc_apis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned station_desc_apis
    **/
    _count?: true | Station_desc_apiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Station_desc_apiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Station_desc_apiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Station_desc_apiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Station_desc_apiMaxAggregateInputType
  }

  export type GetStation_desc_apiAggregateType<T extends Station_desc_apiAggregateArgs> = {
        [P in keyof T & keyof AggregateStation_desc_api]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStation_desc_api[P]>
      : GetScalarType<T[P], AggregateStation_desc_api[P]>
  }




  export type station_desc_apiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: station_desc_apiWhereInput
    orderBy?: station_desc_apiOrderByWithAggregationInput | station_desc_apiOrderByWithAggregationInput[]
    by: Station_desc_apiScalarFieldEnum[] | Station_desc_apiScalarFieldEnum
    having?: station_desc_apiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Station_desc_apiCountAggregateInputType | true
    _avg?: Station_desc_apiAvgAggregateInputType
    _sum?: Station_desc_apiSumAggregateInputType
    _min?: Station_desc_apiMinAggregateInputType
    _max?: Station_desc_apiMaxAggregateInputType
  }

  export type Station_desc_apiGroupByOutputType = {
    id: number
    api_id: number | null
    og_api_pk: number | null
    description_id: number | null
    _count: Station_desc_apiCountAggregateOutputType | null
    _avg: Station_desc_apiAvgAggregateOutputType | null
    _sum: Station_desc_apiSumAggregateOutputType | null
    _min: Station_desc_apiMinAggregateOutputType | null
    _max: Station_desc_apiMaxAggregateOutputType | null
  }

  type GetStation_desc_apiGroupByPayload<T extends station_desc_apiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Station_desc_apiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Station_desc_apiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Station_desc_apiGroupByOutputType[P]>
            : GetScalarType<T[P], Station_desc_apiGroupByOutputType[P]>
        }
      >
    >


  export type station_desc_apiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    api_id?: boolean
    og_api_pk?: boolean
    description_id?: boolean
    api_source?: boolean | station_desc_api$api_sourceArgs<ExtArgs>
    station_description?: boolean | station_desc_api$station_descriptionArgs<ExtArgs>
  }, ExtArgs["result"]["station_desc_api"]>



  export type station_desc_apiSelectScalar = {
    id?: boolean
    api_id?: boolean
    og_api_pk?: boolean
    description_id?: boolean
  }

  export type station_desc_apiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "api_id" | "og_api_pk" | "description_id", ExtArgs["result"]["station_desc_api"]>
  export type station_desc_apiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    api_source?: boolean | station_desc_api$api_sourceArgs<ExtArgs>
    station_description?: boolean | station_desc_api$station_descriptionArgs<ExtArgs>
  }

  export type $station_desc_apiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "station_desc_api"
    objects: {
      api_source: Prisma.$api_sourcePayload<ExtArgs> | null
      station_description: Prisma.$station_descriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      api_id: number | null
      og_api_pk: number | null
      description_id: number | null
    }, ExtArgs["result"]["station_desc_api"]>
    composites: {}
  }

  type station_desc_apiGetPayload<S extends boolean | null | undefined | station_desc_apiDefaultArgs> = $Result.GetResult<Prisma.$station_desc_apiPayload, S>

  type station_desc_apiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<station_desc_apiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Station_desc_apiCountAggregateInputType | true
    }

  export interface station_desc_apiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['station_desc_api'], meta: { name: 'station_desc_api' } }
    /**
     * Find zero or one Station_desc_api that matches the filter.
     * @param {station_desc_apiFindUniqueArgs} args - Arguments to find a Station_desc_api
     * @example
     * // Get one Station_desc_api
     * const station_desc_api = await prisma.station_desc_api.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends station_desc_apiFindUniqueArgs>(args: SelectSubset<T, station_desc_apiFindUniqueArgs<ExtArgs>>): Prisma__station_desc_apiClient<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Station_desc_api that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {station_desc_apiFindUniqueOrThrowArgs} args - Arguments to find a Station_desc_api
     * @example
     * // Get one Station_desc_api
     * const station_desc_api = await prisma.station_desc_api.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends station_desc_apiFindUniqueOrThrowArgs>(args: SelectSubset<T, station_desc_apiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__station_desc_apiClient<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station_desc_api that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_desc_apiFindFirstArgs} args - Arguments to find a Station_desc_api
     * @example
     * // Get one Station_desc_api
     * const station_desc_api = await prisma.station_desc_api.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends station_desc_apiFindFirstArgs>(args?: SelectSubset<T, station_desc_apiFindFirstArgs<ExtArgs>>): Prisma__station_desc_apiClient<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station_desc_api that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_desc_apiFindFirstOrThrowArgs} args - Arguments to find a Station_desc_api
     * @example
     * // Get one Station_desc_api
     * const station_desc_api = await prisma.station_desc_api.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends station_desc_apiFindFirstOrThrowArgs>(args?: SelectSubset<T, station_desc_apiFindFirstOrThrowArgs<ExtArgs>>): Prisma__station_desc_apiClient<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Station_desc_apis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_desc_apiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Station_desc_apis
     * const station_desc_apis = await prisma.station_desc_api.findMany()
     * 
     * // Get first 10 Station_desc_apis
     * const station_desc_apis = await prisma.station_desc_api.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const station_desc_apiWithIdOnly = await prisma.station_desc_api.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends station_desc_apiFindManyArgs>(args?: SelectSubset<T, station_desc_apiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Station_desc_api.
     * @param {station_desc_apiCreateArgs} args - Arguments to create a Station_desc_api.
     * @example
     * // Create one Station_desc_api
     * const Station_desc_api = await prisma.station_desc_api.create({
     *   data: {
     *     // ... data to create a Station_desc_api
     *   }
     * })
     * 
     */
    create<T extends station_desc_apiCreateArgs>(args: SelectSubset<T, station_desc_apiCreateArgs<ExtArgs>>): Prisma__station_desc_apiClient<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Station_desc_apis.
     * @param {station_desc_apiCreateManyArgs} args - Arguments to create many Station_desc_apis.
     * @example
     * // Create many Station_desc_apis
     * const station_desc_api = await prisma.station_desc_api.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends station_desc_apiCreateManyArgs>(args?: SelectSubset<T, station_desc_apiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Station_desc_api.
     * @param {station_desc_apiDeleteArgs} args - Arguments to delete one Station_desc_api.
     * @example
     * // Delete one Station_desc_api
     * const Station_desc_api = await prisma.station_desc_api.delete({
     *   where: {
     *     // ... filter to delete one Station_desc_api
     *   }
     * })
     * 
     */
    delete<T extends station_desc_apiDeleteArgs>(args: SelectSubset<T, station_desc_apiDeleteArgs<ExtArgs>>): Prisma__station_desc_apiClient<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Station_desc_api.
     * @param {station_desc_apiUpdateArgs} args - Arguments to update one Station_desc_api.
     * @example
     * // Update one Station_desc_api
     * const station_desc_api = await prisma.station_desc_api.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends station_desc_apiUpdateArgs>(args: SelectSubset<T, station_desc_apiUpdateArgs<ExtArgs>>): Prisma__station_desc_apiClient<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Station_desc_apis.
     * @param {station_desc_apiDeleteManyArgs} args - Arguments to filter Station_desc_apis to delete.
     * @example
     * // Delete a few Station_desc_apis
     * const { count } = await prisma.station_desc_api.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends station_desc_apiDeleteManyArgs>(args?: SelectSubset<T, station_desc_apiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Station_desc_apis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_desc_apiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Station_desc_apis
     * const station_desc_api = await prisma.station_desc_api.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends station_desc_apiUpdateManyArgs>(args: SelectSubset<T, station_desc_apiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Station_desc_api.
     * @param {station_desc_apiUpsertArgs} args - Arguments to update or create a Station_desc_api.
     * @example
     * // Update or create a Station_desc_api
     * const station_desc_api = await prisma.station_desc_api.upsert({
     *   create: {
     *     // ... data to create a Station_desc_api
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Station_desc_api we want to update
     *   }
     * })
     */
    upsert<T extends station_desc_apiUpsertArgs>(args: SelectSubset<T, station_desc_apiUpsertArgs<ExtArgs>>): Prisma__station_desc_apiClient<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Station_desc_apis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_desc_apiCountArgs} args - Arguments to filter Station_desc_apis to count.
     * @example
     * // Count the number of Station_desc_apis
     * const count = await prisma.station_desc_api.count({
     *   where: {
     *     // ... the filter for the Station_desc_apis we want to count
     *   }
     * })
    **/
    count<T extends station_desc_apiCountArgs>(
      args?: Subset<T, station_desc_apiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Station_desc_apiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Station_desc_api.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Station_desc_apiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Station_desc_apiAggregateArgs>(args: Subset<T, Station_desc_apiAggregateArgs>): Prisma.PrismaPromise<GetStation_desc_apiAggregateType<T>>

    /**
     * Group by Station_desc_api.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_desc_apiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends station_desc_apiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: station_desc_apiGroupByArgs['orderBy'] }
        : { orderBy?: station_desc_apiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, station_desc_apiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStation_desc_apiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the station_desc_api model
   */
  readonly fields: station_desc_apiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for station_desc_api.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__station_desc_apiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    api_source<T extends station_desc_api$api_sourceArgs<ExtArgs> = {}>(args?: Subset<T, station_desc_api$api_sourceArgs<ExtArgs>>): Prisma__api_sourceClient<$Result.GetResult<Prisma.$api_sourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    station_description<T extends station_desc_api$station_descriptionArgs<ExtArgs> = {}>(args?: Subset<T, station_desc_api$station_descriptionArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the station_desc_api model
   */
  interface station_desc_apiFieldRefs {
    readonly id: FieldRef<"station_desc_api", 'Int'>
    readonly api_id: FieldRef<"station_desc_api", 'Int'>
    readonly og_api_pk: FieldRef<"station_desc_api", 'Int'>
    readonly description_id: FieldRef<"station_desc_api", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * station_desc_api findUnique
   */
  export type station_desc_apiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    /**
     * Filter, which station_desc_api to fetch.
     */
    where: station_desc_apiWhereUniqueInput
  }

  /**
   * station_desc_api findUniqueOrThrow
   */
  export type station_desc_apiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    /**
     * Filter, which station_desc_api to fetch.
     */
    where: station_desc_apiWhereUniqueInput
  }

  /**
   * station_desc_api findFirst
   */
  export type station_desc_apiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    /**
     * Filter, which station_desc_api to fetch.
     */
    where?: station_desc_apiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_desc_apis to fetch.
     */
    orderBy?: station_desc_apiOrderByWithRelationInput | station_desc_apiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for station_desc_apis.
     */
    cursor?: station_desc_apiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_desc_apis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_desc_apis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of station_desc_apis.
     */
    distinct?: Station_desc_apiScalarFieldEnum | Station_desc_apiScalarFieldEnum[]
  }

  /**
   * station_desc_api findFirstOrThrow
   */
  export type station_desc_apiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    /**
     * Filter, which station_desc_api to fetch.
     */
    where?: station_desc_apiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_desc_apis to fetch.
     */
    orderBy?: station_desc_apiOrderByWithRelationInput | station_desc_apiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for station_desc_apis.
     */
    cursor?: station_desc_apiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_desc_apis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_desc_apis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of station_desc_apis.
     */
    distinct?: Station_desc_apiScalarFieldEnum | Station_desc_apiScalarFieldEnum[]
  }

  /**
   * station_desc_api findMany
   */
  export type station_desc_apiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    /**
     * Filter, which station_desc_apis to fetch.
     */
    where?: station_desc_apiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_desc_apis to fetch.
     */
    orderBy?: station_desc_apiOrderByWithRelationInput | station_desc_apiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing station_desc_apis.
     */
    cursor?: station_desc_apiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_desc_apis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_desc_apis.
     */
    skip?: number
    distinct?: Station_desc_apiScalarFieldEnum | Station_desc_apiScalarFieldEnum[]
  }

  /**
   * station_desc_api create
   */
  export type station_desc_apiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    /**
     * The data needed to create a station_desc_api.
     */
    data?: XOR<station_desc_apiCreateInput, station_desc_apiUncheckedCreateInput>
  }

  /**
   * station_desc_api createMany
   */
  export type station_desc_apiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many station_desc_apis.
     */
    data: station_desc_apiCreateManyInput | station_desc_apiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * station_desc_api update
   */
  export type station_desc_apiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    /**
     * The data needed to update a station_desc_api.
     */
    data: XOR<station_desc_apiUpdateInput, station_desc_apiUncheckedUpdateInput>
    /**
     * Choose, which station_desc_api to update.
     */
    where: station_desc_apiWhereUniqueInput
  }

  /**
   * station_desc_api updateMany
   */
  export type station_desc_apiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update station_desc_apis.
     */
    data: XOR<station_desc_apiUpdateManyMutationInput, station_desc_apiUncheckedUpdateManyInput>
    /**
     * Filter which station_desc_apis to update
     */
    where?: station_desc_apiWhereInput
    /**
     * Limit how many station_desc_apis to update.
     */
    limit?: number
  }

  /**
   * station_desc_api upsert
   */
  export type station_desc_apiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    /**
     * The filter to search for the station_desc_api to update in case it exists.
     */
    where: station_desc_apiWhereUniqueInput
    /**
     * In case the station_desc_api found by the `where` argument doesn't exist, create a new station_desc_api with this data.
     */
    create: XOR<station_desc_apiCreateInput, station_desc_apiUncheckedCreateInput>
    /**
     * In case the station_desc_api was found with the provided `where` argument, update it with this data.
     */
    update: XOR<station_desc_apiUpdateInput, station_desc_apiUncheckedUpdateInput>
  }

  /**
   * station_desc_api delete
   */
  export type station_desc_apiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    /**
     * Filter which station_desc_api to delete.
     */
    where: station_desc_apiWhereUniqueInput
  }

  /**
   * station_desc_api deleteMany
   */
  export type station_desc_apiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which station_desc_apis to delete
     */
    where?: station_desc_apiWhereInput
    /**
     * Limit how many station_desc_apis to delete.
     */
    limit?: number
  }

  /**
   * station_desc_api.api_source
   */
  export type station_desc_api$api_sourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_source
     */
    select?: api_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_source
     */
    omit?: api_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_sourceInclude<ExtArgs> | null
    where?: api_sourceWhereInput
  }

  /**
   * station_desc_api.station_description
   */
  export type station_desc_api$station_descriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    where?: station_descriptionWhereInput
  }

  /**
   * station_desc_api without action
   */
  export type station_desc_apiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
  }


  /**
   * Model station_description
   */

  export type AggregateStation_description = {
    _count: Station_descriptionCountAggregateOutputType | null
    _avg: Station_descriptionAvgAggregateOutputType | null
    _sum: Station_descriptionSumAggregateOutputType | null
    _min: Station_descriptionMinAggregateOutputType | null
    _max: Station_descriptionMaxAggregateOutputType | null
  }

  export type Station_descriptionAvgAggregateOutputType = {
    description_id: number | null
    station_id: number | null
    last_charging: number | null
    min_power_kw: number | null
    max_power_kw: number | null
    last_status_update: number | null
    network_id: number | null
    status_id: number | null
  }

  export type Station_descriptionSumAggregateOutputType = {
    description_id: number | null
    station_id: number | null
    last_charging: bigint | null
    min_power_kw: number | null
    max_power_kw: number | null
    last_status_update: bigint | null
    network_id: number | null
    status_id: number | null
  }

  export type Station_descriptionMinAggregateOutputType = {
    description_id: number | null
    station_id: number | null
    station_name: string | null
    description_string: string | null
    location_type: string | null
    country_code: string | null
    support_phone: string | null
    is_support_charging: boolean | null
    is_support_reservation: boolean | null
    location_name: string | null
    last_charging: bigint | null
    is_public: boolean | null
    is_fast_charger: boolean | null
    is_open_24x7: boolean | null
    min_power_kw: number | null
    max_power_kw: number | null
    last_status_update: bigint | null
    network_id: number | null
    status_id: number | null
    station_flags: Uint8Array | null
  }

  export type Station_descriptionMaxAggregateOutputType = {
    description_id: number | null
    station_id: number | null
    station_name: string | null
    description_string: string | null
    location_type: string | null
    country_code: string | null
    support_phone: string | null
    is_support_charging: boolean | null
    is_support_reservation: boolean | null
    location_name: string | null
    last_charging: bigint | null
    is_public: boolean | null
    is_fast_charger: boolean | null
    is_open_24x7: boolean | null
    min_power_kw: number | null
    max_power_kw: number | null
    last_status_update: bigint | null
    network_id: number | null
    status_id: number | null
    station_flags: Uint8Array | null
  }

  export type Station_descriptionCountAggregateOutputType = {
    description_id: number
    station_id: number
    station_name: number
    description_string: number
    location_type: number
    country_code: number
    support_phone: number
    is_support_charging: number
    is_support_reservation: number
    location_name: number
    last_charging: number
    is_public: number
    is_fast_charger: number
    is_open_24x7: number
    min_power_kw: number
    max_power_kw: number
    last_status_update: number
    network_id: number
    status_id: number
    station_flags: number
    _all: number
  }


  export type Station_descriptionAvgAggregateInputType = {
    description_id?: true
    station_id?: true
    last_charging?: true
    min_power_kw?: true
    max_power_kw?: true
    last_status_update?: true
    network_id?: true
    status_id?: true
  }

  export type Station_descriptionSumAggregateInputType = {
    description_id?: true
    station_id?: true
    last_charging?: true
    min_power_kw?: true
    max_power_kw?: true
    last_status_update?: true
    network_id?: true
    status_id?: true
  }

  export type Station_descriptionMinAggregateInputType = {
    description_id?: true
    station_id?: true
    station_name?: true
    description_string?: true
    location_type?: true
    country_code?: true
    support_phone?: true
    is_support_charging?: true
    is_support_reservation?: true
    location_name?: true
    last_charging?: true
    is_public?: true
    is_fast_charger?: true
    is_open_24x7?: true
    min_power_kw?: true
    max_power_kw?: true
    last_status_update?: true
    network_id?: true
    status_id?: true
    station_flags?: true
  }

  export type Station_descriptionMaxAggregateInputType = {
    description_id?: true
    station_id?: true
    station_name?: true
    description_string?: true
    location_type?: true
    country_code?: true
    support_phone?: true
    is_support_charging?: true
    is_support_reservation?: true
    location_name?: true
    last_charging?: true
    is_public?: true
    is_fast_charger?: true
    is_open_24x7?: true
    min_power_kw?: true
    max_power_kw?: true
    last_status_update?: true
    network_id?: true
    status_id?: true
    station_flags?: true
  }

  export type Station_descriptionCountAggregateInputType = {
    description_id?: true
    station_id?: true
    station_name?: true
    description_string?: true
    location_type?: true
    country_code?: true
    support_phone?: true
    is_support_charging?: true
    is_support_reservation?: true
    location_name?: true
    last_charging?: true
    is_public?: true
    is_fast_charger?: true
    is_open_24x7?: true
    min_power_kw?: true
    max_power_kw?: true
    last_status_update?: true
    network_id?: true
    status_id?: true
    station_flags?: true
    _all?: true
  }

  export type Station_descriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which station_description to aggregate.
     */
    where?: station_descriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_descriptions to fetch.
     */
    orderBy?: station_descriptionOrderByWithRelationInput | station_descriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: station_descriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_descriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_descriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned station_descriptions
    **/
    _count?: true | Station_descriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Station_descriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Station_descriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Station_descriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Station_descriptionMaxAggregateInputType
  }

  export type GetStation_descriptionAggregateType<T extends Station_descriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateStation_description]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStation_description[P]>
      : GetScalarType<T[P], AggregateStation_description[P]>
  }




  export type station_descriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: station_descriptionWhereInput
    orderBy?: station_descriptionOrderByWithAggregationInput | station_descriptionOrderByWithAggregationInput[]
    by: Station_descriptionScalarFieldEnum[] | Station_descriptionScalarFieldEnum
    having?: station_descriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Station_descriptionCountAggregateInputType | true
    _avg?: Station_descriptionAvgAggregateInputType
    _sum?: Station_descriptionSumAggregateInputType
    _min?: Station_descriptionMinAggregateInputType
    _max?: Station_descriptionMaxAggregateInputType
  }

  export type Station_descriptionGroupByOutputType = {
    description_id: number
    station_id: number | null
    station_name: string | null
    description_string: string | null
    location_type: string | null
    country_code: string | null
    support_phone: string | null
    is_support_charging: boolean | null
    is_support_reservation: boolean | null
    location_name: string | null
    last_charging: bigint | null
    is_public: boolean | null
    is_fast_charger: boolean | null
    is_open_24x7: boolean | null
    min_power_kw: number | null
    max_power_kw: number | null
    last_status_update: bigint | null
    network_id: number | null
    status_id: number | null
    station_flags: Uint8Array | null
    _count: Station_descriptionCountAggregateOutputType | null
    _avg: Station_descriptionAvgAggregateOutputType | null
    _sum: Station_descriptionSumAggregateOutputType | null
    _min: Station_descriptionMinAggregateOutputType | null
    _max: Station_descriptionMaxAggregateOutputType | null
  }

  type GetStation_descriptionGroupByPayload<T extends station_descriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Station_descriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Station_descriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Station_descriptionGroupByOutputType[P]>
            : GetScalarType<T[P], Station_descriptionGroupByOutputType[P]>
        }
      >
    >


  export type station_descriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    description_id?: boolean
    station_id?: boolean
    station_name?: boolean
    description_string?: boolean
    location_type?: boolean
    country_code?: boolean
    support_phone?: boolean
    is_support_charging?: boolean
    is_support_reservation?: boolean
    location_name?: boolean
    last_charging?: boolean
    is_public?: boolean
    is_fast_charger?: boolean
    is_open_24x7?: boolean
    min_power_kw?: boolean
    max_power_kw?: boolean
    last_status_update?: boolean
    network_id?: boolean
    status_id?: boolean
    station_flags?: boolean
    comments?: boolean | station_description$commentsArgs<ExtArgs>
    images?: boolean | station_description$imagesArgs<ExtArgs>
    station_connector?: boolean | station_description$station_connectorArgs<ExtArgs>
    station_desc_api?: boolean | station_description$station_desc_apiArgs<ExtArgs>
    station_marker?: boolean | station_description$station_markerArgs<ExtArgs>
    _count?: boolean | Station_descriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["station_description"]>



  export type station_descriptionSelectScalar = {
    description_id?: boolean
    station_id?: boolean
    station_name?: boolean
    description_string?: boolean
    location_type?: boolean
    country_code?: boolean
    support_phone?: boolean
    is_support_charging?: boolean
    is_support_reservation?: boolean
    location_name?: boolean
    last_charging?: boolean
    is_public?: boolean
    is_fast_charger?: boolean
    is_open_24x7?: boolean
    min_power_kw?: boolean
    max_power_kw?: boolean
    last_status_update?: boolean
    network_id?: boolean
    status_id?: boolean
    station_flags?: boolean
  }

  export type station_descriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"description_id" | "station_id" | "station_name" | "description_string" | "location_type" | "country_code" | "support_phone" | "is_support_charging" | "is_support_reservation" | "location_name" | "last_charging" | "is_public" | "is_fast_charger" | "is_open_24x7" | "min_power_kw" | "max_power_kw" | "last_status_update" | "network_id" | "status_id" | "station_flags", ExtArgs["result"]["station_description"]>
  export type station_descriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | station_description$commentsArgs<ExtArgs>
    images?: boolean | station_description$imagesArgs<ExtArgs>
    station_connector?: boolean | station_description$station_connectorArgs<ExtArgs>
    station_desc_api?: boolean | station_description$station_desc_apiArgs<ExtArgs>
    station_marker?: boolean | station_description$station_markerArgs<ExtArgs>
    _count?: boolean | Station_descriptionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $station_descriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "station_description"
    objects: {
      comments: Prisma.$commentsPayload<ExtArgs>[]
      images: Prisma.$imagesPayload<ExtArgs>[]
      station_connector: Prisma.$station_connectorPayload<ExtArgs>[]
      station_desc_api: Prisma.$station_desc_apiPayload<ExtArgs>[]
      station_marker: Prisma.$station_markerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      description_id: number
      station_id: number | null
      station_name: string | null
      description_string: string | null
      location_type: string | null
      country_code: string | null
      support_phone: string | null
      is_support_charging: boolean | null
      is_support_reservation: boolean | null
      location_name: string | null
      last_charging: bigint | null
      is_public: boolean | null
      is_fast_charger: boolean | null
      is_open_24x7: boolean | null
      min_power_kw: number | null
      max_power_kw: number | null
      last_status_update: bigint | null
      network_id: number | null
      status_id: number | null
      station_flags: Uint8Array | null
    }, ExtArgs["result"]["station_description"]>
    composites: {}
  }

  type station_descriptionGetPayload<S extends boolean | null | undefined | station_descriptionDefaultArgs> = $Result.GetResult<Prisma.$station_descriptionPayload, S>

  type station_descriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<station_descriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Station_descriptionCountAggregateInputType | true
    }

  export interface station_descriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['station_description'], meta: { name: 'station_description' } }
    /**
     * Find zero or one Station_description that matches the filter.
     * @param {station_descriptionFindUniqueArgs} args - Arguments to find a Station_description
     * @example
     * // Get one Station_description
     * const station_description = await prisma.station_description.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends station_descriptionFindUniqueArgs>(args: SelectSubset<T, station_descriptionFindUniqueArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Station_description that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {station_descriptionFindUniqueOrThrowArgs} args - Arguments to find a Station_description
     * @example
     * // Get one Station_description
     * const station_description = await prisma.station_description.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends station_descriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, station_descriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station_description that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_descriptionFindFirstArgs} args - Arguments to find a Station_description
     * @example
     * // Get one Station_description
     * const station_description = await prisma.station_description.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends station_descriptionFindFirstArgs>(args?: SelectSubset<T, station_descriptionFindFirstArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station_description that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_descriptionFindFirstOrThrowArgs} args - Arguments to find a Station_description
     * @example
     * // Get one Station_description
     * const station_description = await prisma.station_description.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends station_descriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, station_descriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Station_descriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_descriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Station_descriptions
     * const station_descriptions = await prisma.station_description.findMany()
     * 
     * // Get first 10 Station_descriptions
     * const station_descriptions = await prisma.station_description.findMany({ take: 10 })
     * 
     * // Only select the `description_id`
     * const station_descriptionWithDescription_idOnly = await prisma.station_description.findMany({ select: { description_id: true } })
     * 
     */
    findMany<T extends station_descriptionFindManyArgs>(args?: SelectSubset<T, station_descriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Station_description.
     * @param {station_descriptionCreateArgs} args - Arguments to create a Station_description.
     * @example
     * // Create one Station_description
     * const Station_description = await prisma.station_description.create({
     *   data: {
     *     // ... data to create a Station_description
     *   }
     * })
     * 
     */
    create<T extends station_descriptionCreateArgs>(args: SelectSubset<T, station_descriptionCreateArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Station_descriptions.
     * @param {station_descriptionCreateManyArgs} args - Arguments to create many Station_descriptions.
     * @example
     * // Create many Station_descriptions
     * const station_description = await prisma.station_description.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends station_descriptionCreateManyArgs>(args?: SelectSubset<T, station_descriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Station_description.
     * @param {station_descriptionDeleteArgs} args - Arguments to delete one Station_description.
     * @example
     * // Delete one Station_description
     * const Station_description = await prisma.station_description.delete({
     *   where: {
     *     // ... filter to delete one Station_description
     *   }
     * })
     * 
     */
    delete<T extends station_descriptionDeleteArgs>(args: SelectSubset<T, station_descriptionDeleteArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Station_description.
     * @param {station_descriptionUpdateArgs} args - Arguments to update one Station_description.
     * @example
     * // Update one Station_description
     * const station_description = await prisma.station_description.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends station_descriptionUpdateArgs>(args: SelectSubset<T, station_descriptionUpdateArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Station_descriptions.
     * @param {station_descriptionDeleteManyArgs} args - Arguments to filter Station_descriptions to delete.
     * @example
     * // Delete a few Station_descriptions
     * const { count } = await prisma.station_description.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends station_descriptionDeleteManyArgs>(args?: SelectSubset<T, station_descriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Station_descriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_descriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Station_descriptions
     * const station_description = await prisma.station_description.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends station_descriptionUpdateManyArgs>(args: SelectSubset<T, station_descriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Station_description.
     * @param {station_descriptionUpsertArgs} args - Arguments to update or create a Station_description.
     * @example
     * // Update or create a Station_description
     * const station_description = await prisma.station_description.upsert({
     *   create: {
     *     // ... data to create a Station_description
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Station_description we want to update
     *   }
     * })
     */
    upsert<T extends station_descriptionUpsertArgs>(args: SelectSubset<T, station_descriptionUpsertArgs<ExtArgs>>): Prisma__station_descriptionClient<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Station_descriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_descriptionCountArgs} args - Arguments to filter Station_descriptions to count.
     * @example
     * // Count the number of Station_descriptions
     * const count = await prisma.station_description.count({
     *   where: {
     *     // ... the filter for the Station_descriptions we want to count
     *   }
     * })
    **/
    count<T extends station_descriptionCountArgs>(
      args?: Subset<T, station_descriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Station_descriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Station_description.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Station_descriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Station_descriptionAggregateArgs>(args: Subset<T, Station_descriptionAggregateArgs>): Prisma.PrismaPromise<GetStation_descriptionAggregateType<T>>

    /**
     * Group by Station_description.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_descriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends station_descriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: station_descriptionGroupByArgs['orderBy'] }
        : { orderBy?: station_descriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, station_descriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStation_descriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the station_description model
   */
  readonly fields: station_descriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for station_description.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__station_descriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends station_description$commentsArgs<ExtArgs> = {}>(args?: Subset<T, station_description$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends station_description$imagesArgs<ExtArgs> = {}>(args?: Subset<T, station_description$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    station_connector<T extends station_description$station_connectorArgs<ExtArgs> = {}>(args?: Subset<T, station_description$station_connectorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$station_connectorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    station_desc_api<T extends station_description$station_desc_apiArgs<ExtArgs> = {}>(args?: Subset<T, station_description$station_desc_apiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$station_desc_apiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    station_marker<T extends station_description$station_markerArgs<ExtArgs> = {}>(args?: Subset<T, station_description$station_markerArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the station_description model
   */
  interface station_descriptionFieldRefs {
    readonly description_id: FieldRef<"station_description", 'Int'>
    readonly station_id: FieldRef<"station_description", 'Int'>
    readonly station_name: FieldRef<"station_description", 'String'>
    readonly description_string: FieldRef<"station_description", 'String'>
    readonly location_type: FieldRef<"station_description", 'String'>
    readonly country_code: FieldRef<"station_description", 'String'>
    readonly support_phone: FieldRef<"station_description", 'String'>
    readonly is_support_charging: FieldRef<"station_description", 'Boolean'>
    readonly is_support_reservation: FieldRef<"station_description", 'Boolean'>
    readonly location_name: FieldRef<"station_description", 'String'>
    readonly last_charging: FieldRef<"station_description", 'BigInt'>
    readonly is_public: FieldRef<"station_description", 'Boolean'>
    readonly is_fast_charger: FieldRef<"station_description", 'Boolean'>
    readonly is_open_24x7: FieldRef<"station_description", 'Boolean'>
    readonly min_power_kw: FieldRef<"station_description", 'Int'>
    readonly max_power_kw: FieldRef<"station_description", 'Int'>
    readonly last_status_update: FieldRef<"station_description", 'BigInt'>
    readonly network_id: FieldRef<"station_description", 'Int'>
    readonly status_id: FieldRef<"station_description", 'Int'>
    readonly station_flags: FieldRef<"station_description", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * station_description findUnique
   */
  export type station_descriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    /**
     * Filter, which station_description to fetch.
     */
    where: station_descriptionWhereUniqueInput
  }

  /**
   * station_description findUniqueOrThrow
   */
  export type station_descriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    /**
     * Filter, which station_description to fetch.
     */
    where: station_descriptionWhereUniqueInput
  }

  /**
   * station_description findFirst
   */
  export type station_descriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    /**
     * Filter, which station_description to fetch.
     */
    where?: station_descriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_descriptions to fetch.
     */
    orderBy?: station_descriptionOrderByWithRelationInput | station_descriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for station_descriptions.
     */
    cursor?: station_descriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_descriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_descriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of station_descriptions.
     */
    distinct?: Station_descriptionScalarFieldEnum | Station_descriptionScalarFieldEnum[]
  }

  /**
   * station_description findFirstOrThrow
   */
  export type station_descriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    /**
     * Filter, which station_description to fetch.
     */
    where?: station_descriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_descriptions to fetch.
     */
    orderBy?: station_descriptionOrderByWithRelationInput | station_descriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for station_descriptions.
     */
    cursor?: station_descriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_descriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_descriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of station_descriptions.
     */
    distinct?: Station_descriptionScalarFieldEnum | Station_descriptionScalarFieldEnum[]
  }

  /**
   * station_description findMany
   */
  export type station_descriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    /**
     * Filter, which station_descriptions to fetch.
     */
    where?: station_descriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_descriptions to fetch.
     */
    orderBy?: station_descriptionOrderByWithRelationInput | station_descriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing station_descriptions.
     */
    cursor?: station_descriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_descriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_descriptions.
     */
    skip?: number
    distinct?: Station_descriptionScalarFieldEnum | Station_descriptionScalarFieldEnum[]
  }

  /**
   * station_description create
   */
  export type station_descriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a station_description.
     */
    data?: XOR<station_descriptionCreateInput, station_descriptionUncheckedCreateInput>
  }

  /**
   * station_description createMany
   */
  export type station_descriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many station_descriptions.
     */
    data: station_descriptionCreateManyInput | station_descriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * station_description update
   */
  export type station_descriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a station_description.
     */
    data: XOR<station_descriptionUpdateInput, station_descriptionUncheckedUpdateInput>
    /**
     * Choose, which station_description to update.
     */
    where: station_descriptionWhereUniqueInput
  }

  /**
   * station_description updateMany
   */
  export type station_descriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update station_descriptions.
     */
    data: XOR<station_descriptionUpdateManyMutationInput, station_descriptionUncheckedUpdateManyInput>
    /**
     * Filter which station_descriptions to update
     */
    where?: station_descriptionWhereInput
    /**
     * Limit how many station_descriptions to update.
     */
    limit?: number
  }

  /**
   * station_description upsert
   */
  export type station_descriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the station_description to update in case it exists.
     */
    where: station_descriptionWhereUniqueInput
    /**
     * In case the station_description found by the `where` argument doesn't exist, create a new station_description with this data.
     */
    create: XOR<station_descriptionCreateInput, station_descriptionUncheckedCreateInput>
    /**
     * In case the station_description was found with the provided `where` argument, update it with this data.
     */
    update: XOR<station_descriptionUpdateInput, station_descriptionUncheckedUpdateInput>
  }

  /**
   * station_description delete
   */
  export type station_descriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    /**
     * Filter which station_description to delete.
     */
    where: station_descriptionWhereUniqueInput
  }

  /**
   * station_description deleteMany
   */
  export type station_descriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which station_descriptions to delete
     */
    where?: station_descriptionWhereInput
    /**
     * Limit how many station_descriptions to delete.
     */
    limit?: number
  }

  /**
   * station_description.comments
   */
  export type station_description$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * station_description.images
   */
  export type station_description$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    cursor?: imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * station_description.station_connector
   */
  export type station_description$station_connectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_connector
     */
    select?: station_connectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_connector
     */
    omit?: station_connectorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_connectorInclude<ExtArgs> | null
    where?: station_connectorWhereInput
    orderBy?: station_connectorOrderByWithRelationInput | station_connectorOrderByWithRelationInput[]
    cursor?: station_connectorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Station_connectorScalarFieldEnum | Station_connectorScalarFieldEnum[]
  }

  /**
   * station_description.station_desc_api
   */
  export type station_description$station_desc_apiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_desc_api
     */
    select?: station_desc_apiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_desc_api
     */
    omit?: station_desc_apiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_desc_apiInclude<ExtArgs> | null
    where?: station_desc_apiWhereInput
    orderBy?: station_desc_apiOrderByWithRelationInput | station_desc_apiOrderByWithRelationInput[]
    cursor?: station_desc_apiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Station_desc_apiScalarFieldEnum | Station_desc_apiScalarFieldEnum[]
  }

  /**
   * station_description.station_marker
   */
  export type station_description$station_markerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    where?: station_markerWhereInput
  }

  /**
   * station_description without action
   */
  export type station_descriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
  }


  /**
   * Model station_marker
   */

  export type AggregateStation_marker = {
    _count: Station_markerCountAggregateOutputType | null
    _avg: Station_markerAvgAggregateOutputType | null
    _sum: Station_markerSumAggregateOutputType | null
    _min: Station_markerMinAggregateOutputType | null
    _max: Station_markerMaxAggregateOutputType | null
  }

  export type Station_markerAvgAggregateOutputType = {
    station_id: number | null
    longitude: Decimal | null
    latitude: Decimal | null
  }

  export type Station_markerSumAggregateOutputType = {
    station_id: number | null
    longitude: Decimal | null
    latitude: Decimal | null
  }

  export type Station_markerMinAggregateOutputType = {
    station_id: number | null
    longitude: Decimal | null
    latitude: Decimal | null
  }

  export type Station_markerMaxAggregateOutputType = {
    station_id: number | null
    longitude: Decimal | null
    latitude: Decimal | null
  }

  export type Station_markerCountAggregateOutputType = {
    station_id: number
    longitude: number
    latitude: number
    _all: number
  }


  export type Station_markerAvgAggregateInputType = {
    station_id?: true
    longitude?: true
    latitude?: true
  }

  export type Station_markerSumAggregateInputType = {
    station_id?: true
    longitude?: true
    latitude?: true
  }

  export type Station_markerMinAggregateInputType = {
    station_id?: true
    longitude?: true
    latitude?: true
  }

  export type Station_markerMaxAggregateInputType = {
    station_id?: true
    longitude?: true
    latitude?: true
  }

  export type Station_markerCountAggregateInputType = {
    station_id?: true
    longitude?: true
    latitude?: true
    _all?: true
  }

  export type Station_markerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which station_marker to aggregate.
     */
    where?: station_markerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_markers to fetch.
     */
    orderBy?: station_markerOrderByWithRelationInput | station_markerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: station_markerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_markers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_markers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned station_markers
    **/
    _count?: true | Station_markerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Station_markerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Station_markerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Station_markerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Station_markerMaxAggregateInputType
  }

  export type GetStation_markerAggregateType<T extends Station_markerAggregateArgs> = {
        [P in keyof T & keyof AggregateStation_marker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStation_marker[P]>
      : GetScalarType<T[P], AggregateStation_marker[P]>
  }




  export type station_markerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: station_markerWhereInput
    orderBy?: station_markerOrderByWithAggregationInput | station_markerOrderByWithAggregationInput[]
    by: Station_markerScalarFieldEnum[] | Station_markerScalarFieldEnum
    having?: station_markerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Station_markerCountAggregateInputType | true
    _avg?: Station_markerAvgAggregateInputType
    _sum?: Station_markerSumAggregateInputType
    _min?: Station_markerMinAggregateInputType
    _max?: Station_markerMaxAggregateInputType
  }

  export type Station_markerGroupByOutputType = {
    station_id: number
    longitude: Decimal
    latitude: Decimal
    _count: Station_markerCountAggregateOutputType | null
    _avg: Station_markerAvgAggregateOutputType | null
    _sum: Station_markerSumAggregateOutputType | null
    _min: Station_markerMinAggregateOutputType | null
    _max: Station_markerMaxAggregateOutputType | null
  }

  type GetStation_markerGroupByPayload<T extends station_markerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Station_markerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Station_markerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Station_markerGroupByOutputType[P]>
            : GetScalarType<T[P], Station_markerGroupByOutputType[P]>
        }
      >
    >


  export type station_markerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    station_id?: boolean
    longitude?: boolean
    latitude?: boolean
    station_description?: boolean | station_marker$station_descriptionArgs<ExtArgs>
    savedStations?: boolean | station_marker$savedStationsArgs<ExtArgs>
    _count?: boolean | Station_markerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["station_marker"]>



  export type station_markerSelectScalar = {
    station_id?: boolean
    longitude?: boolean
    latitude?: boolean
  }

  export type station_markerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"station_id" | "longitude" | "latitude", ExtArgs["result"]["station_marker"]>
  export type station_markerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    station_description?: boolean | station_marker$station_descriptionArgs<ExtArgs>
    savedStations?: boolean | station_marker$savedStationsArgs<ExtArgs>
    _count?: boolean | Station_markerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $station_markerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "station_marker"
    objects: {
      station_description: Prisma.$station_descriptionPayload<ExtArgs>[]
      savedStations: Prisma.$SavedStationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      station_id: number
      longitude: Prisma.Decimal
      latitude: Prisma.Decimal
    }, ExtArgs["result"]["station_marker"]>
    composites: {}
  }

  type station_markerGetPayload<S extends boolean | null | undefined | station_markerDefaultArgs> = $Result.GetResult<Prisma.$station_markerPayload, S>

  type station_markerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<station_markerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Station_markerCountAggregateInputType | true
    }

  export interface station_markerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['station_marker'], meta: { name: 'station_marker' } }
    /**
     * Find zero or one Station_marker that matches the filter.
     * @param {station_markerFindUniqueArgs} args - Arguments to find a Station_marker
     * @example
     * // Get one Station_marker
     * const station_marker = await prisma.station_marker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends station_markerFindUniqueArgs>(args: SelectSubset<T, station_markerFindUniqueArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Station_marker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {station_markerFindUniqueOrThrowArgs} args - Arguments to find a Station_marker
     * @example
     * // Get one Station_marker
     * const station_marker = await prisma.station_marker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends station_markerFindUniqueOrThrowArgs>(args: SelectSubset<T, station_markerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station_marker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_markerFindFirstArgs} args - Arguments to find a Station_marker
     * @example
     * // Get one Station_marker
     * const station_marker = await prisma.station_marker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends station_markerFindFirstArgs>(args?: SelectSubset<T, station_markerFindFirstArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Station_marker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_markerFindFirstOrThrowArgs} args - Arguments to find a Station_marker
     * @example
     * // Get one Station_marker
     * const station_marker = await prisma.station_marker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends station_markerFindFirstOrThrowArgs>(args?: SelectSubset<T, station_markerFindFirstOrThrowArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Station_markers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_markerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Station_markers
     * const station_markers = await prisma.station_marker.findMany()
     * 
     * // Get first 10 Station_markers
     * const station_markers = await prisma.station_marker.findMany({ take: 10 })
     * 
     * // Only select the `station_id`
     * const station_markerWithStation_idOnly = await prisma.station_marker.findMany({ select: { station_id: true } })
     * 
     */
    findMany<T extends station_markerFindManyArgs>(args?: SelectSubset<T, station_markerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Station_marker.
     * @param {station_markerCreateArgs} args - Arguments to create a Station_marker.
     * @example
     * // Create one Station_marker
     * const Station_marker = await prisma.station_marker.create({
     *   data: {
     *     // ... data to create a Station_marker
     *   }
     * })
     * 
     */
    create<T extends station_markerCreateArgs>(args: SelectSubset<T, station_markerCreateArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Station_markers.
     * @param {station_markerCreateManyArgs} args - Arguments to create many Station_markers.
     * @example
     * // Create many Station_markers
     * const station_marker = await prisma.station_marker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends station_markerCreateManyArgs>(args?: SelectSubset<T, station_markerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Station_marker.
     * @param {station_markerDeleteArgs} args - Arguments to delete one Station_marker.
     * @example
     * // Delete one Station_marker
     * const Station_marker = await prisma.station_marker.delete({
     *   where: {
     *     // ... filter to delete one Station_marker
     *   }
     * })
     * 
     */
    delete<T extends station_markerDeleteArgs>(args: SelectSubset<T, station_markerDeleteArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Station_marker.
     * @param {station_markerUpdateArgs} args - Arguments to update one Station_marker.
     * @example
     * // Update one Station_marker
     * const station_marker = await prisma.station_marker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends station_markerUpdateArgs>(args: SelectSubset<T, station_markerUpdateArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Station_markers.
     * @param {station_markerDeleteManyArgs} args - Arguments to filter Station_markers to delete.
     * @example
     * // Delete a few Station_markers
     * const { count } = await prisma.station_marker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends station_markerDeleteManyArgs>(args?: SelectSubset<T, station_markerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Station_markers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_markerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Station_markers
     * const station_marker = await prisma.station_marker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends station_markerUpdateManyArgs>(args: SelectSubset<T, station_markerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Station_marker.
     * @param {station_markerUpsertArgs} args - Arguments to update or create a Station_marker.
     * @example
     * // Update or create a Station_marker
     * const station_marker = await prisma.station_marker.upsert({
     *   create: {
     *     // ... data to create a Station_marker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Station_marker we want to update
     *   }
     * })
     */
    upsert<T extends station_markerUpsertArgs>(args: SelectSubset<T, station_markerUpsertArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Station_markers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_markerCountArgs} args - Arguments to filter Station_markers to count.
     * @example
     * // Count the number of Station_markers
     * const count = await prisma.station_marker.count({
     *   where: {
     *     // ... the filter for the Station_markers we want to count
     *   }
     * })
    **/
    count<T extends station_markerCountArgs>(
      args?: Subset<T, station_markerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Station_markerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Station_marker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Station_markerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Station_markerAggregateArgs>(args: Subset<T, Station_markerAggregateArgs>): Prisma.PrismaPromise<GetStation_markerAggregateType<T>>

    /**
     * Group by Station_marker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {station_markerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends station_markerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: station_markerGroupByArgs['orderBy'] }
        : { orderBy?: station_markerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, station_markerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStation_markerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the station_marker model
   */
  readonly fields: station_markerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for station_marker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__station_markerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    station_description<T extends station_marker$station_descriptionArgs<ExtArgs> = {}>(args?: Subset<T, station_marker$station_descriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$station_descriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedStations<T extends station_marker$savedStationsArgs<ExtArgs> = {}>(args?: Subset<T, station_marker$savedStationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the station_marker model
   */
  interface station_markerFieldRefs {
    readonly station_id: FieldRef<"station_marker", 'Int'>
    readonly longitude: FieldRef<"station_marker", 'Decimal'>
    readonly latitude: FieldRef<"station_marker", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * station_marker findUnique
   */
  export type station_markerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    /**
     * Filter, which station_marker to fetch.
     */
    where: station_markerWhereUniqueInput
  }

  /**
   * station_marker findUniqueOrThrow
   */
  export type station_markerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    /**
     * Filter, which station_marker to fetch.
     */
    where: station_markerWhereUniqueInput
  }

  /**
   * station_marker findFirst
   */
  export type station_markerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    /**
     * Filter, which station_marker to fetch.
     */
    where?: station_markerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_markers to fetch.
     */
    orderBy?: station_markerOrderByWithRelationInput | station_markerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for station_markers.
     */
    cursor?: station_markerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_markers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_markers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of station_markers.
     */
    distinct?: Station_markerScalarFieldEnum | Station_markerScalarFieldEnum[]
  }

  /**
   * station_marker findFirstOrThrow
   */
  export type station_markerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    /**
     * Filter, which station_marker to fetch.
     */
    where?: station_markerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_markers to fetch.
     */
    orderBy?: station_markerOrderByWithRelationInput | station_markerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for station_markers.
     */
    cursor?: station_markerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_markers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_markers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of station_markers.
     */
    distinct?: Station_markerScalarFieldEnum | Station_markerScalarFieldEnum[]
  }

  /**
   * station_marker findMany
   */
  export type station_markerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    /**
     * Filter, which station_markers to fetch.
     */
    where?: station_markerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of station_markers to fetch.
     */
    orderBy?: station_markerOrderByWithRelationInput | station_markerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing station_markers.
     */
    cursor?: station_markerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` station_markers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` station_markers.
     */
    skip?: number
    distinct?: Station_markerScalarFieldEnum | Station_markerScalarFieldEnum[]
  }

  /**
   * station_marker create
   */
  export type station_markerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    /**
     * The data needed to create a station_marker.
     */
    data: XOR<station_markerCreateInput, station_markerUncheckedCreateInput>
  }

  /**
   * station_marker createMany
   */
  export type station_markerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many station_markers.
     */
    data: station_markerCreateManyInput | station_markerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * station_marker update
   */
  export type station_markerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    /**
     * The data needed to update a station_marker.
     */
    data: XOR<station_markerUpdateInput, station_markerUncheckedUpdateInput>
    /**
     * Choose, which station_marker to update.
     */
    where: station_markerWhereUniqueInput
  }

  /**
   * station_marker updateMany
   */
  export type station_markerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update station_markers.
     */
    data: XOR<station_markerUpdateManyMutationInput, station_markerUncheckedUpdateManyInput>
    /**
     * Filter which station_markers to update
     */
    where?: station_markerWhereInput
    /**
     * Limit how many station_markers to update.
     */
    limit?: number
  }

  /**
   * station_marker upsert
   */
  export type station_markerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    /**
     * The filter to search for the station_marker to update in case it exists.
     */
    where: station_markerWhereUniqueInput
    /**
     * In case the station_marker found by the `where` argument doesn't exist, create a new station_marker with this data.
     */
    create: XOR<station_markerCreateInput, station_markerUncheckedCreateInput>
    /**
     * In case the station_marker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<station_markerUpdateInput, station_markerUncheckedUpdateInput>
  }

  /**
   * station_marker delete
   */
  export type station_markerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
    /**
     * Filter which station_marker to delete.
     */
    where: station_markerWhereUniqueInput
  }

  /**
   * station_marker deleteMany
   */
  export type station_markerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which station_markers to delete
     */
    where?: station_markerWhereInput
    /**
     * Limit how many station_markers to delete.
     */
    limit?: number
  }

  /**
   * station_marker.station_description
   */
  export type station_marker$station_descriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_description
     */
    select?: station_descriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_description
     */
    omit?: station_descriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_descriptionInclude<ExtArgs> | null
    where?: station_descriptionWhereInput
    orderBy?: station_descriptionOrderByWithRelationInput | station_descriptionOrderByWithRelationInput[]
    cursor?: station_descriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Station_descriptionScalarFieldEnum | Station_descriptionScalarFieldEnum[]
  }

  /**
   * station_marker.savedStations
   */
  export type station_marker$savedStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    where?: SavedStationsWhereInput
    orderBy?: SavedStationsOrderByWithRelationInput | SavedStationsOrderByWithRelationInput[]
    cursor?: SavedStationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedStationsScalarFieldEnum | SavedStationsScalarFieldEnum[]
  }

  /**
   * station_marker without action
   */
  export type station_markerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the station_marker
     */
    select?: station_markerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the station_marker
     */
    omit?: station_markerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: station_markerInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    passwordHash: string | null
    roleId: number | null
    isBanned: boolean | null
    emailVerificationKey: string | null
    emailVerifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    passwordHash: string | null
    roleId: number | null
    isBanned: boolean | null
    emailVerificationKey: string | null
    emailVerifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    passwordHash: number
    roleId: number
    isBanned: number
    emailVerificationKey: number
    emailVerifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    roleId?: true
    isBanned?: true
    emailVerificationKey?: true
    emailVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    roleId?: true
    isBanned?: true
    emailVerificationKey?: true
    emailVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    roleId?: true
    isBanned?: true
    emailVerificationKey?: true
    emailVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string | null
    passwordHash: string | null
    roleId: number
    isBanned: boolean
    emailVerificationKey: string | null
    emailVerifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    roleId?: boolean
    isBanned?: boolean
    emailVerificationKey?: boolean
    emailVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    RecoveryToken?: boolean | User$RecoveryTokenArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    savedStations?: boolean | User$savedStationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    roleId?: boolean
    isBanned?: boolean
    emailVerificationKey?: boolean
    emailVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "passwordHash" | "roleId" | "isBanned" | "emailVerificationKey" | "emailVerifiedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permissions?: boolean | User$permissionsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    RecoveryToken?: boolean | User$RecoveryTokenArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    savedStations?: boolean | User$savedStationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permissions: Prisma.$UserPermissionsPayload<ExtArgs>[]
      activities: Prisma.$UserActivityPayload<ExtArgs>[]
      RecoveryToken: Prisma.$RecoveryTokenPayload<ExtArgs>[]
      comments: Prisma.$commentsPayload<ExtArgs>[]
      savedStations: Prisma.$SavedStationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string | null
      passwordHash: string | null
      roleId: number
      isBanned: boolean
      emailVerificationKey: string | null
      emailVerifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permissions<T extends User$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RecoveryToken<T extends User$RecoveryTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$RecoveryTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedStations<T extends User$savedStationsArgs<ExtArgs> = {}>(args?: Subset<T, User$savedStationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly isBanned: FieldRef<"User", 'Boolean'>
    readonly emailVerificationKey: FieldRef<"User", 'String'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.permissions
   */
  export type User$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    where?: UserPermissionsWhereInput
    orderBy?: UserPermissionsOrderByWithRelationInput | UserPermissionsOrderByWithRelationInput[]
    cursor?: UserPermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPermissionsScalarFieldEnum | UserPermissionsScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    where?: UserActivityWhereInput
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    cursor?: UserActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * User.RecoveryToken
   */
  export type User$RecoveryTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    where?: RecoveryTokenWhereInput
    orderBy?: RecoveryTokenOrderByWithRelationInput | RecoveryTokenOrderByWithRelationInput[]
    cursor?: RecoveryTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecoveryTokenScalarFieldEnum | RecoveryTokenScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * User.savedStations
   */
  export type User$savedStationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    where?: SavedStationsWhereInput
    orderBy?: SavedStationsOrderByWithRelationInput | SavedStationsOrderByWithRelationInput[]
    cursor?: SavedStationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedStationsScalarFieldEnum | SavedStationsScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model SavedStations
   */

  export type AggregateSavedStations = {
    _count: SavedStationsCountAggregateOutputType | null
    _avg: SavedStationsAvgAggregateOutputType | null
    _sum: SavedStationsSumAggregateOutputType | null
    _min: SavedStationsMinAggregateOutputType | null
    _max: SavedStationsMaxAggregateOutputType | null
  }

  export type SavedStationsAvgAggregateOutputType = {
    userId: number | null
    markerId: number | null
  }

  export type SavedStationsSumAggregateOutputType = {
    userId: number | null
    markerId: number | null
  }

  export type SavedStationsMinAggregateOutputType = {
    userId: number | null
    markerId: number | null
  }

  export type SavedStationsMaxAggregateOutputType = {
    userId: number | null
    markerId: number | null
  }

  export type SavedStationsCountAggregateOutputType = {
    userId: number
    markerId: number
    _all: number
  }


  export type SavedStationsAvgAggregateInputType = {
    userId?: true
    markerId?: true
  }

  export type SavedStationsSumAggregateInputType = {
    userId?: true
    markerId?: true
  }

  export type SavedStationsMinAggregateInputType = {
    userId?: true
    markerId?: true
  }

  export type SavedStationsMaxAggregateInputType = {
    userId?: true
    markerId?: true
  }

  export type SavedStationsCountAggregateInputType = {
    userId?: true
    markerId?: true
    _all?: true
  }

  export type SavedStationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedStations to aggregate.
     */
    where?: SavedStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedStations to fetch.
     */
    orderBy?: SavedStationsOrderByWithRelationInput | SavedStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedStations
    **/
    _count?: true | SavedStationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SavedStationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SavedStationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedStationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedStationsMaxAggregateInputType
  }

  export type GetSavedStationsAggregateType<T extends SavedStationsAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedStations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedStations[P]>
      : GetScalarType<T[P], AggregateSavedStations[P]>
  }




  export type SavedStationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedStationsWhereInput
    orderBy?: SavedStationsOrderByWithAggregationInput | SavedStationsOrderByWithAggregationInput[]
    by: SavedStationsScalarFieldEnum[] | SavedStationsScalarFieldEnum
    having?: SavedStationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedStationsCountAggregateInputType | true
    _avg?: SavedStationsAvgAggregateInputType
    _sum?: SavedStationsSumAggregateInputType
    _min?: SavedStationsMinAggregateInputType
    _max?: SavedStationsMaxAggregateInputType
  }

  export type SavedStationsGroupByOutputType = {
    userId: number
    markerId: number
    _count: SavedStationsCountAggregateOutputType | null
    _avg: SavedStationsAvgAggregateOutputType | null
    _sum: SavedStationsSumAggregateOutputType | null
    _min: SavedStationsMinAggregateOutputType | null
    _max: SavedStationsMaxAggregateOutputType | null
  }

  type GetSavedStationsGroupByPayload<T extends SavedStationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedStationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedStationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedStationsGroupByOutputType[P]>
            : GetScalarType<T[P], SavedStationsGroupByOutputType[P]>
        }
      >
    >


  export type SavedStationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    markerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    marker?: boolean | station_markerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedStations"]>



  export type SavedStationsSelectScalar = {
    userId?: boolean
    markerId?: boolean
  }

  export type SavedStationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "markerId", ExtArgs["result"]["savedStations"]>
  export type SavedStationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    marker?: boolean | station_markerDefaultArgs<ExtArgs>
  }

  export type $SavedStationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedStations"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      marker: Prisma.$station_markerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      markerId: number
    }, ExtArgs["result"]["savedStations"]>
    composites: {}
  }

  type SavedStationsGetPayload<S extends boolean | null | undefined | SavedStationsDefaultArgs> = $Result.GetResult<Prisma.$SavedStationsPayload, S>

  type SavedStationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedStationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedStationsCountAggregateInputType | true
    }

  export interface SavedStationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedStations'], meta: { name: 'SavedStations' } }
    /**
     * Find zero or one SavedStations that matches the filter.
     * @param {SavedStationsFindUniqueArgs} args - Arguments to find a SavedStations
     * @example
     * // Get one SavedStations
     * const savedStations = await prisma.savedStations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedStationsFindUniqueArgs>(args: SelectSubset<T, SavedStationsFindUniqueArgs<ExtArgs>>): Prisma__SavedStationsClient<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedStations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedStationsFindUniqueOrThrowArgs} args - Arguments to find a SavedStations
     * @example
     * // Get one SavedStations
     * const savedStations = await prisma.savedStations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedStationsFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedStationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedStationsClient<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedStationsFindFirstArgs} args - Arguments to find a SavedStations
     * @example
     * // Get one SavedStations
     * const savedStations = await prisma.savedStations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedStationsFindFirstArgs>(args?: SelectSubset<T, SavedStationsFindFirstArgs<ExtArgs>>): Prisma__SavedStationsClient<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedStations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedStationsFindFirstOrThrowArgs} args - Arguments to find a SavedStations
     * @example
     * // Get one SavedStations
     * const savedStations = await prisma.savedStations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedStationsFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedStationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedStationsClient<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedStationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedStations
     * const savedStations = await prisma.savedStations.findMany()
     * 
     * // Get first 10 SavedStations
     * const savedStations = await prisma.savedStations.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const savedStationsWithUserIdOnly = await prisma.savedStations.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends SavedStationsFindManyArgs>(args?: SelectSubset<T, SavedStationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedStations.
     * @param {SavedStationsCreateArgs} args - Arguments to create a SavedStations.
     * @example
     * // Create one SavedStations
     * const SavedStations = await prisma.savedStations.create({
     *   data: {
     *     // ... data to create a SavedStations
     *   }
     * })
     * 
     */
    create<T extends SavedStationsCreateArgs>(args: SelectSubset<T, SavedStationsCreateArgs<ExtArgs>>): Prisma__SavedStationsClient<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedStations.
     * @param {SavedStationsCreateManyArgs} args - Arguments to create many SavedStations.
     * @example
     * // Create many SavedStations
     * const savedStations = await prisma.savedStations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedStationsCreateManyArgs>(args?: SelectSubset<T, SavedStationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SavedStations.
     * @param {SavedStationsDeleteArgs} args - Arguments to delete one SavedStations.
     * @example
     * // Delete one SavedStations
     * const SavedStations = await prisma.savedStations.delete({
     *   where: {
     *     // ... filter to delete one SavedStations
     *   }
     * })
     * 
     */
    delete<T extends SavedStationsDeleteArgs>(args: SelectSubset<T, SavedStationsDeleteArgs<ExtArgs>>): Prisma__SavedStationsClient<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedStations.
     * @param {SavedStationsUpdateArgs} args - Arguments to update one SavedStations.
     * @example
     * // Update one SavedStations
     * const savedStations = await prisma.savedStations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedStationsUpdateArgs>(args: SelectSubset<T, SavedStationsUpdateArgs<ExtArgs>>): Prisma__SavedStationsClient<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedStations.
     * @param {SavedStationsDeleteManyArgs} args - Arguments to filter SavedStations to delete.
     * @example
     * // Delete a few SavedStations
     * const { count } = await prisma.savedStations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedStationsDeleteManyArgs>(args?: SelectSubset<T, SavedStationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedStationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedStations
     * const savedStations = await prisma.savedStations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedStationsUpdateManyArgs>(args: SelectSubset<T, SavedStationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedStations.
     * @param {SavedStationsUpsertArgs} args - Arguments to update or create a SavedStations.
     * @example
     * // Update or create a SavedStations
     * const savedStations = await prisma.savedStations.upsert({
     *   create: {
     *     // ... data to create a SavedStations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedStations we want to update
     *   }
     * })
     */
    upsert<T extends SavedStationsUpsertArgs>(args: SelectSubset<T, SavedStationsUpsertArgs<ExtArgs>>): Prisma__SavedStationsClient<$Result.GetResult<Prisma.$SavedStationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedStationsCountArgs} args - Arguments to filter SavedStations to count.
     * @example
     * // Count the number of SavedStations
     * const count = await prisma.savedStations.count({
     *   where: {
     *     // ... the filter for the SavedStations we want to count
     *   }
     * })
    **/
    count<T extends SavedStationsCountArgs>(
      args?: Subset<T, SavedStationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedStationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedStationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedStationsAggregateArgs>(args: Subset<T, SavedStationsAggregateArgs>): Prisma.PrismaPromise<GetSavedStationsAggregateType<T>>

    /**
     * Group by SavedStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedStationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedStationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedStationsGroupByArgs['orderBy'] }
        : { orderBy?: SavedStationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedStationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedStationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedStations model
   */
  readonly fields: SavedStationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedStations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedStationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marker<T extends station_markerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, station_markerDefaultArgs<ExtArgs>>): Prisma__station_markerClient<$Result.GetResult<Prisma.$station_markerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedStations model
   */
  interface SavedStationsFieldRefs {
    readonly userId: FieldRef<"SavedStations", 'Int'>
    readonly markerId: FieldRef<"SavedStations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SavedStations findUnique
   */
  export type SavedStationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    /**
     * Filter, which SavedStations to fetch.
     */
    where: SavedStationsWhereUniqueInput
  }

  /**
   * SavedStations findUniqueOrThrow
   */
  export type SavedStationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    /**
     * Filter, which SavedStations to fetch.
     */
    where: SavedStationsWhereUniqueInput
  }

  /**
   * SavedStations findFirst
   */
  export type SavedStationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    /**
     * Filter, which SavedStations to fetch.
     */
    where?: SavedStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedStations to fetch.
     */
    orderBy?: SavedStationsOrderByWithRelationInput | SavedStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedStations.
     */
    cursor?: SavedStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedStations.
     */
    distinct?: SavedStationsScalarFieldEnum | SavedStationsScalarFieldEnum[]
  }

  /**
   * SavedStations findFirstOrThrow
   */
  export type SavedStationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    /**
     * Filter, which SavedStations to fetch.
     */
    where?: SavedStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedStations to fetch.
     */
    orderBy?: SavedStationsOrderByWithRelationInput | SavedStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedStations.
     */
    cursor?: SavedStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedStations.
     */
    distinct?: SavedStationsScalarFieldEnum | SavedStationsScalarFieldEnum[]
  }

  /**
   * SavedStations findMany
   */
  export type SavedStationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    /**
     * Filter, which SavedStations to fetch.
     */
    where?: SavedStationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedStations to fetch.
     */
    orderBy?: SavedStationsOrderByWithRelationInput | SavedStationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedStations.
     */
    cursor?: SavedStationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedStations.
     */
    skip?: number
    distinct?: SavedStationsScalarFieldEnum | SavedStationsScalarFieldEnum[]
  }

  /**
   * SavedStations create
   */
  export type SavedStationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedStations.
     */
    data: XOR<SavedStationsCreateInput, SavedStationsUncheckedCreateInput>
  }

  /**
   * SavedStations createMany
   */
  export type SavedStationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedStations.
     */
    data: SavedStationsCreateManyInput | SavedStationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedStations update
   */
  export type SavedStationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedStations.
     */
    data: XOR<SavedStationsUpdateInput, SavedStationsUncheckedUpdateInput>
    /**
     * Choose, which SavedStations to update.
     */
    where: SavedStationsWhereUniqueInput
  }

  /**
   * SavedStations updateMany
   */
  export type SavedStationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedStations.
     */
    data: XOR<SavedStationsUpdateManyMutationInput, SavedStationsUncheckedUpdateManyInput>
    /**
     * Filter which SavedStations to update
     */
    where?: SavedStationsWhereInput
    /**
     * Limit how many SavedStations to update.
     */
    limit?: number
  }

  /**
   * SavedStations upsert
   */
  export type SavedStationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedStations to update in case it exists.
     */
    where: SavedStationsWhereUniqueInput
    /**
     * In case the SavedStations found by the `where` argument doesn't exist, create a new SavedStations with this data.
     */
    create: XOR<SavedStationsCreateInput, SavedStationsUncheckedCreateInput>
    /**
     * In case the SavedStations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedStationsUpdateInput, SavedStationsUncheckedUpdateInput>
  }

  /**
   * SavedStations delete
   */
  export type SavedStationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
    /**
     * Filter which SavedStations to delete.
     */
    where: SavedStationsWhereUniqueInput
  }

  /**
   * SavedStations deleteMany
   */
  export type SavedStationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedStations to delete
     */
    where?: SavedStationsWhereInput
    /**
     * Limit how many SavedStations to delete.
     */
    limit?: number
  }

  /**
   * SavedStations without action
   */
  export type SavedStationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedStations
     */
    select?: SavedStationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedStations
     */
    omit?: SavedStationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedStationsInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    resource: string | null
    action: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    resource: string | null
    action: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    resource: number
    action: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    resource?: true
    action?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    resource?: true
    action?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    resource?: true
    action?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    resource: string
    action: string
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resource?: boolean
    action?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>



  export type PermissionSelectScalar = {
    id?: boolean
    resource?: boolean
    action?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resource" | "action", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      resource: string
      action: string
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: number
    roleId: number
    permissionId: number
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    users?: boolean | RolePermission$usersArgs<ExtArgs>
    _count?: boolean | RolePermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>



  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    users?: boolean | RolePermission$usersArgs<ExtArgs>
    _count?: boolean | RolePermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
      users: Prisma.$UserPermissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number
      permissionId: number
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends RolePermission$usersArgs<ExtArgs> = {}>(args?: Subset<T, RolePermission$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'Int'>
    readonly roleId: FieldRef<"RolePermission", 'Int'>
    readonly permissionId: FieldRef<"RolePermission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission.users
   */
  export type RolePermission$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    where?: UserPermissionsWhereInput
    orderBy?: UserPermissionsOrderByWithRelationInput | UserPermissionsOrderByWithRelationInput[]
    cursor?: UserPermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPermissionsScalarFieldEnum | UserPermissionsScalarFieldEnum[]
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model RecoveryToken
   */

  export type AggregateRecoveryToken = {
    _count: RecoveryTokenCountAggregateOutputType | null
    _avg: RecoveryTokenAvgAggregateOutputType | null
    _sum: RecoveryTokenSumAggregateOutputType | null
    _min: RecoveryTokenMinAggregateOutputType | null
    _max: RecoveryTokenMaxAggregateOutputType | null
  }

  export type RecoveryTokenAvgAggregateOutputType = {
    userId: number | null
  }

  export type RecoveryTokenSumAggregateOutputType = {
    userId: number | null
  }

  export type RecoveryTokenMinAggregateOutputType = {
    userId: number | null
    tokenHash: string | null
    expiresAt: Date | null
  }

  export type RecoveryTokenMaxAggregateOutputType = {
    userId: number | null
    tokenHash: string | null
    expiresAt: Date | null
  }

  export type RecoveryTokenCountAggregateOutputType = {
    userId: number
    tokenHash: number
    expiresAt: number
    _all: number
  }


  export type RecoveryTokenAvgAggregateInputType = {
    userId?: true
  }

  export type RecoveryTokenSumAggregateInputType = {
    userId?: true
  }

  export type RecoveryTokenMinAggregateInputType = {
    userId?: true
    tokenHash?: true
    expiresAt?: true
  }

  export type RecoveryTokenMaxAggregateInputType = {
    userId?: true
    tokenHash?: true
    expiresAt?: true
  }

  export type RecoveryTokenCountAggregateInputType = {
    userId?: true
    tokenHash?: true
    expiresAt?: true
    _all?: true
  }

  export type RecoveryTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryToken to aggregate.
     */
    where?: RecoveryTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryTokens to fetch.
     */
    orderBy?: RecoveryTokenOrderByWithRelationInput | RecoveryTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecoveryTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecoveryTokens
    **/
    _count?: true | RecoveryTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecoveryTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecoveryTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecoveryTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecoveryTokenMaxAggregateInputType
  }

  export type GetRecoveryTokenAggregateType<T extends RecoveryTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRecoveryToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecoveryToken[P]>
      : GetScalarType<T[P], AggregateRecoveryToken[P]>
  }




  export type RecoveryTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecoveryTokenWhereInput
    orderBy?: RecoveryTokenOrderByWithAggregationInput | RecoveryTokenOrderByWithAggregationInput[]
    by: RecoveryTokenScalarFieldEnum[] | RecoveryTokenScalarFieldEnum
    having?: RecoveryTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecoveryTokenCountAggregateInputType | true
    _avg?: RecoveryTokenAvgAggregateInputType
    _sum?: RecoveryTokenSumAggregateInputType
    _min?: RecoveryTokenMinAggregateInputType
    _max?: RecoveryTokenMaxAggregateInputType
  }

  export type RecoveryTokenGroupByOutputType = {
    userId: number
    tokenHash: string
    expiresAt: Date
    _count: RecoveryTokenCountAggregateOutputType | null
    _avg: RecoveryTokenAvgAggregateOutputType | null
    _sum: RecoveryTokenSumAggregateOutputType | null
    _min: RecoveryTokenMinAggregateOutputType | null
    _max: RecoveryTokenMaxAggregateOutputType | null
  }

  type GetRecoveryTokenGroupByPayload<T extends RecoveryTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecoveryTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecoveryTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecoveryTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RecoveryTokenGroupByOutputType[P]>
        }
      >
    >


  export type RecoveryTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recoveryToken"]>



  export type RecoveryTokenSelectScalar = {
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
  }

  export type RecoveryTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "tokenHash" | "expiresAt", ExtArgs["result"]["recoveryToken"]>
  export type RecoveryTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RecoveryTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecoveryToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      tokenHash: string
      expiresAt: Date
    }, ExtArgs["result"]["recoveryToken"]>
    composites: {}
  }

  type RecoveryTokenGetPayload<S extends boolean | null | undefined | RecoveryTokenDefaultArgs> = $Result.GetResult<Prisma.$RecoveryTokenPayload, S>

  type RecoveryTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecoveryTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecoveryTokenCountAggregateInputType | true
    }

  export interface RecoveryTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecoveryToken'], meta: { name: 'RecoveryToken' } }
    /**
     * Find zero or one RecoveryToken that matches the filter.
     * @param {RecoveryTokenFindUniqueArgs} args - Arguments to find a RecoveryToken
     * @example
     * // Get one RecoveryToken
     * const recoveryToken = await prisma.recoveryToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecoveryTokenFindUniqueArgs>(args: SelectSubset<T, RecoveryTokenFindUniqueArgs<ExtArgs>>): Prisma__RecoveryTokenClient<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecoveryToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecoveryTokenFindUniqueOrThrowArgs} args - Arguments to find a RecoveryToken
     * @example
     * // Get one RecoveryToken
     * const recoveryToken = await prisma.recoveryToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecoveryTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RecoveryTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecoveryTokenClient<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryTokenFindFirstArgs} args - Arguments to find a RecoveryToken
     * @example
     * // Get one RecoveryToken
     * const recoveryToken = await prisma.recoveryToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecoveryTokenFindFirstArgs>(args?: SelectSubset<T, RecoveryTokenFindFirstArgs<ExtArgs>>): Prisma__RecoveryTokenClient<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecoveryToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryTokenFindFirstOrThrowArgs} args - Arguments to find a RecoveryToken
     * @example
     * // Get one RecoveryToken
     * const recoveryToken = await prisma.recoveryToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecoveryTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RecoveryTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecoveryTokenClient<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecoveryTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecoveryTokens
     * const recoveryTokens = await prisma.recoveryToken.findMany()
     * 
     * // Get first 10 RecoveryTokens
     * const recoveryTokens = await prisma.recoveryToken.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const recoveryTokenWithUserIdOnly = await prisma.recoveryToken.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends RecoveryTokenFindManyArgs>(args?: SelectSubset<T, RecoveryTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecoveryToken.
     * @param {RecoveryTokenCreateArgs} args - Arguments to create a RecoveryToken.
     * @example
     * // Create one RecoveryToken
     * const RecoveryToken = await prisma.recoveryToken.create({
     *   data: {
     *     // ... data to create a RecoveryToken
     *   }
     * })
     * 
     */
    create<T extends RecoveryTokenCreateArgs>(args: SelectSubset<T, RecoveryTokenCreateArgs<ExtArgs>>): Prisma__RecoveryTokenClient<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecoveryTokens.
     * @param {RecoveryTokenCreateManyArgs} args - Arguments to create many RecoveryTokens.
     * @example
     * // Create many RecoveryTokens
     * const recoveryToken = await prisma.recoveryToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecoveryTokenCreateManyArgs>(args?: SelectSubset<T, RecoveryTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecoveryToken.
     * @param {RecoveryTokenDeleteArgs} args - Arguments to delete one RecoveryToken.
     * @example
     * // Delete one RecoveryToken
     * const RecoveryToken = await prisma.recoveryToken.delete({
     *   where: {
     *     // ... filter to delete one RecoveryToken
     *   }
     * })
     * 
     */
    delete<T extends RecoveryTokenDeleteArgs>(args: SelectSubset<T, RecoveryTokenDeleteArgs<ExtArgs>>): Prisma__RecoveryTokenClient<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecoveryToken.
     * @param {RecoveryTokenUpdateArgs} args - Arguments to update one RecoveryToken.
     * @example
     * // Update one RecoveryToken
     * const recoveryToken = await prisma.recoveryToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecoveryTokenUpdateArgs>(args: SelectSubset<T, RecoveryTokenUpdateArgs<ExtArgs>>): Prisma__RecoveryTokenClient<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecoveryTokens.
     * @param {RecoveryTokenDeleteManyArgs} args - Arguments to filter RecoveryTokens to delete.
     * @example
     * // Delete a few RecoveryTokens
     * const { count } = await prisma.recoveryToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecoveryTokenDeleteManyArgs>(args?: SelectSubset<T, RecoveryTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecoveryTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecoveryTokens
     * const recoveryToken = await prisma.recoveryToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecoveryTokenUpdateManyArgs>(args: SelectSubset<T, RecoveryTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecoveryToken.
     * @param {RecoveryTokenUpsertArgs} args - Arguments to update or create a RecoveryToken.
     * @example
     * // Update or create a RecoveryToken
     * const recoveryToken = await prisma.recoveryToken.upsert({
     *   create: {
     *     // ... data to create a RecoveryToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecoveryToken we want to update
     *   }
     * })
     */
    upsert<T extends RecoveryTokenUpsertArgs>(args: SelectSubset<T, RecoveryTokenUpsertArgs<ExtArgs>>): Prisma__RecoveryTokenClient<$Result.GetResult<Prisma.$RecoveryTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecoveryTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryTokenCountArgs} args - Arguments to filter RecoveryTokens to count.
     * @example
     * // Count the number of RecoveryTokens
     * const count = await prisma.recoveryToken.count({
     *   where: {
     *     // ... the filter for the RecoveryTokens we want to count
     *   }
     * })
    **/
    count<T extends RecoveryTokenCountArgs>(
      args?: Subset<T, RecoveryTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecoveryTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecoveryToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecoveryTokenAggregateArgs>(args: Subset<T, RecoveryTokenAggregateArgs>): Prisma.PrismaPromise<GetRecoveryTokenAggregateType<T>>

    /**
     * Group by RecoveryToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecoveryTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecoveryTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecoveryTokenGroupByArgs['orderBy'] }
        : { orderBy?: RecoveryTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecoveryTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecoveryTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecoveryToken model
   */
  readonly fields: RecoveryTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecoveryToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecoveryTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecoveryToken model
   */
  interface RecoveryTokenFieldRefs {
    readonly userId: FieldRef<"RecoveryToken", 'Int'>
    readonly tokenHash: FieldRef<"RecoveryToken", 'String'>
    readonly expiresAt: FieldRef<"RecoveryToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecoveryToken findUnique
   */
  export type RecoveryTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryToken to fetch.
     */
    where: RecoveryTokenWhereUniqueInput
  }

  /**
   * RecoveryToken findUniqueOrThrow
   */
  export type RecoveryTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryToken to fetch.
     */
    where: RecoveryTokenWhereUniqueInput
  }

  /**
   * RecoveryToken findFirst
   */
  export type RecoveryTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryToken to fetch.
     */
    where?: RecoveryTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryTokens to fetch.
     */
    orderBy?: RecoveryTokenOrderByWithRelationInput | RecoveryTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryTokens.
     */
    cursor?: RecoveryTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryTokens.
     */
    distinct?: RecoveryTokenScalarFieldEnum | RecoveryTokenScalarFieldEnum[]
  }

  /**
   * RecoveryToken findFirstOrThrow
   */
  export type RecoveryTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryToken to fetch.
     */
    where?: RecoveryTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryTokens to fetch.
     */
    orderBy?: RecoveryTokenOrderByWithRelationInput | RecoveryTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecoveryTokens.
     */
    cursor?: RecoveryTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecoveryTokens.
     */
    distinct?: RecoveryTokenScalarFieldEnum | RecoveryTokenScalarFieldEnum[]
  }

  /**
   * RecoveryToken findMany
   */
  export type RecoveryTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    /**
     * Filter, which RecoveryTokens to fetch.
     */
    where?: RecoveryTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecoveryTokens to fetch.
     */
    orderBy?: RecoveryTokenOrderByWithRelationInput | RecoveryTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecoveryTokens.
     */
    cursor?: RecoveryTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecoveryTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecoveryTokens.
     */
    skip?: number
    distinct?: RecoveryTokenScalarFieldEnum | RecoveryTokenScalarFieldEnum[]
  }

  /**
   * RecoveryToken create
   */
  export type RecoveryTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RecoveryToken.
     */
    data: XOR<RecoveryTokenCreateInput, RecoveryTokenUncheckedCreateInput>
  }

  /**
   * RecoveryToken createMany
   */
  export type RecoveryTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecoveryTokens.
     */
    data: RecoveryTokenCreateManyInput | RecoveryTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecoveryToken update
   */
  export type RecoveryTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RecoveryToken.
     */
    data: XOR<RecoveryTokenUpdateInput, RecoveryTokenUncheckedUpdateInput>
    /**
     * Choose, which RecoveryToken to update.
     */
    where: RecoveryTokenWhereUniqueInput
  }

  /**
   * RecoveryToken updateMany
   */
  export type RecoveryTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecoveryTokens.
     */
    data: XOR<RecoveryTokenUpdateManyMutationInput, RecoveryTokenUncheckedUpdateManyInput>
    /**
     * Filter which RecoveryTokens to update
     */
    where?: RecoveryTokenWhereInput
    /**
     * Limit how many RecoveryTokens to update.
     */
    limit?: number
  }

  /**
   * RecoveryToken upsert
   */
  export type RecoveryTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RecoveryToken to update in case it exists.
     */
    where: RecoveryTokenWhereUniqueInput
    /**
     * In case the RecoveryToken found by the `where` argument doesn't exist, create a new RecoveryToken with this data.
     */
    create: XOR<RecoveryTokenCreateInput, RecoveryTokenUncheckedCreateInput>
    /**
     * In case the RecoveryToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecoveryTokenUpdateInput, RecoveryTokenUncheckedUpdateInput>
  }

  /**
   * RecoveryToken delete
   */
  export type RecoveryTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
    /**
     * Filter which RecoveryToken to delete.
     */
    where: RecoveryTokenWhereUniqueInput
  }

  /**
   * RecoveryToken deleteMany
   */
  export type RecoveryTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecoveryTokens to delete
     */
    where?: RecoveryTokenWhereInput
    /**
     * Limit how many RecoveryTokens to delete.
     */
    limit?: number
  }

  /**
   * RecoveryToken without action
   */
  export type RecoveryTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecoveryToken
     */
    select?: RecoveryTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecoveryToken
     */
    omit?: RecoveryTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecoveryTokenInclude<ExtArgs> | null
  }


  /**
   * Model UserPermissions
   */

  export type AggregateUserPermissions = {
    _count: UserPermissionsCountAggregateOutputType | null
    _avg: UserPermissionsAvgAggregateOutputType | null
    _sum: UserPermissionsSumAggregateOutputType | null
    _min: UserPermissionsMinAggregateOutputType | null
    _max: UserPermissionsMaxAggregateOutputType | null
  }

  export type UserPermissionsAvgAggregateOutputType = {
    userId: number | null
    rolePermissionId: number | null
  }

  export type UserPermissionsSumAggregateOutputType = {
    userId: number | null
    rolePermissionId: number | null
  }

  export type UserPermissionsMinAggregateOutputType = {
    userId: number | null
    rolePermissionId: number | null
  }

  export type UserPermissionsMaxAggregateOutputType = {
    userId: number | null
    rolePermissionId: number | null
  }

  export type UserPermissionsCountAggregateOutputType = {
    userId: number
    rolePermissionId: number
    _all: number
  }


  export type UserPermissionsAvgAggregateInputType = {
    userId?: true
    rolePermissionId?: true
  }

  export type UserPermissionsSumAggregateInputType = {
    userId?: true
    rolePermissionId?: true
  }

  export type UserPermissionsMinAggregateInputType = {
    userId?: true
    rolePermissionId?: true
  }

  export type UserPermissionsMaxAggregateInputType = {
    userId?: true
    rolePermissionId?: true
  }

  export type UserPermissionsCountAggregateInputType = {
    userId?: true
    rolePermissionId?: true
    _all?: true
  }

  export type UserPermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPermissions to aggregate.
     */
    where?: UserPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionsOrderByWithRelationInput | UserPermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPermissions
    **/
    _count?: true | UserPermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPermissionsMaxAggregateInputType
  }

  export type GetUserPermissionsAggregateType<T extends UserPermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPermissions[P]>
      : GetScalarType<T[P], AggregateUserPermissions[P]>
  }




  export type UserPermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionsWhereInput
    orderBy?: UserPermissionsOrderByWithAggregationInput | UserPermissionsOrderByWithAggregationInput[]
    by: UserPermissionsScalarFieldEnum[] | UserPermissionsScalarFieldEnum
    having?: UserPermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPermissionsCountAggregateInputType | true
    _avg?: UserPermissionsAvgAggregateInputType
    _sum?: UserPermissionsSumAggregateInputType
    _min?: UserPermissionsMinAggregateInputType
    _max?: UserPermissionsMaxAggregateInputType
  }

  export type UserPermissionsGroupByOutputType = {
    userId: number
    rolePermissionId: number
    _count: UserPermissionsCountAggregateOutputType | null
    _avg: UserPermissionsAvgAggregateOutputType | null
    _sum: UserPermissionsSumAggregateOutputType | null
    _min: UserPermissionsMinAggregateOutputType | null
    _max: UserPermissionsMaxAggregateOutputType | null
  }

  type GetUserPermissionsGroupByPayload<T extends UserPermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], UserPermissionsGroupByOutputType[P]>
        }
      >
    >


  export type UserPermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    rolePermissionId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    rolePermission?: boolean | RolePermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermissions"]>



  export type UserPermissionsSelectScalar = {
    userId?: boolean
    rolePermissionId?: boolean
  }

  export type UserPermissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "rolePermissionId", ExtArgs["result"]["userPermissions"]>
  export type UserPermissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    rolePermission?: boolean | RolePermissionDefaultArgs<ExtArgs>
  }

  export type $UserPermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPermissions"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      rolePermission: Prisma.$RolePermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      rolePermissionId: number
    }, ExtArgs["result"]["userPermissions"]>
    composites: {}
  }

  type UserPermissionsGetPayload<S extends boolean | null | undefined | UserPermissionsDefaultArgs> = $Result.GetResult<Prisma.$UserPermissionsPayload, S>

  type UserPermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPermissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPermissionsCountAggregateInputType | true
    }

  export interface UserPermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPermissions'], meta: { name: 'UserPermissions' } }
    /**
     * Find zero or one UserPermissions that matches the filter.
     * @param {UserPermissionsFindUniqueArgs} args - Arguments to find a UserPermissions
     * @example
     * // Get one UserPermissions
     * const userPermissions = await prisma.userPermissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPermissionsFindUniqueArgs>(args: SelectSubset<T, UserPermissionsFindUniqueArgs<ExtArgs>>): Prisma__UserPermissionsClient<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPermissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPermissionsFindUniqueOrThrowArgs} args - Arguments to find a UserPermissions
     * @example
     * // Get one UserPermissions
     * const userPermissions = await prisma.userPermissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPermissionsClient<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsFindFirstArgs} args - Arguments to find a UserPermissions
     * @example
     * // Get one UserPermissions
     * const userPermissions = await prisma.userPermissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPermissionsFindFirstArgs>(args?: SelectSubset<T, UserPermissionsFindFirstArgs<ExtArgs>>): Prisma__UserPermissionsClient<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPermissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsFindFirstOrThrowArgs} args - Arguments to find a UserPermissions
     * @example
     * // Get one UserPermissions
     * const userPermissions = await prisma.userPermissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPermissionsClient<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPermissions
     * const userPermissions = await prisma.userPermissions.findMany()
     * 
     * // Get first 10 UserPermissions
     * const userPermissions = await prisma.userPermissions.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userPermissionsWithUserIdOnly = await prisma.userPermissions.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserPermissionsFindManyArgs>(args?: SelectSubset<T, UserPermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPermissions.
     * @param {UserPermissionsCreateArgs} args - Arguments to create a UserPermissions.
     * @example
     * // Create one UserPermissions
     * const UserPermissions = await prisma.userPermissions.create({
     *   data: {
     *     // ... data to create a UserPermissions
     *   }
     * })
     * 
     */
    create<T extends UserPermissionsCreateArgs>(args: SelectSubset<T, UserPermissionsCreateArgs<ExtArgs>>): Prisma__UserPermissionsClient<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPermissions.
     * @param {UserPermissionsCreateManyArgs} args - Arguments to create many UserPermissions.
     * @example
     * // Create many UserPermissions
     * const userPermissions = await prisma.userPermissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPermissionsCreateManyArgs>(args?: SelectSubset<T, UserPermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPermissions.
     * @param {UserPermissionsDeleteArgs} args - Arguments to delete one UserPermissions.
     * @example
     * // Delete one UserPermissions
     * const UserPermissions = await prisma.userPermissions.delete({
     *   where: {
     *     // ... filter to delete one UserPermissions
     *   }
     * })
     * 
     */
    delete<T extends UserPermissionsDeleteArgs>(args: SelectSubset<T, UserPermissionsDeleteArgs<ExtArgs>>): Prisma__UserPermissionsClient<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPermissions.
     * @param {UserPermissionsUpdateArgs} args - Arguments to update one UserPermissions.
     * @example
     * // Update one UserPermissions
     * const userPermissions = await prisma.userPermissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPermissionsUpdateArgs>(args: SelectSubset<T, UserPermissionsUpdateArgs<ExtArgs>>): Prisma__UserPermissionsClient<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPermissions.
     * @param {UserPermissionsDeleteManyArgs} args - Arguments to filter UserPermissions to delete.
     * @example
     * // Delete a few UserPermissions
     * const { count } = await prisma.userPermissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPermissionsDeleteManyArgs>(args?: SelectSubset<T, UserPermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPermissions
     * const userPermissions = await prisma.userPermissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPermissionsUpdateManyArgs>(args: SelectSubset<T, UserPermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPermissions.
     * @param {UserPermissionsUpsertArgs} args - Arguments to update or create a UserPermissions.
     * @example
     * // Update or create a UserPermissions
     * const userPermissions = await prisma.userPermissions.upsert({
     *   create: {
     *     // ... data to create a UserPermissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPermissions we want to update
     *   }
     * })
     */
    upsert<T extends UserPermissionsUpsertArgs>(args: SelectSubset<T, UserPermissionsUpsertArgs<ExtArgs>>): Prisma__UserPermissionsClient<$Result.GetResult<Prisma.$UserPermissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsCountArgs} args - Arguments to filter UserPermissions to count.
     * @example
     * // Count the number of UserPermissions
     * const count = await prisma.userPermissions.count({
     *   where: {
     *     // ... the filter for the UserPermissions we want to count
     *   }
     * })
    **/
    count<T extends UserPermissionsCountArgs>(
      args?: Subset<T, UserPermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPermissionsAggregateArgs>(args: Subset<T, UserPermissionsAggregateArgs>): Prisma.PrismaPromise<GetUserPermissionsAggregateType<T>>

    /**
     * Group by UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPermissionsGroupByArgs['orderBy'] }
        : { orderBy?: UserPermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPermissions model
   */
  readonly fields: UserPermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPermissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rolePermission<T extends RolePermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolePermissionDefaultArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPermissions model
   */
  interface UserPermissionsFieldRefs {
    readonly userId: FieldRef<"UserPermissions", 'Int'>
    readonly rolePermissionId: FieldRef<"UserPermissions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserPermissions findUnique
   */
  export type UserPermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserPermissions to fetch.
     */
    where: UserPermissionsWhereUniqueInput
  }

  /**
   * UserPermissions findUniqueOrThrow
   */
  export type UserPermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserPermissions to fetch.
     */
    where: UserPermissionsWhereUniqueInput
  }

  /**
   * UserPermissions findFirst
   */
  export type UserPermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserPermissions to fetch.
     */
    where?: UserPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionsOrderByWithRelationInput | UserPermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPermissions.
     */
    cursor?: UserPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPermissions.
     */
    distinct?: UserPermissionsScalarFieldEnum | UserPermissionsScalarFieldEnum[]
  }

  /**
   * UserPermissions findFirstOrThrow
   */
  export type UserPermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserPermissions to fetch.
     */
    where?: UserPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionsOrderByWithRelationInput | UserPermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPermissions.
     */
    cursor?: UserPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPermissions.
     */
    distinct?: UserPermissionsScalarFieldEnum | UserPermissionsScalarFieldEnum[]
  }

  /**
   * UserPermissions findMany
   */
  export type UserPermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserPermissions to fetch.
     */
    where?: UserPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionsOrderByWithRelationInput | UserPermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPermissions.
     */
    cursor?: UserPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    distinct?: UserPermissionsScalarFieldEnum | UserPermissionsScalarFieldEnum[]
  }

  /**
   * UserPermissions create
   */
  export type UserPermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPermissions.
     */
    data: XOR<UserPermissionsCreateInput, UserPermissionsUncheckedCreateInput>
  }

  /**
   * UserPermissions createMany
   */
  export type UserPermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPermissions.
     */
    data: UserPermissionsCreateManyInput | UserPermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPermissions update
   */
  export type UserPermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPermissions.
     */
    data: XOR<UserPermissionsUpdateInput, UserPermissionsUncheckedUpdateInput>
    /**
     * Choose, which UserPermissions to update.
     */
    where: UserPermissionsWhereUniqueInput
  }

  /**
   * UserPermissions updateMany
   */
  export type UserPermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPermissions.
     */
    data: XOR<UserPermissionsUpdateManyMutationInput, UserPermissionsUncheckedUpdateManyInput>
    /**
     * Filter which UserPermissions to update
     */
    where?: UserPermissionsWhereInput
    /**
     * Limit how many UserPermissions to update.
     */
    limit?: number
  }

  /**
   * UserPermissions upsert
   */
  export type UserPermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPermissions to update in case it exists.
     */
    where: UserPermissionsWhereUniqueInput
    /**
     * In case the UserPermissions found by the `where` argument doesn't exist, create a new UserPermissions with this data.
     */
    create: XOR<UserPermissionsCreateInput, UserPermissionsUncheckedCreateInput>
    /**
     * In case the UserPermissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPermissionsUpdateInput, UserPermissionsUncheckedUpdateInput>
  }

  /**
   * UserPermissions delete
   */
  export type UserPermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
    /**
     * Filter which UserPermissions to delete.
     */
    where: UserPermissionsWhereUniqueInput
  }

  /**
   * UserPermissions deleteMany
   */
  export type UserPermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPermissions to delete
     */
    where?: UserPermissionsWhereInput
    /**
     * Limit how many UserPermissions to delete.
     */
    limit?: number
  }

  /**
   * UserPermissions without action
   */
  export type UserPermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermissions
     */
    select?: UserPermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermissions
     */
    omit?: UserPermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionsInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserSessionSumAggregateOutputType = {
    userId: number | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    ip: string | null
    userAgent: string | null
    refreshToken: string | null
    userId: number | null
    lastRefreshAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    ip: string | null
    userAgent: string | null
    refreshToken: string | null
    userId: number | null
    lastRefreshAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    ip: number
    userAgent: number
    refreshToken: number
    userId: number
    lastRefreshAt: number
    _all: number
  }


  export type UserSessionAvgAggregateInputType = {
    userId?: true
  }

  export type UserSessionSumAggregateInputType = {
    userId?: true
  }

  export type UserSessionMinAggregateInputType = {
    id?: true
    ip?: true
    userAgent?: true
    refreshToken?: true
    userId?: true
    lastRefreshAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    ip?: true
    userAgent?: true
    refreshToken?: true
    userId?: true
    lastRefreshAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    ip?: true
    userAgent?: true
    refreshToken?: true
    userId?: true
    lastRefreshAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _avg?: UserSessionAvgAggregateInputType
    _sum?: UserSessionSumAggregateInputType
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    ip: string
    userAgent: string
    refreshToken: string
    userId: number
    lastRefreshAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    userAgent?: boolean
    refreshToken?: boolean
    userId?: boolean
    lastRefreshAt?: boolean
  }, ExtArgs["result"]["userSession"]>



  export type UserSessionSelectScalar = {
    id?: boolean
    ip?: boolean
    userAgent?: boolean
    refreshToken?: boolean
    userId?: boolean
    lastRefreshAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ip" | "userAgent" | "refreshToken" | "userId" | "lastRefreshAt", ExtArgs["result"]["userSession"]>

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ip: string
      userAgent: string
      refreshToken: string
      userId: number
      lastRefreshAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly ip: FieldRef<"UserSession", 'String'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly refreshToken: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'Int'>
    readonly lastRefreshAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
  }


  /**
   * Model UserActivity
   */

  export type AggregateUserActivity = {
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  export type UserActivityAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserActivitySumAggregateOutputType = {
    userId: number | null
  }

  export type UserActivityMinAggregateOutputType = {
    userId: number | null
    ip: string | null
    lastActivityAt: Date | null
  }

  export type UserActivityMaxAggregateOutputType = {
    userId: number | null
    ip: string | null
    lastActivityAt: Date | null
  }

  export type UserActivityCountAggregateOutputType = {
    userId: number
    ip: number
    lastActivityAt: number
    _all: number
  }


  export type UserActivityAvgAggregateInputType = {
    userId?: true
  }

  export type UserActivitySumAggregateInputType = {
    userId?: true
  }

  export type UserActivityMinAggregateInputType = {
    userId?: true
    ip?: true
    lastActivityAt?: true
  }

  export type UserActivityMaxAggregateInputType = {
    userId?: true
    ip?: true
    lastActivityAt?: true
  }

  export type UserActivityCountAggregateInputType = {
    userId?: true
    ip?: true
    lastActivityAt?: true
    _all?: true
  }

  export type UserActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivity to aggregate.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActivities
    **/
    _count?: true | UserActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivityMaxAggregateInputType
  }

  export type GetUserActivityAggregateType<T extends UserActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivity[P]>
      : GetScalarType<T[P], AggregateUserActivity[P]>
  }




  export type UserActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityWhereInput
    orderBy?: UserActivityOrderByWithAggregationInput | UserActivityOrderByWithAggregationInput[]
    by: UserActivityScalarFieldEnum[] | UserActivityScalarFieldEnum
    having?: UserActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivityCountAggregateInputType | true
    _avg?: UserActivityAvgAggregateInputType
    _sum?: UserActivitySumAggregateInputType
    _min?: UserActivityMinAggregateInputType
    _max?: UserActivityMaxAggregateInputType
  }

  export type UserActivityGroupByOutputType = {
    userId: number
    ip: string
    lastActivityAt: Date
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  type GetUserActivityGroupByPayload<T extends UserActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
        }
      >
    >


  export type UserActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    ip?: boolean
    lastActivityAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivity"]>



  export type UserActivitySelectScalar = {
    userId?: boolean
    ip?: boolean
    lastActivityAt?: boolean
  }

  export type UserActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "ip" | "lastActivityAt", ExtArgs["result"]["userActivity"]>
  export type UserActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserActivity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      ip: string
      lastActivityAt: Date
    }, ExtArgs["result"]["userActivity"]>
    composites: {}
  }

  type UserActivityGetPayload<S extends boolean | null | undefined | UserActivityDefaultArgs> = $Result.GetResult<Prisma.$UserActivityPayload, S>

  type UserActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserActivityCountAggregateInputType | true
    }

  export interface UserActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserActivity'], meta: { name: 'UserActivity' } }
    /**
     * Find zero or one UserActivity that matches the filter.
     * @param {UserActivityFindUniqueArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserActivityFindUniqueArgs>(args: SelectSubset<T, UserActivityFindUniqueArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserActivityFindUniqueOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, UserActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindFirstArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserActivityFindFirstArgs>(args?: SelectSubset<T, UserActivityFindFirstArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindFirstOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, UserActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivities
     * const userActivities = await prisma.userActivity.findMany()
     * 
     * // Get first 10 UserActivities
     * const userActivities = await prisma.userActivity.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userActivityWithUserIdOnly = await prisma.userActivity.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserActivityFindManyArgs>(args?: SelectSubset<T, UserActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserActivity.
     * @param {UserActivityCreateArgs} args - Arguments to create a UserActivity.
     * @example
     * // Create one UserActivity
     * const UserActivity = await prisma.userActivity.create({
     *   data: {
     *     // ... data to create a UserActivity
     *   }
     * })
     * 
     */
    create<T extends UserActivityCreateArgs>(args: SelectSubset<T, UserActivityCreateArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserActivities.
     * @param {UserActivityCreateManyArgs} args - Arguments to create many UserActivities.
     * @example
     * // Create many UserActivities
     * const userActivity = await prisma.userActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserActivityCreateManyArgs>(args?: SelectSubset<T, UserActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserActivity.
     * @param {UserActivityDeleteArgs} args - Arguments to delete one UserActivity.
     * @example
     * // Delete one UserActivity
     * const UserActivity = await prisma.userActivity.delete({
     *   where: {
     *     // ... filter to delete one UserActivity
     *   }
     * })
     * 
     */
    delete<T extends UserActivityDeleteArgs>(args: SelectSubset<T, UserActivityDeleteArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserActivity.
     * @param {UserActivityUpdateArgs} args - Arguments to update one UserActivity.
     * @example
     * // Update one UserActivity
     * const userActivity = await prisma.userActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserActivityUpdateArgs>(args: SelectSubset<T, UserActivityUpdateArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserActivities.
     * @param {UserActivityDeleteManyArgs} args - Arguments to filter UserActivities to delete.
     * @example
     * // Delete a few UserActivities
     * const { count } = await prisma.userActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserActivityDeleteManyArgs>(args?: SelectSubset<T, UserActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivities
     * const userActivity = await prisma.userActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserActivityUpdateManyArgs>(args: SelectSubset<T, UserActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserActivity.
     * @param {UserActivityUpsertArgs} args - Arguments to update or create a UserActivity.
     * @example
     * // Update or create a UserActivity
     * const userActivity = await prisma.userActivity.upsert({
     *   create: {
     *     // ... data to create a UserActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivity we want to update
     *   }
     * })
     */
    upsert<T extends UserActivityUpsertArgs>(args: SelectSubset<T, UserActivityUpsertArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityCountArgs} args - Arguments to filter UserActivities to count.
     * @example
     * // Count the number of UserActivities
     * const count = await prisma.userActivity.count({
     *   where: {
     *     // ... the filter for the UserActivities we want to count
     *   }
     * })
    **/
    count<T extends UserActivityCountArgs>(
      args?: Subset<T, UserActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivityAggregateArgs>(args: Subset<T, UserActivityAggregateArgs>): Prisma.PrismaPromise<GetUserActivityAggregateType<T>>

    /**
     * Group by UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActivityGroupByArgs['orderBy'] }
        : { orderBy?: UserActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserActivity model
   */
  readonly fields: UserActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserActivity model
   */
  interface UserActivityFieldRefs {
    readonly userId: FieldRef<"UserActivity", 'Int'>
    readonly ip: FieldRef<"UserActivity", 'String'>
    readonly lastActivityAt: FieldRef<"UserActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserActivity findUnique
   */
  export type UserActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity findUniqueOrThrow
   */
  export type UserActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity findFirst
   */
  export type UserActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity findFirstOrThrow
   */
  export type UserActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity findMany
   */
  export type UserActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivities to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity create
   */
  export type UserActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a UserActivity.
     */
    data: XOR<UserActivityCreateInput, UserActivityUncheckedCreateInput>
  }

  /**
   * UserActivity createMany
   */
  export type UserActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserActivities.
     */
    data: UserActivityCreateManyInput | UserActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserActivity update
   */
  export type UserActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a UserActivity.
     */
    data: XOR<UserActivityUpdateInput, UserActivityUncheckedUpdateInput>
    /**
     * Choose, which UserActivity to update.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity updateMany
   */
  export type UserActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserActivities.
     */
    data: XOR<UserActivityUpdateManyMutationInput, UserActivityUncheckedUpdateManyInput>
    /**
     * Filter which UserActivities to update
     */
    where?: UserActivityWhereInput
    /**
     * Limit how many UserActivities to update.
     */
    limit?: number
  }

  /**
   * UserActivity upsert
   */
  export type UserActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the UserActivity to update in case it exists.
     */
    where: UserActivityWhereUniqueInput
    /**
     * In case the UserActivity found by the `where` argument doesn't exist, create a new UserActivity with this data.
     */
    create: XOR<UserActivityCreateInput, UserActivityUncheckedCreateInput>
    /**
     * In case the UserActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserActivityUpdateInput, UserActivityUncheckedUpdateInput>
  }

  /**
   * UserActivity delete
   */
  export type UserActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter which UserActivity to delete.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity deleteMany
   */
  export type UserActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivities to delete
     */
    where?: UserActivityWhereInput
    /**
     * Limit how many UserActivities to delete.
     */
    limit?: number
  }

  /**
   * UserActivity without action
   */
  export type UserActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivity
     */
    omit?: UserActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
  }


  /**
   * Model UserBan
   */

  export type AggregateUserBan = {
    _count: UserBanCountAggregateOutputType | null
    _avg: UserBanAvgAggregateOutputType | null
    _sum: UserBanSumAggregateOutputType | null
    _min: UserBanMinAggregateOutputType | null
    _max: UserBanMaxAggregateOutputType | null
  }

  export type UserBanAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserBanSumAggregateOutputType = {
    userId: number | null
  }

  export type UserBanMinAggregateOutputType = {
    userId: number | null
    reason: string | null
    expiredAt: Date | null
  }

  export type UserBanMaxAggregateOutputType = {
    userId: number | null
    reason: string | null
    expiredAt: Date | null
  }

  export type UserBanCountAggregateOutputType = {
    userId: number
    reason: number
    expiredAt: number
    _all: number
  }


  export type UserBanAvgAggregateInputType = {
    userId?: true
  }

  export type UserBanSumAggregateInputType = {
    userId?: true
  }

  export type UserBanMinAggregateInputType = {
    userId?: true
    reason?: true
    expiredAt?: true
  }

  export type UserBanMaxAggregateInputType = {
    userId?: true
    reason?: true
    expiredAt?: true
  }

  export type UserBanCountAggregateInputType = {
    userId?: true
    reason?: true
    expiredAt?: true
    _all?: true
  }

  export type UserBanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBan to aggregate.
     */
    where?: UserBanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBans to fetch.
     */
    orderBy?: UserBanOrderByWithRelationInput | UserBanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBans
    **/
    _count?: true | UserBanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBanMaxAggregateInputType
  }

  export type GetUserBanAggregateType<T extends UserBanAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBan[P]>
      : GetScalarType<T[P], AggregateUserBan[P]>
  }




  export type UserBanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBanWhereInput
    orderBy?: UserBanOrderByWithAggregationInput | UserBanOrderByWithAggregationInput[]
    by: UserBanScalarFieldEnum[] | UserBanScalarFieldEnum
    having?: UserBanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBanCountAggregateInputType | true
    _avg?: UserBanAvgAggregateInputType
    _sum?: UserBanSumAggregateInputType
    _min?: UserBanMinAggregateInputType
    _max?: UserBanMaxAggregateInputType
  }

  export type UserBanGroupByOutputType = {
    userId: number
    reason: string
    expiredAt: Date
    _count: UserBanCountAggregateOutputType | null
    _avg: UserBanAvgAggregateOutputType | null
    _sum: UserBanSumAggregateOutputType | null
    _min: UserBanMinAggregateOutputType | null
    _max: UserBanMaxAggregateOutputType | null
  }

  type GetUserBanGroupByPayload<T extends UserBanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBanGroupByOutputType[P]>
            : GetScalarType<T[P], UserBanGroupByOutputType[P]>
        }
      >
    >


  export type UserBanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    reason?: boolean
    expiredAt?: boolean
  }, ExtArgs["result"]["userBan"]>



  export type UserBanSelectScalar = {
    userId?: boolean
    reason?: boolean
    expiredAt?: boolean
  }

  export type UserBanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "reason" | "expiredAt", ExtArgs["result"]["userBan"]>

  export type $UserBanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      reason: string
      expiredAt: Date
    }, ExtArgs["result"]["userBan"]>
    composites: {}
  }

  type UserBanGetPayload<S extends boolean | null | undefined | UserBanDefaultArgs> = $Result.GetResult<Prisma.$UserBanPayload, S>

  type UserBanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBanCountAggregateInputType | true
    }

  export interface UserBanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBan'], meta: { name: 'UserBan' } }
    /**
     * Find zero or one UserBan that matches the filter.
     * @param {UserBanFindUniqueArgs} args - Arguments to find a UserBan
     * @example
     * // Get one UserBan
     * const userBan = await prisma.userBan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBanFindUniqueArgs>(args: SelectSubset<T, UserBanFindUniqueArgs<ExtArgs>>): Prisma__UserBanClient<$Result.GetResult<Prisma.$UserBanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBanFindUniqueOrThrowArgs} args - Arguments to find a UserBan
     * @example
     * // Get one UserBan
     * const userBan = await prisma.userBan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBanFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBanClient<$Result.GetResult<Prisma.$UserBanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBanFindFirstArgs} args - Arguments to find a UserBan
     * @example
     * // Get one UserBan
     * const userBan = await prisma.userBan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBanFindFirstArgs>(args?: SelectSubset<T, UserBanFindFirstArgs<ExtArgs>>): Prisma__UserBanClient<$Result.GetResult<Prisma.$UserBanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBanFindFirstOrThrowArgs} args - Arguments to find a UserBan
     * @example
     * // Get one UserBan
     * const userBan = await prisma.userBan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBanFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBanFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBanClient<$Result.GetResult<Prisma.$UserBanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBans
     * const userBans = await prisma.userBan.findMany()
     * 
     * // Get first 10 UserBans
     * const userBans = await prisma.userBan.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userBanWithUserIdOnly = await prisma.userBan.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserBanFindManyArgs>(args?: SelectSubset<T, UserBanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBan.
     * @param {UserBanCreateArgs} args - Arguments to create a UserBan.
     * @example
     * // Create one UserBan
     * const UserBan = await prisma.userBan.create({
     *   data: {
     *     // ... data to create a UserBan
     *   }
     * })
     * 
     */
    create<T extends UserBanCreateArgs>(args: SelectSubset<T, UserBanCreateArgs<ExtArgs>>): Prisma__UserBanClient<$Result.GetResult<Prisma.$UserBanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBans.
     * @param {UserBanCreateManyArgs} args - Arguments to create many UserBans.
     * @example
     * // Create many UserBans
     * const userBan = await prisma.userBan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBanCreateManyArgs>(args?: SelectSubset<T, UserBanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserBan.
     * @param {UserBanDeleteArgs} args - Arguments to delete one UserBan.
     * @example
     * // Delete one UserBan
     * const UserBan = await prisma.userBan.delete({
     *   where: {
     *     // ... filter to delete one UserBan
     *   }
     * })
     * 
     */
    delete<T extends UserBanDeleteArgs>(args: SelectSubset<T, UserBanDeleteArgs<ExtArgs>>): Prisma__UserBanClient<$Result.GetResult<Prisma.$UserBanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBan.
     * @param {UserBanUpdateArgs} args - Arguments to update one UserBan.
     * @example
     * // Update one UserBan
     * const userBan = await prisma.userBan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBanUpdateArgs>(args: SelectSubset<T, UserBanUpdateArgs<ExtArgs>>): Prisma__UserBanClient<$Result.GetResult<Prisma.$UserBanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBans.
     * @param {UserBanDeleteManyArgs} args - Arguments to filter UserBans to delete.
     * @example
     * // Delete a few UserBans
     * const { count } = await prisma.userBan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBanDeleteManyArgs>(args?: SelectSubset<T, UserBanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBans
     * const userBan = await prisma.userBan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBanUpdateManyArgs>(args: SelectSubset<T, UserBanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBan.
     * @param {UserBanUpsertArgs} args - Arguments to update or create a UserBan.
     * @example
     * // Update or create a UserBan
     * const userBan = await prisma.userBan.upsert({
     *   create: {
     *     // ... data to create a UserBan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBan we want to update
     *   }
     * })
     */
    upsert<T extends UserBanUpsertArgs>(args: SelectSubset<T, UserBanUpsertArgs<ExtArgs>>): Prisma__UserBanClient<$Result.GetResult<Prisma.$UserBanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBanCountArgs} args - Arguments to filter UserBans to count.
     * @example
     * // Count the number of UserBans
     * const count = await prisma.userBan.count({
     *   where: {
     *     // ... the filter for the UserBans we want to count
     *   }
     * })
    **/
    count<T extends UserBanCountArgs>(
      args?: Subset<T, UserBanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBanAggregateArgs>(args: Subset<T, UserBanAggregateArgs>): Prisma.PrismaPromise<GetUserBanAggregateType<T>>

    /**
     * Group by UserBan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBanGroupByArgs['orderBy'] }
        : { orderBy?: UserBanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBan model
   */
  readonly fields: UserBanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBan model
   */
  interface UserBanFieldRefs {
    readonly userId: FieldRef<"UserBan", 'Int'>
    readonly reason: FieldRef<"UserBan", 'String'>
    readonly expiredAt: FieldRef<"UserBan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBan findUnique
   */
  export type UserBanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
    /**
     * Filter, which UserBan to fetch.
     */
    where: UserBanWhereUniqueInput
  }

  /**
   * UserBan findUniqueOrThrow
   */
  export type UserBanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
    /**
     * Filter, which UserBan to fetch.
     */
    where: UserBanWhereUniqueInput
  }

  /**
   * UserBan findFirst
   */
  export type UserBanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
    /**
     * Filter, which UserBan to fetch.
     */
    where?: UserBanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBans to fetch.
     */
    orderBy?: UserBanOrderByWithRelationInput | UserBanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBans.
     */
    cursor?: UserBanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBans.
     */
    distinct?: UserBanScalarFieldEnum | UserBanScalarFieldEnum[]
  }

  /**
   * UserBan findFirstOrThrow
   */
  export type UserBanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
    /**
     * Filter, which UserBan to fetch.
     */
    where?: UserBanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBans to fetch.
     */
    orderBy?: UserBanOrderByWithRelationInput | UserBanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBans.
     */
    cursor?: UserBanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBans.
     */
    distinct?: UserBanScalarFieldEnum | UserBanScalarFieldEnum[]
  }

  /**
   * UserBan findMany
   */
  export type UserBanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
    /**
     * Filter, which UserBans to fetch.
     */
    where?: UserBanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBans to fetch.
     */
    orderBy?: UserBanOrderByWithRelationInput | UserBanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBans.
     */
    cursor?: UserBanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBans.
     */
    skip?: number
    distinct?: UserBanScalarFieldEnum | UserBanScalarFieldEnum[]
  }

  /**
   * UserBan create
   */
  export type UserBanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
    /**
     * The data needed to create a UserBan.
     */
    data: XOR<UserBanCreateInput, UserBanUncheckedCreateInput>
  }

  /**
   * UserBan createMany
   */
  export type UserBanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBans.
     */
    data: UserBanCreateManyInput | UserBanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBan update
   */
  export type UserBanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
    /**
     * The data needed to update a UserBan.
     */
    data: XOR<UserBanUpdateInput, UserBanUncheckedUpdateInput>
    /**
     * Choose, which UserBan to update.
     */
    where: UserBanWhereUniqueInput
  }

  /**
   * UserBan updateMany
   */
  export type UserBanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBans.
     */
    data: XOR<UserBanUpdateManyMutationInput, UserBanUncheckedUpdateManyInput>
    /**
     * Filter which UserBans to update
     */
    where?: UserBanWhereInput
    /**
     * Limit how many UserBans to update.
     */
    limit?: number
  }

  /**
   * UserBan upsert
   */
  export type UserBanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
    /**
     * The filter to search for the UserBan to update in case it exists.
     */
    where: UserBanWhereUniqueInput
    /**
     * In case the UserBan found by the `where` argument doesn't exist, create a new UserBan with this data.
     */
    create: XOR<UserBanCreateInput, UserBanUncheckedCreateInput>
    /**
     * In case the UserBan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBanUpdateInput, UserBanUncheckedUpdateInput>
  }

  /**
   * UserBan delete
   */
  export type UserBanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
    /**
     * Filter which UserBan to delete.
     */
    where: UserBanWhereUniqueInput
  }

  /**
   * UserBan deleteMany
   */
  export type UserBanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBans to delete
     */
    where?: UserBanWhereInput
    /**
     * Limit how many UserBans to delete.
     */
    limit?: number
  }

  /**
   * UserBan without action
   */
  export type UserBanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBan
     */
    select?: UserBanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBan
     */
    omit?: UserBanOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Api_sourceScalarFieldEnum: {
    api_id: 'api_id',
    link: 'link',
    detailed_link: 'detailed_link',
    last_update: 'last_update',
    next_update: 'next_update',
    update_interval_ms: 'update_interval_ms',
    comments_link: 'comments_link'
  };

  export type Api_sourceScalarFieldEnum = (typeof Api_sourceScalarFieldEnum)[keyof typeof Api_sourceScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    comment_id: 'comment_id',
    description_id: 'description_id',
    comment_href: 'comment_href',
    author_name: 'author_name',
    user_id: 'user_id',
    rating: 'rating',
    comment_text: 'comment_text'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const ImagesScalarFieldEnum: {
    image_id: 'image_id',
    description_id: 'description_id',
    image_href: 'image_href'
  };

  export type ImagesScalarFieldEnum = (typeof ImagesScalarFieldEnum)[keyof typeof ImagesScalarFieldEnum]


  export const Station_connectorScalarFieldEnum: {
    connector_id: 'connector_id',
    description_id: 'description_id',
    connector_type_id: 'connector_type_id',
    connector_status_id: 'connector_status_id',
    connector_name: 'connector_name',
    power_kw: 'power_kw',
    current_amp: 'current_amp',
    price_per_start: 'price_per_start',
    price: 'price',
    currency: 'currency',
    free_min_after_charging: 'free_min_after_charging',
    price_per_min_after_charging: 'price_per_min_after_charging'
  };

  export type Station_connectorScalarFieldEnum = (typeof Station_connectorScalarFieldEnum)[keyof typeof Station_connectorScalarFieldEnum]


  export const Station_desc_apiScalarFieldEnum: {
    id: 'id',
    api_id: 'api_id',
    og_api_pk: 'og_api_pk',
    description_id: 'description_id'
  };

  export type Station_desc_apiScalarFieldEnum = (typeof Station_desc_apiScalarFieldEnum)[keyof typeof Station_desc_apiScalarFieldEnum]


  export const Station_descriptionScalarFieldEnum: {
    description_id: 'description_id',
    station_id: 'station_id',
    station_name: 'station_name',
    description_string: 'description_string',
    location_type: 'location_type',
    country_code: 'country_code',
    support_phone: 'support_phone',
    is_support_charging: 'is_support_charging',
    is_support_reservation: 'is_support_reservation',
    location_name: 'location_name',
    last_charging: 'last_charging',
    is_public: 'is_public',
    is_fast_charger: 'is_fast_charger',
    is_open_24x7: 'is_open_24x7',
    min_power_kw: 'min_power_kw',
    max_power_kw: 'max_power_kw',
    last_status_update: 'last_status_update',
    network_id: 'network_id',
    status_id: 'status_id',
    station_flags: 'station_flags'
  };

  export type Station_descriptionScalarFieldEnum = (typeof Station_descriptionScalarFieldEnum)[keyof typeof Station_descriptionScalarFieldEnum]


  export const Station_markerScalarFieldEnum: {
    station_id: 'station_id',
    longitude: 'longitude',
    latitude: 'latitude'
  };

  export type Station_markerScalarFieldEnum = (typeof Station_markerScalarFieldEnum)[keyof typeof Station_markerScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    roleId: 'roleId',
    isBanned: 'isBanned',
    emailVerificationKey: 'emailVerificationKey',
    emailVerifiedAt: 'emailVerifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SavedStationsScalarFieldEnum: {
    userId: 'userId',
    markerId: 'markerId'
  };

  export type SavedStationsScalarFieldEnum = (typeof SavedStationsScalarFieldEnum)[keyof typeof SavedStationsScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    resource: 'resource',
    action: 'action'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const RecoveryTokenScalarFieldEnum: {
    userId: 'userId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt'
  };

  export type RecoveryTokenScalarFieldEnum = (typeof RecoveryTokenScalarFieldEnum)[keyof typeof RecoveryTokenScalarFieldEnum]


  export const UserPermissionsScalarFieldEnum: {
    userId: 'userId',
    rolePermissionId: 'rolePermissionId'
  };

  export type UserPermissionsScalarFieldEnum = (typeof UserPermissionsScalarFieldEnum)[keyof typeof UserPermissionsScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    ip: 'ip',
    userAgent: 'userAgent',
    refreshToken: 'refreshToken',
    userId: 'userId',
    lastRefreshAt: 'lastRefreshAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const UserActivityScalarFieldEnum: {
    userId: 'userId',
    ip: 'ip',
    lastActivityAt: 'lastActivityAt'
  };

  export type UserActivityScalarFieldEnum = (typeof UserActivityScalarFieldEnum)[keyof typeof UserActivityScalarFieldEnum]


  export const UserBanScalarFieldEnum: {
    userId: 'userId',
    reason: 'reason',
    expiredAt: 'expiredAt'
  };

  export type UserBanScalarFieldEnum = (typeof UserBanScalarFieldEnum)[keyof typeof UserBanScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const api_sourceOrderByRelevanceFieldEnum: {
    link: 'link',
    detailed_link: 'detailed_link',
    comments_link: 'comments_link'
  };

  export type api_sourceOrderByRelevanceFieldEnum = (typeof api_sourceOrderByRelevanceFieldEnum)[keyof typeof api_sourceOrderByRelevanceFieldEnum]


  export const commentsOrderByRelevanceFieldEnum: {
    comment_href: 'comment_href',
    author_name: 'author_name',
    comment_text: 'comment_text'
  };

  export type commentsOrderByRelevanceFieldEnum = (typeof commentsOrderByRelevanceFieldEnum)[keyof typeof commentsOrderByRelevanceFieldEnum]


  export const imagesOrderByRelevanceFieldEnum: {
    image_href: 'image_href'
  };

  export type imagesOrderByRelevanceFieldEnum = (typeof imagesOrderByRelevanceFieldEnum)[keyof typeof imagesOrderByRelevanceFieldEnum]


  export const station_connectorOrderByRelevanceFieldEnum: {
    connector_name: 'connector_name',
    currency: 'currency'
  };

  export type station_connectorOrderByRelevanceFieldEnum = (typeof station_connectorOrderByRelevanceFieldEnum)[keyof typeof station_connectorOrderByRelevanceFieldEnum]


  export const station_descriptionOrderByRelevanceFieldEnum: {
    station_name: 'station_name',
    description_string: 'description_string',
    location_type: 'location_type',
    country_code: 'country_code',
    support_phone: 'support_phone',
    location_name: 'location_name'
  };

  export type station_descriptionOrderByRelevanceFieldEnum = (typeof station_descriptionOrderByRelevanceFieldEnum)[keyof typeof station_descriptionOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    emailVerificationKey: 'emailVerificationKey'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RoleOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  export const PermissionOrderByRelevanceFieldEnum: {
    resource: 'resource',
    action: 'action'
  };

  export type PermissionOrderByRelevanceFieldEnum = (typeof PermissionOrderByRelevanceFieldEnum)[keyof typeof PermissionOrderByRelevanceFieldEnum]


  export const RecoveryTokenOrderByRelevanceFieldEnum: {
    tokenHash: 'tokenHash'
  };

  export type RecoveryTokenOrderByRelevanceFieldEnum = (typeof RecoveryTokenOrderByRelevanceFieldEnum)[keyof typeof RecoveryTokenOrderByRelevanceFieldEnum]


  export const UserSessionOrderByRelevanceFieldEnum: {
    id: 'id',
    ip: 'ip',
    userAgent: 'userAgent',
    refreshToken: 'refreshToken'
  };

  export type UserSessionOrderByRelevanceFieldEnum = (typeof UserSessionOrderByRelevanceFieldEnum)[keyof typeof UserSessionOrderByRelevanceFieldEnum]


  export const UserActivityOrderByRelevanceFieldEnum: {
    ip: 'ip'
  };

  export type UserActivityOrderByRelevanceFieldEnum = (typeof UserActivityOrderByRelevanceFieldEnum)[keyof typeof UserActivityOrderByRelevanceFieldEnum]


  export const UserBanOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type UserBanOrderByRelevanceFieldEnum = (typeof UserBanOrderByRelevanceFieldEnum)[keyof typeof UserBanOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    
  /**
   * Deep Input Types
   */


  export type api_sourceWhereInput = {
    AND?: api_sourceWhereInput | api_sourceWhereInput[]
    OR?: api_sourceWhereInput[]
    NOT?: api_sourceWhereInput | api_sourceWhereInput[]
    api_id?: IntFilter<"api_source"> | number
    link?: StringFilter<"api_source"> | string
    detailed_link?: StringFilter<"api_source"> | string
    last_update?: BigIntNullableFilter<"api_source"> | bigint | number | null
    next_update?: BigIntNullableFilter<"api_source"> | bigint | number | null
    update_interval_ms?: BigIntNullableFilter<"api_source"> | bigint | number | null
    comments_link?: StringNullableFilter<"api_source"> | string | null
    station_desc_api?: Station_desc_apiListRelationFilter
  }

  export type api_sourceOrderByWithRelationInput = {
    api_id?: SortOrder
    link?: SortOrder
    detailed_link?: SortOrder
    last_update?: SortOrderInput | SortOrder
    next_update?: SortOrderInput | SortOrder
    update_interval_ms?: SortOrderInput | SortOrder
    comments_link?: SortOrderInput | SortOrder
    station_desc_api?: station_desc_apiOrderByRelationAggregateInput
    _relevance?: api_sourceOrderByRelevanceInput
  }

  export type api_sourceWhereUniqueInput = Prisma.AtLeast<{
    api_id?: number
    link?: string
    AND?: api_sourceWhereInput | api_sourceWhereInput[]
    OR?: api_sourceWhereInput[]
    NOT?: api_sourceWhereInput | api_sourceWhereInput[]
    detailed_link?: StringFilter<"api_source"> | string
    last_update?: BigIntNullableFilter<"api_source"> | bigint | number | null
    next_update?: BigIntNullableFilter<"api_source"> | bigint | number | null
    update_interval_ms?: BigIntNullableFilter<"api_source"> | bigint | number | null
    comments_link?: StringNullableFilter<"api_source"> | string | null
    station_desc_api?: Station_desc_apiListRelationFilter
  }, "api_id" | "link">

  export type api_sourceOrderByWithAggregationInput = {
    api_id?: SortOrder
    link?: SortOrder
    detailed_link?: SortOrder
    last_update?: SortOrderInput | SortOrder
    next_update?: SortOrderInput | SortOrder
    update_interval_ms?: SortOrderInput | SortOrder
    comments_link?: SortOrderInput | SortOrder
    _count?: api_sourceCountOrderByAggregateInput
    _avg?: api_sourceAvgOrderByAggregateInput
    _max?: api_sourceMaxOrderByAggregateInput
    _min?: api_sourceMinOrderByAggregateInput
    _sum?: api_sourceSumOrderByAggregateInput
  }

  export type api_sourceScalarWhereWithAggregatesInput = {
    AND?: api_sourceScalarWhereWithAggregatesInput | api_sourceScalarWhereWithAggregatesInput[]
    OR?: api_sourceScalarWhereWithAggregatesInput[]
    NOT?: api_sourceScalarWhereWithAggregatesInput | api_sourceScalarWhereWithAggregatesInput[]
    api_id?: IntWithAggregatesFilter<"api_source"> | number
    link?: StringWithAggregatesFilter<"api_source"> | string
    detailed_link?: StringWithAggregatesFilter<"api_source"> | string
    last_update?: BigIntNullableWithAggregatesFilter<"api_source"> | bigint | number | null
    next_update?: BigIntNullableWithAggregatesFilter<"api_source"> | bigint | number | null
    update_interval_ms?: BigIntNullableWithAggregatesFilter<"api_source"> | bigint | number | null
    comments_link?: StringNullableWithAggregatesFilter<"api_source"> | string | null
  }

  export type commentsWhereInput = {
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    comment_id?: IntFilter<"comments"> | number
    description_id?: IntNullableFilter<"comments"> | number | null
    comment_href?: StringNullableFilter<"comments"> | string | null
    author_name?: StringNullableFilter<"comments"> | string | null
    user_id?: IntNullableFilter<"comments"> | number | null
    rating?: FloatNullableFilter<"comments"> | number | null
    comment_text?: StringNullableFilter<"comments"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    station_description?: XOR<Station_descriptionNullableScalarRelationFilter, station_descriptionWhereInput> | null
  }

  export type commentsOrderByWithRelationInput = {
    comment_id?: SortOrder
    description_id?: SortOrderInput | SortOrder
    comment_href?: SortOrderInput | SortOrder
    author_name?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    comment_text?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    station_description?: station_descriptionOrderByWithRelationInput
    _relevance?: commentsOrderByRelevanceInput
  }

  export type commentsWhereUniqueInput = Prisma.AtLeast<{
    comment_id?: number
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    description_id?: IntNullableFilter<"comments"> | number | null
    comment_href?: StringNullableFilter<"comments"> | string | null
    author_name?: StringNullableFilter<"comments"> | string | null
    user_id?: IntNullableFilter<"comments"> | number | null
    rating?: FloatNullableFilter<"comments"> | number | null
    comment_text?: StringNullableFilter<"comments"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    station_description?: XOR<Station_descriptionNullableScalarRelationFilter, station_descriptionWhereInput> | null
  }, "comment_id">

  export type commentsOrderByWithAggregationInput = {
    comment_id?: SortOrder
    description_id?: SortOrderInput | SortOrder
    comment_href?: SortOrderInput | SortOrder
    author_name?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    comment_text?: SortOrderInput | SortOrder
    _count?: commentsCountOrderByAggregateInput
    _avg?: commentsAvgOrderByAggregateInput
    _max?: commentsMaxOrderByAggregateInput
    _min?: commentsMinOrderByAggregateInput
    _sum?: commentsSumOrderByAggregateInput
  }

  export type commentsScalarWhereWithAggregatesInput = {
    AND?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    OR?: commentsScalarWhereWithAggregatesInput[]
    NOT?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    comment_id?: IntWithAggregatesFilter<"comments"> | number
    description_id?: IntNullableWithAggregatesFilter<"comments"> | number | null
    comment_href?: StringNullableWithAggregatesFilter<"comments"> | string | null
    author_name?: StringNullableWithAggregatesFilter<"comments"> | string | null
    user_id?: IntNullableWithAggregatesFilter<"comments"> | number | null
    rating?: FloatNullableWithAggregatesFilter<"comments"> | number | null
    comment_text?: StringNullableWithAggregatesFilter<"comments"> | string | null
  }

  export type imagesWhereInput = {
    AND?: imagesWhereInput | imagesWhereInput[]
    OR?: imagesWhereInput[]
    NOT?: imagesWhereInput | imagesWhereInput[]
    image_id?: IntFilter<"images"> | number
    description_id?: IntNullableFilter<"images"> | number | null
    image_href?: StringNullableFilter<"images"> | string | null
    station_description?: XOR<Station_descriptionNullableScalarRelationFilter, station_descriptionWhereInput> | null
  }

  export type imagesOrderByWithRelationInput = {
    image_id?: SortOrder
    description_id?: SortOrderInput | SortOrder
    image_href?: SortOrderInput | SortOrder
    station_description?: station_descriptionOrderByWithRelationInput
    _relevance?: imagesOrderByRelevanceInput
  }

  export type imagesWhereUniqueInput = Prisma.AtLeast<{
    image_id?: number
    AND?: imagesWhereInput | imagesWhereInput[]
    OR?: imagesWhereInput[]
    NOT?: imagesWhereInput | imagesWhereInput[]
    description_id?: IntNullableFilter<"images"> | number | null
    image_href?: StringNullableFilter<"images"> | string | null
    station_description?: XOR<Station_descriptionNullableScalarRelationFilter, station_descriptionWhereInput> | null
  }, "image_id">

  export type imagesOrderByWithAggregationInput = {
    image_id?: SortOrder
    description_id?: SortOrderInput | SortOrder
    image_href?: SortOrderInput | SortOrder
    _count?: imagesCountOrderByAggregateInput
    _avg?: imagesAvgOrderByAggregateInput
    _max?: imagesMaxOrderByAggregateInput
    _min?: imagesMinOrderByAggregateInput
    _sum?: imagesSumOrderByAggregateInput
  }

  export type imagesScalarWhereWithAggregatesInput = {
    AND?: imagesScalarWhereWithAggregatesInput | imagesScalarWhereWithAggregatesInput[]
    OR?: imagesScalarWhereWithAggregatesInput[]
    NOT?: imagesScalarWhereWithAggregatesInput | imagesScalarWhereWithAggregatesInput[]
    image_id?: IntWithAggregatesFilter<"images"> | number
    description_id?: IntNullableWithAggregatesFilter<"images"> | number | null
    image_href?: StringNullableWithAggregatesFilter<"images"> | string | null
  }

  export type station_connectorWhereInput = {
    AND?: station_connectorWhereInput | station_connectorWhereInput[]
    OR?: station_connectorWhereInput[]
    NOT?: station_connectorWhereInput | station_connectorWhereInput[]
    connector_id?: IntFilter<"station_connector"> | number
    description_id?: IntNullableFilter<"station_connector"> | number | null
    connector_type_id?: IntNullableFilter<"station_connector"> | number | null
    connector_status_id?: IntNullableFilter<"station_connector"> | number | null
    connector_name?: StringNullableFilter<"station_connector"> | string | null
    power_kw?: IntNullableFilter<"station_connector"> | number | null
    current_amp?: IntNullableFilter<"station_connector"> | number | null
    price_per_start?: DecimalNullableFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    price?: DecimalNullableFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"station_connector"> | string | null
    free_min_after_charging?: IntNullableFilter<"station_connector"> | number | null
    price_per_min_after_charging?: DecimalNullableFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    station_description?: XOR<Station_descriptionNullableScalarRelationFilter, station_descriptionWhereInput> | null
  }

  export type station_connectorOrderByWithRelationInput = {
    connector_id?: SortOrder
    description_id?: SortOrderInput | SortOrder
    connector_type_id?: SortOrderInput | SortOrder
    connector_status_id?: SortOrderInput | SortOrder
    connector_name?: SortOrderInput | SortOrder
    power_kw?: SortOrderInput | SortOrder
    current_amp?: SortOrderInput | SortOrder
    price_per_start?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    free_min_after_charging?: SortOrderInput | SortOrder
    price_per_min_after_charging?: SortOrderInput | SortOrder
    station_description?: station_descriptionOrderByWithRelationInput
    _relevance?: station_connectorOrderByRelevanceInput
  }

  export type station_connectorWhereUniqueInput = Prisma.AtLeast<{
    connector_id?: number
    AND?: station_connectorWhereInput | station_connectorWhereInput[]
    OR?: station_connectorWhereInput[]
    NOT?: station_connectorWhereInput | station_connectorWhereInput[]
    description_id?: IntNullableFilter<"station_connector"> | number | null
    connector_type_id?: IntNullableFilter<"station_connector"> | number | null
    connector_status_id?: IntNullableFilter<"station_connector"> | number | null
    connector_name?: StringNullableFilter<"station_connector"> | string | null
    power_kw?: IntNullableFilter<"station_connector"> | number | null
    current_amp?: IntNullableFilter<"station_connector"> | number | null
    price_per_start?: DecimalNullableFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    price?: DecimalNullableFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"station_connector"> | string | null
    free_min_after_charging?: IntNullableFilter<"station_connector"> | number | null
    price_per_min_after_charging?: DecimalNullableFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    station_description?: XOR<Station_descriptionNullableScalarRelationFilter, station_descriptionWhereInput> | null
  }, "connector_id">

  export type station_connectorOrderByWithAggregationInput = {
    connector_id?: SortOrder
    description_id?: SortOrderInput | SortOrder
    connector_type_id?: SortOrderInput | SortOrder
    connector_status_id?: SortOrderInput | SortOrder
    connector_name?: SortOrderInput | SortOrder
    power_kw?: SortOrderInput | SortOrder
    current_amp?: SortOrderInput | SortOrder
    price_per_start?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    free_min_after_charging?: SortOrderInput | SortOrder
    price_per_min_after_charging?: SortOrderInput | SortOrder
    _count?: station_connectorCountOrderByAggregateInput
    _avg?: station_connectorAvgOrderByAggregateInput
    _max?: station_connectorMaxOrderByAggregateInput
    _min?: station_connectorMinOrderByAggregateInput
    _sum?: station_connectorSumOrderByAggregateInput
  }

  export type station_connectorScalarWhereWithAggregatesInput = {
    AND?: station_connectorScalarWhereWithAggregatesInput | station_connectorScalarWhereWithAggregatesInput[]
    OR?: station_connectorScalarWhereWithAggregatesInput[]
    NOT?: station_connectorScalarWhereWithAggregatesInput | station_connectorScalarWhereWithAggregatesInput[]
    connector_id?: IntWithAggregatesFilter<"station_connector"> | number
    description_id?: IntNullableWithAggregatesFilter<"station_connector"> | number | null
    connector_type_id?: IntNullableWithAggregatesFilter<"station_connector"> | number | null
    connector_status_id?: IntNullableWithAggregatesFilter<"station_connector"> | number | null
    connector_name?: StringNullableWithAggregatesFilter<"station_connector"> | string | null
    power_kw?: IntNullableWithAggregatesFilter<"station_connector"> | number | null
    current_amp?: IntNullableWithAggregatesFilter<"station_connector"> | number | null
    price_per_start?: DecimalNullableWithAggregatesFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    price?: DecimalNullableWithAggregatesFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"station_connector"> | string | null
    free_min_after_charging?: IntNullableWithAggregatesFilter<"station_connector"> | number | null
    price_per_min_after_charging?: DecimalNullableWithAggregatesFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
  }

  export type station_desc_apiWhereInput = {
    AND?: station_desc_apiWhereInput | station_desc_apiWhereInput[]
    OR?: station_desc_apiWhereInput[]
    NOT?: station_desc_apiWhereInput | station_desc_apiWhereInput[]
    id?: IntFilter<"station_desc_api"> | number
    api_id?: IntNullableFilter<"station_desc_api"> | number | null
    og_api_pk?: IntNullableFilter<"station_desc_api"> | number | null
    description_id?: IntNullableFilter<"station_desc_api"> | number | null
    api_source?: XOR<Api_sourceNullableScalarRelationFilter, api_sourceWhereInput> | null
    station_description?: XOR<Station_descriptionNullableScalarRelationFilter, station_descriptionWhereInput> | null
  }

  export type station_desc_apiOrderByWithRelationInput = {
    id?: SortOrder
    api_id?: SortOrderInput | SortOrder
    og_api_pk?: SortOrderInput | SortOrder
    description_id?: SortOrderInput | SortOrder
    api_source?: api_sourceOrderByWithRelationInput
    station_description?: station_descriptionOrderByWithRelationInput
  }

  export type station_desc_apiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: station_desc_apiWhereInput | station_desc_apiWhereInput[]
    OR?: station_desc_apiWhereInput[]
    NOT?: station_desc_apiWhereInput | station_desc_apiWhereInput[]
    api_id?: IntNullableFilter<"station_desc_api"> | number | null
    og_api_pk?: IntNullableFilter<"station_desc_api"> | number | null
    description_id?: IntNullableFilter<"station_desc_api"> | number | null
    api_source?: XOR<Api_sourceNullableScalarRelationFilter, api_sourceWhereInput> | null
    station_description?: XOR<Station_descriptionNullableScalarRelationFilter, station_descriptionWhereInput> | null
  }, "id">

  export type station_desc_apiOrderByWithAggregationInput = {
    id?: SortOrder
    api_id?: SortOrderInput | SortOrder
    og_api_pk?: SortOrderInput | SortOrder
    description_id?: SortOrderInput | SortOrder
    _count?: station_desc_apiCountOrderByAggregateInput
    _avg?: station_desc_apiAvgOrderByAggregateInput
    _max?: station_desc_apiMaxOrderByAggregateInput
    _min?: station_desc_apiMinOrderByAggregateInput
    _sum?: station_desc_apiSumOrderByAggregateInput
  }

  export type station_desc_apiScalarWhereWithAggregatesInput = {
    AND?: station_desc_apiScalarWhereWithAggregatesInput | station_desc_apiScalarWhereWithAggregatesInput[]
    OR?: station_desc_apiScalarWhereWithAggregatesInput[]
    NOT?: station_desc_apiScalarWhereWithAggregatesInput | station_desc_apiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"station_desc_api"> | number
    api_id?: IntNullableWithAggregatesFilter<"station_desc_api"> | number | null
    og_api_pk?: IntNullableWithAggregatesFilter<"station_desc_api"> | number | null
    description_id?: IntNullableWithAggregatesFilter<"station_desc_api"> | number | null
  }

  export type station_descriptionWhereInput = {
    AND?: station_descriptionWhereInput | station_descriptionWhereInput[]
    OR?: station_descriptionWhereInput[]
    NOT?: station_descriptionWhereInput | station_descriptionWhereInput[]
    description_id?: IntFilter<"station_description"> | number
    station_id?: IntNullableFilter<"station_description"> | number | null
    station_name?: StringNullableFilter<"station_description"> | string | null
    description_string?: StringNullableFilter<"station_description"> | string | null
    location_type?: StringNullableFilter<"station_description"> | string | null
    country_code?: StringNullableFilter<"station_description"> | string | null
    support_phone?: StringNullableFilter<"station_description"> | string | null
    is_support_charging?: BoolNullableFilter<"station_description"> | boolean | null
    is_support_reservation?: BoolNullableFilter<"station_description"> | boolean | null
    location_name?: StringNullableFilter<"station_description"> | string | null
    last_charging?: BigIntNullableFilter<"station_description"> | bigint | number | null
    is_public?: BoolNullableFilter<"station_description"> | boolean | null
    is_fast_charger?: BoolNullableFilter<"station_description"> | boolean | null
    is_open_24x7?: BoolNullableFilter<"station_description"> | boolean | null
    min_power_kw?: IntNullableFilter<"station_description"> | number | null
    max_power_kw?: IntNullableFilter<"station_description"> | number | null
    last_status_update?: BigIntNullableFilter<"station_description"> | bigint | number | null
    network_id?: IntNullableFilter<"station_description"> | number | null
    status_id?: IntNullableFilter<"station_description"> | number | null
    station_flags?: BytesNullableFilter<"station_description"> | Uint8Array | null
    comments?: CommentsListRelationFilter
    images?: ImagesListRelationFilter
    station_connector?: Station_connectorListRelationFilter
    station_desc_api?: Station_desc_apiListRelationFilter
    station_marker?: XOR<Station_markerNullableScalarRelationFilter, station_markerWhereInput> | null
  }

  export type station_descriptionOrderByWithRelationInput = {
    description_id?: SortOrder
    station_id?: SortOrderInput | SortOrder
    station_name?: SortOrderInput | SortOrder
    description_string?: SortOrderInput | SortOrder
    location_type?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    support_phone?: SortOrderInput | SortOrder
    is_support_charging?: SortOrderInput | SortOrder
    is_support_reservation?: SortOrderInput | SortOrder
    location_name?: SortOrderInput | SortOrder
    last_charging?: SortOrderInput | SortOrder
    is_public?: SortOrderInput | SortOrder
    is_fast_charger?: SortOrderInput | SortOrder
    is_open_24x7?: SortOrderInput | SortOrder
    min_power_kw?: SortOrderInput | SortOrder
    max_power_kw?: SortOrderInput | SortOrder
    last_status_update?: SortOrderInput | SortOrder
    network_id?: SortOrderInput | SortOrder
    status_id?: SortOrderInput | SortOrder
    station_flags?: SortOrderInput | SortOrder
    comments?: commentsOrderByRelationAggregateInput
    images?: imagesOrderByRelationAggregateInput
    station_connector?: station_connectorOrderByRelationAggregateInput
    station_desc_api?: station_desc_apiOrderByRelationAggregateInput
    station_marker?: station_markerOrderByWithRelationInput
    _relevance?: station_descriptionOrderByRelevanceInput
  }

  export type station_descriptionWhereUniqueInput = Prisma.AtLeast<{
    description_id?: number
    AND?: station_descriptionWhereInput | station_descriptionWhereInput[]
    OR?: station_descriptionWhereInput[]
    NOT?: station_descriptionWhereInput | station_descriptionWhereInput[]
    station_id?: IntNullableFilter<"station_description"> | number | null
    station_name?: StringNullableFilter<"station_description"> | string | null
    description_string?: StringNullableFilter<"station_description"> | string | null
    location_type?: StringNullableFilter<"station_description"> | string | null
    country_code?: StringNullableFilter<"station_description"> | string | null
    support_phone?: StringNullableFilter<"station_description"> | string | null
    is_support_charging?: BoolNullableFilter<"station_description"> | boolean | null
    is_support_reservation?: BoolNullableFilter<"station_description"> | boolean | null
    location_name?: StringNullableFilter<"station_description"> | string | null
    last_charging?: BigIntNullableFilter<"station_description"> | bigint | number | null
    is_public?: BoolNullableFilter<"station_description"> | boolean | null
    is_fast_charger?: BoolNullableFilter<"station_description"> | boolean | null
    is_open_24x7?: BoolNullableFilter<"station_description"> | boolean | null
    min_power_kw?: IntNullableFilter<"station_description"> | number | null
    max_power_kw?: IntNullableFilter<"station_description"> | number | null
    last_status_update?: BigIntNullableFilter<"station_description"> | bigint | number | null
    network_id?: IntNullableFilter<"station_description"> | number | null
    status_id?: IntNullableFilter<"station_description"> | number | null
    station_flags?: BytesNullableFilter<"station_description"> | Uint8Array | null
    comments?: CommentsListRelationFilter
    images?: ImagesListRelationFilter
    station_connector?: Station_connectorListRelationFilter
    station_desc_api?: Station_desc_apiListRelationFilter
    station_marker?: XOR<Station_markerNullableScalarRelationFilter, station_markerWhereInput> | null
  }, "description_id">

  export type station_descriptionOrderByWithAggregationInput = {
    description_id?: SortOrder
    station_id?: SortOrderInput | SortOrder
    station_name?: SortOrderInput | SortOrder
    description_string?: SortOrderInput | SortOrder
    location_type?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    support_phone?: SortOrderInput | SortOrder
    is_support_charging?: SortOrderInput | SortOrder
    is_support_reservation?: SortOrderInput | SortOrder
    location_name?: SortOrderInput | SortOrder
    last_charging?: SortOrderInput | SortOrder
    is_public?: SortOrderInput | SortOrder
    is_fast_charger?: SortOrderInput | SortOrder
    is_open_24x7?: SortOrderInput | SortOrder
    min_power_kw?: SortOrderInput | SortOrder
    max_power_kw?: SortOrderInput | SortOrder
    last_status_update?: SortOrderInput | SortOrder
    network_id?: SortOrderInput | SortOrder
    status_id?: SortOrderInput | SortOrder
    station_flags?: SortOrderInput | SortOrder
    _count?: station_descriptionCountOrderByAggregateInput
    _avg?: station_descriptionAvgOrderByAggregateInput
    _max?: station_descriptionMaxOrderByAggregateInput
    _min?: station_descriptionMinOrderByAggregateInput
    _sum?: station_descriptionSumOrderByAggregateInput
  }

  export type station_descriptionScalarWhereWithAggregatesInput = {
    AND?: station_descriptionScalarWhereWithAggregatesInput | station_descriptionScalarWhereWithAggregatesInput[]
    OR?: station_descriptionScalarWhereWithAggregatesInput[]
    NOT?: station_descriptionScalarWhereWithAggregatesInput | station_descriptionScalarWhereWithAggregatesInput[]
    description_id?: IntWithAggregatesFilter<"station_description"> | number
    station_id?: IntNullableWithAggregatesFilter<"station_description"> | number | null
    station_name?: StringNullableWithAggregatesFilter<"station_description"> | string | null
    description_string?: StringNullableWithAggregatesFilter<"station_description"> | string | null
    location_type?: StringNullableWithAggregatesFilter<"station_description"> | string | null
    country_code?: StringNullableWithAggregatesFilter<"station_description"> | string | null
    support_phone?: StringNullableWithAggregatesFilter<"station_description"> | string | null
    is_support_charging?: BoolNullableWithAggregatesFilter<"station_description"> | boolean | null
    is_support_reservation?: BoolNullableWithAggregatesFilter<"station_description"> | boolean | null
    location_name?: StringNullableWithAggregatesFilter<"station_description"> | string | null
    last_charging?: BigIntNullableWithAggregatesFilter<"station_description"> | bigint | number | null
    is_public?: BoolNullableWithAggregatesFilter<"station_description"> | boolean | null
    is_fast_charger?: BoolNullableWithAggregatesFilter<"station_description"> | boolean | null
    is_open_24x7?: BoolNullableWithAggregatesFilter<"station_description"> | boolean | null
    min_power_kw?: IntNullableWithAggregatesFilter<"station_description"> | number | null
    max_power_kw?: IntNullableWithAggregatesFilter<"station_description"> | number | null
    last_status_update?: BigIntNullableWithAggregatesFilter<"station_description"> | bigint | number | null
    network_id?: IntNullableWithAggregatesFilter<"station_description"> | number | null
    status_id?: IntNullableWithAggregatesFilter<"station_description"> | number | null
    station_flags?: BytesNullableWithAggregatesFilter<"station_description"> | Uint8Array | null
  }

  export type station_markerWhereInput = {
    AND?: station_markerWhereInput | station_markerWhereInput[]
    OR?: station_markerWhereInput[]
    NOT?: station_markerWhereInput | station_markerWhereInput[]
    station_id?: IntFilter<"station_marker"> | number
    longitude?: DecimalFilter<"station_marker"> | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFilter<"station_marker"> | Decimal | DecimalJsLike | number | string
    station_description?: Station_descriptionListRelationFilter
    savedStations?: SavedStationsListRelationFilter
  }

  export type station_markerOrderByWithRelationInput = {
    station_id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    station_description?: station_descriptionOrderByRelationAggregateInput
    savedStations?: SavedStationsOrderByRelationAggregateInput
  }

  export type station_markerWhereUniqueInput = Prisma.AtLeast<{
    station_id?: number
    AND?: station_markerWhereInput | station_markerWhereInput[]
    OR?: station_markerWhereInput[]
    NOT?: station_markerWhereInput | station_markerWhereInput[]
    longitude?: DecimalFilter<"station_marker"> | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFilter<"station_marker"> | Decimal | DecimalJsLike | number | string
    station_description?: Station_descriptionListRelationFilter
    savedStations?: SavedStationsListRelationFilter
  }, "station_id">

  export type station_markerOrderByWithAggregationInput = {
    station_id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    _count?: station_markerCountOrderByAggregateInput
    _avg?: station_markerAvgOrderByAggregateInput
    _max?: station_markerMaxOrderByAggregateInput
    _min?: station_markerMinOrderByAggregateInput
    _sum?: station_markerSumOrderByAggregateInput
  }

  export type station_markerScalarWhereWithAggregatesInput = {
    AND?: station_markerScalarWhereWithAggregatesInput | station_markerScalarWhereWithAggregatesInput[]
    OR?: station_markerScalarWhereWithAggregatesInput[]
    NOT?: station_markerScalarWhereWithAggregatesInput | station_markerScalarWhereWithAggregatesInput[]
    station_id?: IntWithAggregatesFilter<"station_marker"> | number
    longitude?: DecimalWithAggregatesFilter<"station_marker"> | Decimal | DecimalJsLike | number | string
    latitude?: DecimalWithAggregatesFilter<"station_marker"> | Decimal | DecimalJsLike | number | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    roleId?: IntFilter<"User"> | number
    isBanned?: BoolFilter<"User"> | boolean
    emailVerificationKey?: StringNullableFilter<"User"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permissions?: UserPermissionsListRelationFilter
    activities?: UserActivityListRelationFilter
    RecoveryToken?: RecoveryTokenListRelationFilter
    comments?: CommentsListRelationFilter
    savedStations?: SavedStationsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    roleId?: SortOrder
    isBanned?: SortOrder
    emailVerificationKey?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permissions?: UserPermissionsOrderByRelationAggregateInput
    activities?: UserActivityOrderByRelationAggregateInput
    RecoveryToken?: RecoveryTokenOrderByRelationAggregateInput
    comments?: commentsOrderByRelationAggregateInput
    savedStations?: SavedStationsOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    emailVerificationKey?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    roleId?: IntFilter<"User"> | number
    isBanned?: BoolFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permissions?: UserPermissionsListRelationFilter
    activities?: UserActivityListRelationFilter
    RecoveryToken?: RecoveryTokenListRelationFilter
    comments?: CommentsListRelationFilter
    savedStations?: SavedStationsListRelationFilter
  }, "id" | "email" | "emailVerificationKey">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    roleId?: SortOrder
    isBanned?: SortOrder
    emailVerificationKey?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    roleId?: IntWithAggregatesFilter<"User"> | number
    isBanned?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerificationKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SavedStationsWhereInput = {
    AND?: SavedStationsWhereInput | SavedStationsWhereInput[]
    OR?: SavedStationsWhereInput[]
    NOT?: SavedStationsWhereInput | SavedStationsWhereInput[]
    userId?: IntFilter<"SavedStations"> | number
    markerId?: IntFilter<"SavedStations"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    marker?: XOR<Station_markerScalarRelationFilter, station_markerWhereInput>
  }

  export type SavedStationsOrderByWithRelationInput = {
    userId?: SortOrder
    markerId?: SortOrder
    user?: UserOrderByWithRelationInput
    marker?: station_markerOrderByWithRelationInput
  }

  export type SavedStationsWhereUniqueInput = Prisma.AtLeast<{
    userId_markerId?: SavedStationsUserIdMarkerIdCompoundUniqueInput
    AND?: SavedStationsWhereInput | SavedStationsWhereInput[]
    OR?: SavedStationsWhereInput[]
    NOT?: SavedStationsWhereInput | SavedStationsWhereInput[]
    userId?: IntFilter<"SavedStations"> | number
    markerId?: IntFilter<"SavedStations"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    marker?: XOR<Station_markerScalarRelationFilter, station_markerWhereInput>
  }, "userId_markerId">

  export type SavedStationsOrderByWithAggregationInput = {
    userId?: SortOrder
    markerId?: SortOrder
    _count?: SavedStationsCountOrderByAggregateInput
    _avg?: SavedStationsAvgOrderByAggregateInput
    _max?: SavedStationsMaxOrderByAggregateInput
    _min?: SavedStationsMinOrderByAggregateInput
    _sum?: SavedStationsSumOrderByAggregateInput
  }

  export type SavedStationsScalarWhereWithAggregatesInput = {
    AND?: SavedStationsScalarWhereWithAggregatesInput | SavedStationsScalarWhereWithAggregatesInput[]
    OR?: SavedStationsScalarWhereWithAggregatesInput[]
    NOT?: SavedStationsScalarWhereWithAggregatesInput | SavedStationsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"SavedStations"> | number
    markerId?: IntWithAggregatesFilter<"SavedStations"> | number
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    permissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    permissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
    _relevance?: PermissionOrderByRelevanceInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    resource_action?: PermissionResourceActionCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "resource_action">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    resource?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
    users?: UserPermissionsListRelationFilter
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
    users?: UserPermissionsOrderByRelationAggregateInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
    users?: UserPermissionsListRelationFilter
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermission"> | number
    roleId?: IntWithAggregatesFilter<"RolePermission"> | number
    permissionId?: IntWithAggregatesFilter<"RolePermission"> | number
  }

  export type RecoveryTokenWhereInput = {
    AND?: RecoveryTokenWhereInput | RecoveryTokenWhereInput[]
    OR?: RecoveryTokenWhereInput[]
    NOT?: RecoveryTokenWhereInput | RecoveryTokenWhereInput[]
    userId?: IntFilter<"RecoveryToken"> | number
    tokenHash?: StringFilter<"RecoveryToken"> | string
    expiresAt?: DateTimeFilter<"RecoveryToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RecoveryTokenOrderByWithRelationInput = {
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: RecoveryTokenOrderByRelevanceInput
  }

  export type RecoveryTokenWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: RecoveryTokenWhereInput | RecoveryTokenWhereInput[]
    OR?: RecoveryTokenWhereInput[]
    NOT?: RecoveryTokenWhereInput | RecoveryTokenWhereInput[]
    tokenHash?: StringFilter<"RecoveryToken"> | string
    expiresAt?: DateTimeFilter<"RecoveryToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type RecoveryTokenOrderByWithAggregationInput = {
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    _count?: RecoveryTokenCountOrderByAggregateInput
    _avg?: RecoveryTokenAvgOrderByAggregateInput
    _max?: RecoveryTokenMaxOrderByAggregateInput
    _min?: RecoveryTokenMinOrderByAggregateInput
    _sum?: RecoveryTokenSumOrderByAggregateInput
  }

  export type RecoveryTokenScalarWhereWithAggregatesInput = {
    AND?: RecoveryTokenScalarWhereWithAggregatesInput | RecoveryTokenScalarWhereWithAggregatesInput[]
    OR?: RecoveryTokenScalarWhereWithAggregatesInput[]
    NOT?: RecoveryTokenScalarWhereWithAggregatesInput | RecoveryTokenScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"RecoveryToken"> | number
    tokenHash?: StringWithAggregatesFilter<"RecoveryToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RecoveryToken"> | Date | string
  }

  export type UserPermissionsWhereInput = {
    AND?: UserPermissionsWhereInput | UserPermissionsWhereInput[]
    OR?: UserPermissionsWhereInput[]
    NOT?: UserPermissionsWhereInput | UserPermissionsWhereInput[]
    userId?: IntFilter<"UserPermissions"> | number
    rolePermissionId?: IntFilter<"UserPermissions"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    rolePermission?: XOR<RolePermissionScalarRelationFilter, RolePermissionWhereInput>
  }

  export type UserPermissionsOrderByWithRelationInput = {
    userId?: SortOrder
    rolePermissionId?: SortOrder
    user?: UserOrderByWithRelationInput
    rolePermission?: RolePermissionOrderByWithRelationInput
  }

  export type UserPermissionsWhereUniqueInput = Prisma.AtLeast<{
    userId_rolePermissionId?: UserPermissionsUserIdRolePermissionIdCompoundUniqueInput
    AND?: UserPermissionsWhereInput | UserPermissionsWhereInput[]
    OR?: UserPermissionsWhereInput[]
    NOT?: UserPermissionsWhereInput | UserPermissionsWhereInput[]
    userId?: IntFilter<"UserPermissions"> | number
    rolePermissionId?: IntFilter<"UserPermissions"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    rolePermission?: XOR<RolePermissionScalarRelationFilter, RolePermissionWhereInput>
  }, "userId_rolePermissionId">

  export type UserPermissionsOrderByWithAggregationInput = {
    userId?: SortOrder
    rolePermissionId?: SortOrder
    _count?: UserPermissionsCountOrderByAggregateInput
    _avg?: UserPermissionsAvgOrderByAggregateInput
    _max?: UserPermissionsMaxOrderByAggregateInput
    _min?: UserPermissionsMinOrderByAggregateInput
    _sum?: UserPermissionsSumOrderByAggregateInput
  }

  export type UserPermissionsScalarWhereWithAggregatesInput = {
    AND?: UserPermissionsScalarWhereWithAggregatesInput | UserPermissionsScalarWhereWithAggregatesInput[]
    OR?: UserPermissionsScalarWhereWithAggregatesInput[]
    NOT?: UserPermissionsScalarWhereWithAggregatesInput | UserPermissionsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserPermissions"> | number
    rolePermissionId?: IntWithAggregatesFilter<"UserPermissions"> | number
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    ip?: StringFilter<"UserSession"> | string
    userAgent?: StringFilter<"UserSession"> | string
    refreshToken?: StringFilter<"UserSession"> | string
    userId?: IntFilter<"UserSession"> | number
    lastRefreshAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    lastRefreshAt?: SortOrder
    _relevance?: UserSessionOrderByRelevanceInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userAgent_userId?: UserSessionUserAgentUserIdCompoundUniqueInput
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    ip?: StringFilter<"UserSession"> | string
    userAgent?: StringFilter<"UserSession"> | string
    refreshToken?: StringFilter<"UserSession"> | string
    userId?: IntFilter<"UserSession"> | number
    lastRefreshAt?: DateTimeFilter<"UserSession"> | Date | string
  }, "id" | "userAgent_userId">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    lastRefreshAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _avg?: UserSessionAvgOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
    _sum?: UserSessionSumOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    ip?: StringWithAggregatesFilter<"UserSession"> | string
    userAgent?: StringWithAggregatesFilter<"UserSession"> | string
    refreshToken?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: IntWithAggregatesFilter<"UserSession"> | number
    lastRefreshAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type UserActivityWhereInput = {
    AND?: UserActivityWhereInput | UserActivityWhereInput[]
    OR?: UserActivityWhereInput[]
    NOT?: UserActivityWhereInput | UserActivityWhereInput[]
    userId?: IntFilter<"UserActivity"> | number
    ip?: StringFilter<"UserActivity"> | string
    lastActivityAt?: DateTimeFilter<"UserActivity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserActivityOrderByWithRelationInput = {
    userId?: SortOrder
    ip?: SortOrder
    lastActivityAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: UserActivityOrderByRelevanceInput
  }

  export type UserActivityWhereUniqueInput = Prisma.AtLeast<{
    userId_ip?: UserActivityUserIdIpCompoundUniqueInput
    AND?: UserActivityWhereInput | UserActivityWhereInput[]
    OR?: UserActivityWhereInput[]
    NOT?: UserActivityWhereInput | UserActivityWhereInput[]
    userId?: IntFilter<"UserActivity"> | number
    ip?: StringFilter<"UserActivity"> | string
    lastActivityAt?: DateTimeFilter<"UserActivity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_ip">

  export type UserActivityOrderByWithAggregationInput = {
    userId?: SortOrder
    ip?: SortOrder
    lastActivityAt?: SortOrder
    _count?: UserActivityCountOrderByAggregateInput
    _avg?: UserActivityAvgOrderByAggregateInput
    _max?: UserActivityMaxOrderByAggregateInput
    _min?: UserActivityMinOrderByAggregateInput
    _sum?: UserActivitySumOrderByAggregateInput
  }

  export type UserActivityScalarWhereWithAggregatesInput = {
    AND?: UserActivityScalarWhereWithAggregatesInput | UserActivityScalarWhereWithAggregatesInput[]
    OR?: UserActivityScalarWhereWithAggregatesInput[]
    NOT?: UserActivityScalarWhereWithAggregatesInput | UserActivityScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserActivity"> | number
    ip?: StringWithAggregatesFilter<"UserActivity"> | string
    lastActivityAt?: DateTimeWithAggregatesFilter<"UserActivity"> | Date | string
  }

  export type UserBanWhereInput = {
    AND?: UserBanWhereInput | UserBanWhereInput[]
    OR?: UserBanWhereInput[]
    NOT?: UserBanWhereInput | UserBanWhereInput[]
    userId?: IntFilter<"UserBan"> | number
    reason?: StringFilter<"UserBan"> | string
    expiredAt?: DateTimeFilter<"UserBan"> | Date | string
  }

  export type UserBanOrderByWithRelationInput = {
    userId?: SortOrder
    reason?: SortOrder
    expiredAt?: SortOrder
    _relevance?: UserBanOrderByRelevanceInput
  }

  export type UserBanWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: UserBanWhereInput | UserBanWhereInput[]
    OR?: UserBanWhereInput[]
    NOT?: UserBanWhereInput | UserBanWhereInput[]
    reason?: StringFilter<"UserBan"> | string
    expiredAt?: DateTimeFilter<"UserBan"> | Date | string
  }, "userId">

  export type UserBanOrderByWithAggregationInput = {
    userId?: SortOrder
    reason?: SortOrder
    expiredAt?: SortOrder
    _count?: UserBanCountOrderByAggregateInput
    _avg?: UserBanAvgOrderByAggregateInput
    _max?: UserBanMaxOrderByAggregateInput
    _min?: UserBanMinOrderByAggregateInput
    _sum?: UserBanSumOrderByAggregateInput
  }

  export type UserBanScalarWhereWithAggregatesInput = {
    AND?: UserBanScalarWhereWithAggregatesInput | UserBanScalarWhereWithAggregatesInput[]
    OR?: UserBanScalarWhereWithAggregatesInput[]
    NOT?: UserBanScalarWhereWithAggregatesInput | UserBanScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserBan"> | number
    reason?: StringWithAggregatesFilter<"UserBan"> | string
    expiredAt?: DateTimeWithAggregatesFilter<"UserBan"> | Date | string
  }

  export type api_sourceCreateInput = {
    link: string
    detailed_link: string
    last_update?: bigint | number | null
    next_update?: bigint | number | null
    update_interval_ms?: bigint | number | null
    comments_link?: string | null
    station_desc_api?: station_desc_apiCreateNestedManyWithoutApi_sourceInput
  }

  export type api_sourceUncheckedCreateInput = {
    api_id?: number
    link: string
    detailed_link: string
    last_update?: bigint | number | null
    next_update?: bigint | number | null
    update_interval_ms?: bigint | number | null
    comments_link?: string | null
    station_desc_api?: station_desc_apiUncheckedCreateNestedManyWithoutApi_sourceInput
  }

  export type api_sourceUpdateInput = {
    link?: StringFieldUpdateOperationsInput | string
    detailed_link?: StringFieldUpdateOperationsInput | string
    last_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    next_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    update_interval_ms?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments_link?: NullableStringFieldUpdateOperationsInput | string | null
    station_desc_api?: station_desc_apiUpdateManyWithoutApi_sourceNestedInput
  }

  export type api_sourceUncheckedUpdateInput = {
    api_id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    detailed_link?: StringFieldUpdateOperationsInput | string
    last_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    next_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    update_interval_ms?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments_link?: NullableStringFieldUpdateOperationsInput | string | null
    station_desc_api?: station_desc_apiUncheckedUpdateManyWithoutApi_sourceNestedInput
  }

  export type api_sourceCreateManyInput = {
    api_id?: number
    link: string
    detailed_link: string
    last_update?: bigint | number | null
    next_update?: bigint | number | null
    update_interval_ms?: bigint | number | null
    comments_link?: string | null
  }

  export type api_sourceUpdateManyMutationInput = {
    link?: StringFieldUpdateOperationsInput | string
    detailed_link?: StringFieldUpdateOperationsInput | string
    last_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    next_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    update_interval_ms?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type api_sourceUncheckedUpdateManyInput = {
    api_id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    detailed_link?: StringFieldUpdateOperationsInput | string
    last_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    next_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    update_interval_ms?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentsCreateInput = {
    comment_href?: string | null
    author_name?: string | null
    rating?: number | null
    comment_text?: string | null
    user?: UserCreateNestedOneWithoutCommentsInput
    station_description?: station_descriptionCreateNestedOneWithoutCommentsInput
  }

  export type commentsUncheckedCreateInput = {
    comment_id?: number
    description_id?: number | null
    comment_href?: string | null
    author_name?: string | null
    user_id?: number | null
    rating?: number | null
    comment_text?: string | null
  }

  export type commentsUpdateInput = {
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCommentsNestedInput
    station_description?: station_descriptionUpdateOneWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentsCreateManyInput = {
    comment_id?: number
    description_id?: number | null
    comment_href?: string | null
    author_name?: string | null
    user_id?: number | null
    rating?: number | null
    comment_text?: string | null
  }

  export type commentsUpdateManyMutationInput = {
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentsUncheckedUpdateManyInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type imagesCreateInput = {
    image_href?: string | null
    station_description?: station_descriptionCreateNestedOneWithoutImagesInput
  }

  export type imagesUncheckedCreateInput = {
    image_id?: number
    description_id?: number | null
    image_href?: string | null
  }

  export type imagesUpdateInput = {
    image_href?: NullableStringFieldUpdateOperationsInput | string | null
    station_description?: station_descriptionUpdateOneWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateInput = {
    image_id?: IntFieldUpdateOperationsInput | number
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_href?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type imagesCreateManyInput = {
    image_id?: number
    description_id?: number | null
    image_href?: string | null
  }

  export type imagesUpdateManyMutationInput = {
    image_href?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type imagesUncheckedUpdateManyInput = {
    image_id?: IntFieldUpdateOperationsInput | number
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_href?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type station_connectorCreateInput = {
    connector_type_id?: number | null
    connector_status_id?: number | null
    connector_name?: string | null
    power_kw?: number | null
    current_amp?: number | null
    price_per_start?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    free_min_after_charging?: number | null
    price_per_min_after_charging?: Decimal | DecimalJsLike | number | string | null
    station_description?: station_descriptionCreateNestedOneWithoutStation_connectorInput
  }

  export type station_connectorUncheckedCreateInput = {
    connector_id?: number
    description_id?: number | null
    connector_type_id?: number | null
    connector_status_id?: number | null
    connector_name?: string | null
    power_kw?: number | null
    current_amp?: number | null
    price_per_start?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    free_min_after_charging?: number | null
    price_per_min_after_charging?: Decimal | DecimalJsLike | number | string | null
  }

  export type station_connectorUpdateInput = {
    connector_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_status_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_name?: NullableStringFieldUpdateOperationsInput | string | null
    power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    current_amp?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_start?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    free_min_after_charging?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_min_after_charging?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    station_description?: station_descriptionUpdateOneWithoutStation_connectorNestedInput
  }

  export type station_connectorUncheckedUpdateInput = {
    connector_id?: IntFieldUpdateOperationsInput | number
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_status_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_name?: NullableStringFieldUpdateOperationsInput | string | null
    power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    current_amp?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_start?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    free_min_after_charging?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_min_after_charging?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type station_connectorCreateManyInput = {
    connector_id?: number
    description_id?: number | null
    connector_type_id?: number | null
    connector_status_id?: number | null
    connector_name?: string | null
    power_kw?: number | null
    current_amp?: number | null
    price_per_start?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    free_min_after_charging?: number | null
    price_per_min_after_charging?: Decimal | DecimalJsLike | number | string | null
  }

  export type station_connectorUpdateManyMutationInput = {
    connector_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_status_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_name?: NullableStringFieldUpdateOperationsInput | string | null
    power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    current_amp?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_start?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    free_min_after_charging?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_min_after_charging?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type station_connectorUncheckedUpdateManyInput = {
    connector_id?: IntFieldUpdateOperationsInput | number
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_status_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_name?: NullableStringFieldUpdateOperationsInput | string | null
    power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    current_amp?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_start?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    free_min_after_charging?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_min_after_charging?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type station_desc_apiCreateInput = {
    og_api_pk?: number | null
    api_source?: api_sourceCreateNestedOneWithoutStation_desc_apiInput
    station_description?: station_descriptionCreateNestedOneWithoutStation_desc_apiInput
  }

  export type station_desc_apiUncheckedCreateInput = {
    id?: number
    api_id?: number | null
    og_api_pk?: number | null
    description_id?: number | null
  }

  export type station_desc_apiUpdateInput = {
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
    api_source?: api_sourceUpdateOneWithoutStation_desc_apiNestedInput
    station_description?: station_descriptionUpdateOneWithoutStation_desc_apiNestedInput
  }

  export type station_desc_apiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    api_id?: NullableIntFieldUpdateOperationsInput | number | null
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type station_desc_apiCreateManyInput = {
    id?: number
    api_id?: number | null
    og_api_pk?: number | null
    description_id?: number | null
  }

  export type station_desc_apiUpdateManyMutationInput = {
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type station_desc_apiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    api_id?: NullableIntFieldUpdateOperationsInput | number | null
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type station_descriptionCreateInput = {
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsCreateNestedManyWithoutStation_descriptionInput
    images?: imagesCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiCreateNestedManyWithoutStation_descriptionInput
    station_marker?: station_markerCreateNestedOneWithoutStation_descriptionInput
  }

  export type station_descriptionUncheckedCreateInput = {
    description_id?: number
    station_id?: number | null
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsUncheckedCreateNestedManyWithoutStation_descriptionInput
    images?: imagesUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiUncheckedCreateNestedManyWithoutStation_descriptionInput
  }

  export type station_descriptionUpdateInput = {
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUpdateManyWithoutStation_descriptionNestedInput
    images?: imagesUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUpdateManyWithoutStation_descriptionNestedInput
    station_marker?: station_markerUpdateOneWithoutStation_descriptionNestedInput
  }

  export type station_descriptionUncheckedUpdateInput = {
    description_id?: IntFieldUpdateOperationsInput | number
    station_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUncheckedUpdateManyWithoutStation_descriptionNestedInput
    images?: imagesUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUncheckedUpdateManyWithoutStation_descriptionNestedInput
  }

  export type station_descriptionCreateManyInput = {
    description_id?: number
    station_id?: number | null
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
  }

  export type station_descriptionUpdateManyMutationInput = {
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type station_descriptionUncheckedUpdateManyInput = {
    description_id?: IntFieldUpdateOperationsInput | number
    station_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type station_markerCreateInput = {
    longitude: Decimal | DecimalJsLike | number | string
    latitude: Decimal | DecimalJsLike | number | string
    station_description?: station_descriptionCreateNestedManyWithoutStation_markerInput
    savedStations?: SavedStationsCreateNestedManyWithoutMarkerInput
  }

  export type station_markerUncheckedCreateInput = {
    station_id?: number
    longitude: Decimal | DecimalJsLike | number | string
    latitude: Decimal | DecimalJsLike | number | string
    station_description?: station_descriptionUncheckedCreateNestedManyWithoutStation_markerInput
    savedStations?: SavedStationsUncheckedCreateNestedManyWithoutMarkerInput
  }

  export type station_markerUpdateInput = {
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    station_description?: station_descriptionUpdateManyWithoutStation_markerNestedInput
    savedStations?: SavedStationsUpdateManyWithoutMarkerNestedInput
  }

  export type station_markerUncheckedUpdateInput = {
    station_id?: IntFieldUpdateOperationsInput | number
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    station_description?: station_descriptionUncheckedUpdateManyWithoutStation_markerNestedInput
    savedStations?: SavedStationsUncheckedUpdateManyWithoutMarkerNestedInput
  }

  export type station_markerCreateManyInput = {
    station_id?: number
    longitude: Decimal | DecimalJsLike | number | string
    latitude: Decimal | DecimalJsLike | number | string
  }

  export type station_markerUpdateManyMutationInput = {
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type station_markerUncheckedUpdateManyInput = {
    station_id?: IntFieldUpdateOperationsInput | number
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserCreateInput = {
    name: string
    email?: string | null
    passwordHash?: string | null
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    permissions?: UserPermissionsCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenCreateNestedManyWithoutUserInput
    comments?: commentsCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email?: string | null
    passwordHash?: string | null
    roleId: number
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenUncheckedCreateNestedManyWithoutUserInput
    comments?: commentsUncheckedCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    permissions?: UserPermissionsUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUpdateManyWithoutUserNestedInput
    comments?: commentsUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: UserPermissionsUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUncheckedUpdateManyWithoutUserNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email?: string | null
    passwordHash?: string | null
    roleId: number
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedStationsCreateInput = {
    user: UserCreateNestedOneWithoutSavedStationsInput
    marker: station_markerCreateNestedOneWithoutSavedStationsInput
  }

  export type SavedStationsUncheckedCreateInput = {
    userId: number
    markerId: number
  }

  export type SavedStationsUpdateInput = {
    user?: UserUpdateOneRequiredWithoutSavedStationsNestedInput
    marker?: station_markerUpdateOneRequiredWithoutSavedStationsNestedInput
  }

  export type SavedStationsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    markerId?: IntFieldUpdateOperationsInput | number
  }

  export type SavedStationsCreateManyInput = {
    userId: number
    markerId: number
  }

  export type SavedStationsUpdateManyMutationInput = {

  }

  export type SavedStationsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    markerId?: IntFieldUpdateOperationsInput | number
  }

  export type RoleCreateInput = {
    name: string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionCreateInput = {
    resource: string
    action: string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    resource: string
    action: string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    resource: string
    action: string
  }

  export type PermissionUpdateManyMutationInput = {
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateInput = {
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
    users?: UserPermissionsCreateNestedManyWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: number
    roleId: number
    permissionId: number
    users?: UserPermissionsUncheckedCreateNestedManyWithoutRolePermissionInput
  }

  export type RolePermissionUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
    users?: UserPermissionsUpdateManyWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    users?: UserPermissionsUncheckedUpdateManyWithoutRolePermissionNestedInput
  }

  export type RolePermissionCreateManyInput = {
    id?: number
    roleId: number
    permissionId: number
  }

  export type RolePermissionUpdateManyMutationInput = {

  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type RecoveryTokenCreateInput = {
    tokenHash: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutRecoveryTokenInput
  }

  export type RecoveryTokenUncheckedCreateInput = {
    userId: number
    tokenHash: string
    expiresAt: Date | string
  }

  export type RecoveryTokenUpdateInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecoveryTokenNestedInput
  }

  export type RecoveryTokenUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryTokenCreateManyInput = {
    userId: number
    tokenHash: string
    expiresAt: Date | string
  }

  export type RecoveryTokenUpdateManyMutationInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryTokenUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPermissionsCreateInput = {
    user: UserCreateNestedOneWithoutPermissionsInput
    rolePermission: RolePermissionCreateNestedOneWithoutUsersInput
  }

  export type UserPermissionsUncheckedCreateInput = {
    userId: number
    rolePermissionId: number
  }

  export type UserPermissionsUpdateInput = {
    user?: UserUpdateOneRequiredWithoutPermissionsNestedInput
    rolePermission?: RolePermissionUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserPermissionsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    rolePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPermissionsCreateManyInput = {
    userId: number
    rolePermissionId: number
  }

  export type UserPermissionsUpdateManyMutationInput = {

  }

  export type UserPermissionsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    rolePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserSessionCreateInput = {
    id?: string
    ip: string
    userAgent: string
    refreshToken: string
    userId: number
    lastRefreshAt?: Date | string
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    ip: string
    userAgent: string
    refreshToken: string
    userId: number
    lastRefreshAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    lastRefreshAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    lastRefreshAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    ip: string
    userAgent: string
    refreshToken: string
    userId: number
    lastRefreshAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    lastRefreshAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    lastRefreshAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityCreateInput = {
    ip: string
    lastActivityAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type UserActivityUncheckedCreateInput = {
    userId: number
    ip: string
    lastActivityAt?: Date | string
  }

  export type UserActivityUpdateInput = {
    ip?: StringFieldUpdateOperationsInput | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type UserActivityUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityCreateManyInput = {
    userId: number
    ip: string
    lastActivityAt?: Date | string
  }

  export type UserActivityUpdateManyMutationInput = {
    ip?: StringFieldUpdateOperationsInput | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBanCreateInput = {
    userId: number
    reason: string
    expiredAt: Date | string
  }

  export type UserBanUncheckedCreateInput = {
    userId: number
    reason: string
    expiredAt: Date | string
  }

  export type UserBanUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBanUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBanCreateManyInput = {
    userId: number
    reason: string
    expiredAt: Date | string
  }

  export type UserBanUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBanUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Station_desc_apiListRelationFilter = {
    every?: station_desc_apiWhereInput
    some?: station_desc_apiWhereInput
    none?: station_desc_apiWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type station_desc_apiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type api_sourceOrderByRelevanceInput = {
    fields: api_sourceOrderByRelevanceFieldEnum | api_sourceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type api_sourceCountOrderByAggregateInput = {
    api_id?: SortOrder
    link?: SortOrder
    detailed_link?: SortOrder
    last_update?: SortOrder
    next_update?: SortOrder
    update_interval_ms?: SortOrder
    comments_link?: SortOrder
  }

  export type api_sourceAvgOrderByAggregateInput = {
    api_id?: SortOrder
    last_update?: SortOrder
    next_update?: SortOrder
    update_interval_ms?: SortOrder
  }

  export type api_sourceMaxOrderByAggregateInput = {
    api_id?: SortOrder
    link?: SortOrder
    detailed_link?: SortOrder
    last_update?: SortOrder
    next_update?: SortOrder
    update_interval_ms?: SortOrder
    comments_link?: SortOrder
  }

  export type api_sourceMinOrderByAggregateInput = {
    api_id?: SortOrder
    link?: SortOrder
    detailed_link?: SortOrder
    last_update?: SortOrder
    next_update?: SortOrder
    update_interval_ms?: SortOrder
    comments_link?: SortOrder
  }

  export type api_sourceSumOrderByAggregateInput = {
    api_id?: SortOrder
    last_update?: SortOrder
    next_update?: SortOrder
    update_interval_ms?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type Station_descriptionNullableScalarRelationFilter = {
    is?: station_descriptionWhereInput | null
    isNot?: station_descriptionWhereInput | null
  }

  export type commentsOrderByRelevanceInput = {
    fields: commentsOrderByRelevanceFieldEnum | commentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type commentsCountOrderByAggregateInput = {
    comment_id?: SortOrder
    description_id?: SortOrder
    comment_href?: SortOrder
    author_name?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    comment_text?: SortOrder
  }

  export type commentsAvgOrderByAggregateInput = {
    comment_id?: SortOrder
    description_id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
  }

  export type commentsMaxOrderByAggregateInput = {
    comment_id?: SortOrder
    description_id?: SortOrder
    comment_href?: SortOrder
    author_name?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    comment_text?: SortOrder
  }

  export type commentsMinOrderByAggregateInput = {
    comment_id?: SortOrder
    description_id?: SortOrder
    comment_href?: SortOrder
    author_name?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    comment_text?: SortOrder
  }

  export type commentsSumOrderByAggregateInput = {
    comment_id?: SortOrder
    description_id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type imagesOrderByRelevanceInput = {
    fields: imagesOrderByRelevanceFieldEnum | imagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type imagesCountOrderByAggregateInput = {
    image_id?: SortOrder
    description_id?: SortOrder
    image_href?: SortOrder
  }

  export type imagesAvgOrderByAggregateInput = {
    image_id?: SortOrder
    description_id?: SortOrder
  }

  export type imagesMaxOrderByAggregateInput = {
    image_id?: SortOrder
    description_id?: SortOrder
    image_href?: SortOrder
  }

  export type imagesMinOrderByAggregateInput = {
    image_id?: SortOrder
    description_id?: SortOrder
    image_href?: SortOrder
  }

  export type imagesSumOrderByAggregateInput = {
    image_id?: SortOrder
    description_id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type station_connectorOrderByRelevanceInput = {
    fields: station_connectorOrderByRelevanceFieldEnum | station_connectorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type station_connectorCountOrderByAggregateInput = {
    connector_id?: SortOrder
    description_id?: SortOrder
    connector_type_id?: SortOrder
    connector_status_id?: SortOrder
    connector_name?: SortOrder
    power_kw?: SortOrder
    current_amp?: SortOrder
    price_per_start?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    free_min_after_charging?: SortOrder
    price_per_min_after_charging?: SortOrder
  }

  export type station_connectorAvgOrderByAggregateInput = {
    connector_id?: SortOrder
    description_id?: SortOrder
    connector_type_id?: SortOrder
    connector_status_id?: SortOrder
    power_kw?: SortOrder
    current_amp?: SortOrder
    price_per_start?: SortOrder
    price?: SortOrder
    free_min_after_charging?: SortOrder
    price_per_min_after_charging?: SortOrder
  }

  export type station_connectorMaxOrderByAggregateInput = {
    connector_id?: SortOrder
    description_id?: SortOrder
    connector_type_id?: SortOrder
    connector_status_id?: SortOrder
    connector_name?: SortOrder
    power_kw?: SortOrder
    current_amp?: SortOrder
    price_per_start?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    free_min_after_charging?: SortOrder
    price_per_min_after_charging?: SortOrder
  }

  export type station_connectorMinOrderByAggregateInput = {
    connector_id?: SortOrder
    description_id?: SortOrder
    connector_type_id?: SortOrder
    connector_status_id?: SortOrder
    connector_name?: SortOrder
    power_kw?: SortOrder
    current_amp?: SortOrder
    price_per_start?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    free_min_after_charging?: SortOrder
    price_per_min_after_charging?: SortOrder
  }

  export type station_connectorSumOrderByAggregateInput = {
    connector_id?: SortOrder
    description_id?: SortOrder
    connector_type_id?: SortOrder
    connector_status_id?: SortOrder
    power_kw?: SortOrder
    current_amp?: SortOrder
    price_per_start?: SortOrder
    price?: SortOrder
    free_min_after_charging?: SortOrder
    price_per_min_after_charging?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type Api_sourceNullableScalarRelationFilter = {
    is?: api_sourceWhereInput | null
    isNot?: api_sourceWhereInput | null
  }

  export type station_desc_apiCountOrderByAggregateInput = {
    id?: SortOrder
    api_id?: SortOrder
    og_api_pk?: SortOrder
    description_id?: SortOrder
  }

  export type station_desc_apiAvgOrderByAggregateInput = {
    id?: SortOrder
    api_id?: SortOrder
    og_api_pk?: SortOrder
    description_id?: SortOrder
  }

  export type station_desc_apiMaxOrderByAggregateInput = {
    id?: SortOrder
    api_id?: SortOrder
    og_api_pk?: SortOrder
    description_id?: SortOrder
  }

  export type station_desc_apiMinOrderByAggregateInput = {
    id?: SortOrder
    api_id?: SortOrder
    og_api_pk?: SortOrder
    description_id?: SortOrder
  }

  export type station_desc_apiSumOrderByAggregateInput = {
    id?: SortOrder
    api_id?: SortOrder
    og_api_pk?: SortOrder
    description_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type CommentsListRelationFilter = {
    every?: commentsWhereInput
    some?: commentsWhereInput
    none?: commentsWhereInput
  }

  export type ImagesListRelationFilter = {
    every?: imagesWhereInput
    some?: imagesWhereInput
    none?: imagesWhereInput
  }

  export type Station_connectorListRelationFilter = {
    every?: station_connectorWhereInput
    some?: station_connectorWhereInput
    none?: station_connectorWhereInput
  }

  export type Station_markerNullableScalarRelationFilter = {
    is?: station_markerWhereInput | null
    isNot?: station_markerWhereInput | null
  }

  export type commentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type station_connectorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type station_descriptionOrderByRelevanceInput = {
    fields: station_descriptionOrderByRelevanceFieldEnum | station_descriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type station_descriptionCountOrderByAggregateInput = {
    description_id?: SortOrder
    station_id?: SortOrder
    station_name?: SortOrder
    description_string?: SortOrder
    location_type?: SortOrder
    country_code?: SortOrder
    support_phone?: SortOrder
    is_support_charging?: SortOrder
    is_support_reservation?: SortOrder
    location_name?: SortOrder
    last_charging?: SortOrder
    is_public?: SortOrder
    is_fast_charger?: SortOrder
    is_open_24x7?: SortOrder
    min_power_kw?: SortOrder
    max_power_kw?: SortOrder
    last_status_update?: SortOrder
    network_id?: SortOrder
    status_id?: SortOrder
    station_flags?: SortOrder
  }

  export type station_descriptionAvgOrderByAggregateInput = {
    description_id?: SortOrder
    station_id?: SortOrder
    last_charging?: SortOrder
    min_power_kw?: SortOrder
    max_power_kw?: SortOrder
    last_status_update?: SortOrder
    network_id?: SortOrder
    status_id?: SortOrder
  }

  export type station_descriptionMaxOrderByAggregateInput = {
    description_id?: SortOrder
    station_id?: SortOrder
    station_name?: SortOrder
    description_string?: SortOrder
    location_type?: SortOrder
    country_code?: SortOrder
    support_phone?: SortOrder
    is_support_charging?: SortOrder
    is_support_reservation?: SortOrder
    location_name?: SortOrder
    last_charging?: SortOrder
    is_public?: SortOrder
    is_fast_charger?: SortOrder
    is_open_24x7?: SortOrder
    min_power_kw?: SortOrder
    max_power_kw?: SortOrder
    last_status_update?: SortOrder
    network_id?: SortOrder
    status_id?: SortOrder
    station_flags?: SortOrder
  }

  export type station_descriptionMinOrderByAggregateInput = {
    description_id?: SortOrder
    station_id?: SortOrder
    station_name?: SortOrder
    description_string?: SortOrder
    location_type?: SortOrder
    country_code?: SortOrder
    support_phone?: SortOrder
    is_support_charging?: SortOrder
    is_support_reservation?: SortOrder
    location_name?: SortOrder
    last_charging?: SortOrder
    is_public?: SortOrder
    is_fast_charger?: SortOrder
    is_open_24x7?: SortOrder
    min_power_kw?: SortOrder
    max_power_kw?: SortOrder
    last_status_update?: SortOrder
    network_id?: SortOrder
    status_id?: SortOrder
    station_flags?: SortOrder
  }

  export type station_descriptionSumOrderByAggregateInput = {
    description_id?: SortOrder
    station_id?: SortOrder
    last_charging?: SortOrder
    min_power_kw?: SortOrder
    max_power_kw?: SortOrder
    last_status_update?: SortOrder
    network_id?: SortOrder
    status_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Station_descriptionListRelationFilter = {
    every?: station_descriptionWhereInput
    some?: station_descriptionWhereInput
    none?: station_descriptionWhereInput
  }

  export type SavedStationsListRelationFilter = {
    every?: SavedStationsWhereInput
    some?: SavedStationsWhereInput
    none?: SavedStationsWhereInput
  }

  export type station_descriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedStationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type station_markerCountOrderByAggregateInput = {
    station_id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type station_markerAvgOrderByAggregateInput = {
    station_id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type station_markerMaxOrderByAggregateInput = {
    station_id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type station_markerMinOrderByAggregateInput = {
    station_id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type station_markerSumOrderByAggregateInput = {
    station_id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserPermissionsListRelationFilter = {
    every?: UserPermissionsWhereInput
    some?: UserPermissionsWhereInput
    none?: UserPermissionsWhereInput
  }

  export type UserActivityListRelationFilter = {
    every?: UserActivityWhereInput
    some?: UserActivityWhereInput
    none?: UserActivityWhereInput
  }

  export type RecoveryTokenListRelationFilter = {
    every?: RecoveryTokenWhereInput
    some?: RecoveryTokenWhereInput
    none?: RecoveryTokenWhereInput
  }

  export type UserPermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecoveryTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    roleId?: SortOrder
    isBanned?: SortOrder
    emailVerificationKey?: SortOrder
    emailVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    roleId?: SortOrder
    isBanned?: SortOrder
    emailVerificationKey?: SortOrder
    emailVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    roleId?: SortOrder
    isBanned?: SortOrder
    emailVerificationKey?: SortOrder
    emailVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type Station_markerScalarRelationFilter = {
    is?: station_markerWhereInput
    isNot?: station_markerWhereInput
  }

  export type SavedStationsUserIdMarkerIdCompoundUniqueInput = {
    userId: number
    markerId: number
  }

  export type SavedStationsCountOrderByAggregateInput = {
    userId?: SortOrder
    markerId?: SortOrder
  }

  export type SavedStationsAvgOrderByAggregateInput = {
    userId?: SortOrder
    markerId?: SortOrder
  }

  export type SavedStationsMaxOrderByAggregateInput = {
    userId?: SortOrder
    markerId?: SortOrder
  }

  export type SavedStationsMinOrderByAggregateInput = {
    userId?: SortOrder
    markerId?: SortOrder
  }

  export type SavedStationsSumOrderByAggregateInput = {
    userId?: SortOrder
    markerId?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionOrderByRelevanceInput = {
    fields: PermissionOrderByRelevanceFieldEnum | PermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PermissionResourceActionCompoundUniqueInput = {
    resource: string
    action: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RecoveryTokenOrderByRelevanceInput = {
    fields: RecoveryTokenOrderByRelevanceFieldEnum | RecoveryTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RecoveryTokenCountOrderByAggregateInput = {
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
  }

  export type RecoveryTokenAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type RecoveryTokenMaxOrderByAggregateInput = {
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
  }

  export type RecoveryTokenMinOrderByAggregateInput = {
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
  }

  export type RecoveryTokenSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type RolePermissionScalarRelationFilter = {
    is?: RolePermissionWhereInput
    isNot?: RolePermissionWhereInput
  }

  export type UserPermissionsUserIdRolePermissionIdCompoundUniqueInput = {
    userId: number
    rolePermissionId: number
  }

  export type UserPermissionsCountOrderByAggregateInput = {
    userId?: SortOrder
    rolePermissionId?: SortOrder
  }

  export type UserPermissionsAvgOrderByAggregateInput = {
    userId?: SortOrder
    rolePermissionId?: SortOrder
  }

  export type UserPermissionsMaxOrderByAggregateInput = {
    userId?: SortOrder
    rolePermissionId?: SortOrder
  }

  export type UserPermissionsMinOrderByAggregateInput = {
    userId?: SortOrder
    rolePermissionId?: SortOrder
  }

  export type UserPermissionsSumOrderByAggregateInput = {
    userId?: SortOrder
    rolePermissionId?: SortOrder
  }

  export type UserSessionOrderByRelevanceInput = {
    fields: UserSessionOrderByRelevanceFieldEnum | UserSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserSessionUserAgentUserIdCompoundUniqueInput = {
    userAgent: string
    userId: number
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    lastRefreshAt?: SortOrder
  }

  export type UserSessionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    lastRefreshAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    lastRefreshAt?: SortOrder
  }

  export type UserSessionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserActivityOrderByRelevanceInput = {
    fields: UserActivityOrderByRelevanceFieldEnum | UserActivityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserActivityUserIdIpCompoundUniqueInput = {
    userId: number
    ip: string
  }

  export type UserActivityCountOrderByAggregateInput = {
    userId?: SortOrder
    ip?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserActivityAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserActivityMaxOrderByAggregateInput = {
    userId?: SortOrder
    ip?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserActivityMinOrderByAggregateInput = {
    userId?: SortOrder
    ip?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserActivitySumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserBanOrderByRelevanceInput = {
    fields: UserBanOrderByRelevanceFieldEnum | UserBanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserBanCountOrderByAggregateInput = {
    userId?: SortOrder
    reason?: SortOrder
    expiredAt?: SortOrder
  }

  export type UserBanAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserBanMaxOrderByAggregateInput = {
    userId?: SortOrder
    reason?: SortOrder
    expiredAt?: SortOrder
  }

  export type UserBanMinOrderByAggregateInput = {
    userId?: SortOrder
    reason?: SortOrder
    expiredAt?: SortOrder
  }

  export type UserBanSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type station_desc_apiCreateNestedManyWithoutApi_sourceInput = {
    create?: XOR<station_desc_apiCreateWithoutApi_sourceInput, station_desc_apiUncheckedCreateWithoutApi_sourceInput> | station_desc_apiCreateWithoutApi_sourceInput[] | station_desc_apiUncheckedCreateWithoutApi_sourceInput[]
    connectOrCreate?: station_desc_apiCreateOrConnectWithoutApi_sourceInput | station_desc_apiCreateOrConnectWithoutApi_sourceInput[]
    createMany?: station_desc_apiCreateManyApi_sourceInputEnvelope
    connect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
  }

  export type station_desc_apiUncheckedCreateNestedManyWithoutApi_sourceInput = {
    create?: XOR<station_desc_apiCreateWithoutApi_sourceInput, station_desc_apiUncheckedCreateWithoutApi_sourceInput> | station_desc_apiCreateWithoutApi_sourceInput[] | station_desc_apiUncheckedCreateWithoutApi_sourceInput[]
    connectOrCreate?: station_desc_apiCreateOrConnectWithoutApi_sourceInput | station_desc_apiCreateOrConnectWithoutApi_sourceInput[]
    createMany?: station_desc_apiCreateManyApi_sourceInputEnvelope
    connect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type station_desc_apiUpdateManyWithoutApi_sourceNestedInput = {
    create?: XOR<station_desc_apiCreateWithoutApi_sourceInput, station_desc_apiUncheckedCreateWithoutApi_sourceInput> | station_desc_apiCreateWithoutApi_sourceInput[] | station_desc_apiUncheckedCreateWithoutApi_sourceInput[]
    connectOrCreate?: station_desc_apiCreateOrConnectWithoutApi_sourceInput | station_desc_apiCreateOrConnectWithoutApi_sourceInput[]
    upsert?: station_desc_apiUpsertWithWhereUniqueWithoutApi_sourceInput | station_desc_apiUpsertWithWhereUniqueWithoutApi_sourceInput[]
    createMany?: station_desc_apiCreateManyApi_sourceInputEnvelope
    set?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    disconnect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    delete?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    connect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    update?: station_desc_apiUpdateWithWhereUniqueWithoutApi_sourceInput | station_desc_apiUpdateWithWhereUniqueWithoutApi_sourceInput[]
    updateMany?: station_desc_apiUpdateManyWithWhereWithoutApi_sourceInput | station_desc_apiUpdateManyWithWhereWithoutApi_sourceInput[]
    deleteMany?: station_desc_apiScalarWhereInput | station_desc_apiScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type station_desc_apiUncheckedUpdateManyWithoutApi_sourceNestedInput = {
    create?: XOR<station_desc_apiCreateWithoutApi_sourceInput, station_desc_apiUncheckedCreateWithoutApi_sourceInput> | station_desc_apiCreateWithoutApi_sourceInput[] | station_desc_apiUncheckedCreateWithoutApi_sourceInput[]
    connectOrCreate?: station_desc_apiCreateOrConnectWithoutApi_sourceInput | station_desc_apiCreateOrConnectWithoutApi_sourceInput[]
    upsert?: station_desc_apiUpsertWithWhereUniqueWithoutApi_sourceInput | station_desc_apiUpsertWithWhereUniqueWithoutApi_sourceInput[]
    createMany?: station_desc_apiCreateManyApi_sourceInputEnvelope
    set?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    disconnect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    delete?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    connect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    update?: station_desc_apiUpdateWithWhereUniqueWithoutApi_sourceInput | station_desc_apiUpdateWithWhereUniqueWithoutApi_sourceInput[]
    updateMany?: station_desc_apiUpdateManyWithWhereWithoutApi_sourceInput | station_desc_apiUpdateManyWithWhereWithoutApi_sourceInput[]
    deleteMany?: station_desc_apiScalarWhereInput | station_desc_apiScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type station_descriptionCreateNestedOneWithoutCommentsInput = {
    create?: XOR<station_descriptionCreateWithoutCommentsInput, station_descriptionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: station_descriptionCreateOrConnectWithoutCommentsInput
    connect?: station_descriptionWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type station_descriptionUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<station_descriptionCreateWithoutCommentsInput, station_descriptionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: station_descriptionCreateOrConnectWithoutCommentsInput
    upsert?: station_descriptionUpsertWithoutCommentsInput
    disconnect?: station_descriptionWhereInput | boolean
    delete?: station_descriptionWhereInput | boolean
    connect?: station_descriptionWhereUniqueInput
    update?: XOR<XOR<station_descriptionUpdateToOneWithWhereWithoutCommentsInput, station_descriptionUpdateWithoutCommentsInput>, station_descriptionUncheckedUpdateWithoutCommentsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type station_descriptionCreateNestedOneWithoutImagesInput = {
    create?: XOR<station_descriptionCreateWithoutImagesInput, station_descriptionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: station_descriptionCreateOrConnectWithoutImagesInput
    connect?: station_descriptionWhereUniqueInput
  }

  export type station_descriptionUpdateOneWithoutImagesNestedInput = {
    create?: XOR<station_descriptionCreateWithoutImagesInput, station_descriptionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: station_descriptionCreateOrConnectWithoutImagesInput
    upsert?: station_descriptionUpsertWithoutImagesInput
    disconnect?: station_descriptionWhereInput | boolean
    delete?: station_descriptionWhereInput | boolean
    connect?: station_descriptionWhereUniqueInput
    update?: XOR<XOR<station_descriptionUpdateToOneWithWhereWithoutImagesInput, station_descriptionUpdateWithoutImagesInput>, station_descriptionUncheckedUpdateWithoutImagesInput>
  }

  export type station_descriptionCreateNestedOneWithoutStation_connectorInput = {
    create?: XOR<station_descriptionCreateWithoutStation_connectorInput, station_descriptionUncheckedCreateWithoutStation_connectorInput>
    connectOrCreate?: station_descriptionCreateOrConnectWithoutStation_connectorInput
    connect?: station_descriptionWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type station_descriptionUpdateOneWithoutStation_connectorNestedInput = {
    create?: XOR<station_descriptionCreateWithoutStation_connectorInput, station_descriptionUncheckedCreateWithoutStation_connectorInput>
    connectOrCreate?: station_descriptionCreateOrConnectWithoutStation_connectorInput
    upsert?: station_descriptionUpsertWithoutStation_connectorInput
    disconnect?: station_descriptionWhereInput | boolean
    delete?: station_descriptionWhereInput | boolean
    connect?: station_descriptionWhereUniqueInput
    update?: XOR<XOR<station_descriptionUpdateToOneWithWhereWithoutStation_connectorInput, station_descriptionUpdateWithoutStation_connectorInput>, station_descriptionUncheckedUpdateWithoutStation_connectorInput>
  }

  export type api_sourceCreateNestedOneWithoutStation_desc_apiInput = {
    create?: XOR<api_sourceCreateWithoutStation_desc_apiInput, api_sourceUncheckedCreateWithoutStation_desc_apiInput>
    connectOrCreate?: api_sourceCreateOrConnectWithoutStation_desc_apiInput
    connect?: api_sourceWhereUniqueInput
  }

  export type station_descriptionCreateNestedOneWithoutStation_desc_apiInput = {
    create?: XOR<station_descriptionCreateWithoutStation_desc_apiInput, station_descriptionUncheckedCreateWithoutStation_desc_apiInput>
    connectOrCreate?: station_descriptionCreateOrConnectWithoutStation_desc_apiInput
    connect?: station_descriptionWhereUniqueInput
  }

  export type api_sourceUpdateOneWithoutStation_desc_apiNestedInput = {
    create?: XOR<api_sourceCreateWithoutStation_desc_apiInput, api_sourceUncheckedCreateWithoutStation_desc_apiInput>
    connectOrCreate?: api_sourceCreateOrConnectWithoutStation_desc_apiInput
    upsert?: api_sourceUpsertWithoutStation_desc_apiInput
    disconnect?: api_sourceWhereInput | boolean
    delete?: api_sourceWhereInput | boolean
    connect?: api_sourceWhereUniqueInput
    update?: XOR<XOR<api_sourceUpdateToOneWithWhereWithoutStation_desc_apiInput, api_sourceUpdateWithoutStation_desc_apiInput>, api_sourceUncheckedUpdateWithoutStation_desc_apiInput>
  }

  export type station_descriptionUpdateOneWithoutStation_desc_apiNestedInput = {
    create?: XOR<station_descriptionCreateWithoutStation_desc_apiInput, station_descriptionUncheckedCreateWithoutStation_desc_apiInput>
    connectOrCreate?: station_descriptionCreateOrConnectWithoutStation_desc_apiInput
    upsert?: station_descriptionUpsertWithoutStation_desc_apiInput
    disconnect?: station_descriptionWhereInput | boolean
    delete?: station_descriptionWhereInput | boolean
    connect?: station_descriptionWhereUniqueInput
    update?: XOR<XOR<station_descriptionUpdateToOneWithWhereWithoutStation_desc_apiInput, station_descriptionUpdateWithoutStation_desc_apiInput>, station_descriptionUncheckedUpdateWithoutStation_desc_apiInput>
  }

  export type commentsCreateNestedManyWithoutStation_descriptionInput = {
    create?: XOR<commentsCreateWithoutStation_descriptionInput, commentsUncheckedCreateWithoutStation_descriptionInput> | commentsCreateWithoutStation_descriptionInput[] | commentsUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutStation_descriptionInput | commentsCreateOrConnectWithoutStation_descriptionInput[]
    createMany?: commentsCreateManyStation_descriptionInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type imagesCreateNestedManyWithoutStation_descriptionInput = {
    create?: XOR<imagesCreateWithoutStation_descriptionInput, imagesUncheckedCreateWithoutStation_descriptionInput> | imagesCreateWithoutStation_descriptionInput[] | imagesUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutStation_descriptionInput | imagesCreateOrConnectWithoutStation_descriptionInput[]
    createMany?: imagesCreateManyStation_descriptionInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type station_connectorCreateNestedManyWithoutStation_descriptionInput = {
    create?: XOR<station_connectorCreateWithoutStation_descriptionInput, station_connectorUncheckedCreateWithoutStation_descriptionInput> | station_connectorCreateWithoutStation_descriptionInput[] | station_connectorUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: station_connectorCreateOrConnectWithoutStation_descriptionInput | station_connectorCreateOrConnectWithoutStation_descriptionInput[]
    createMany?: station_connectorCreateManyStation_descriptionInputEnvelope
    connect?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
  }

  export type station_desc_apiCreateNestedManyWithoutStation_descriptionInput = {
    create?: XOR<station_desc_apiCreateWithoutStation_descriptionInput, station_desc_apiUncheckedCreateWithoutStation_descriptionInput> | station_desc_apiCreateWithoutStation_descriptionInput[] | station_desc_apiUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: station_desc_apiCreateOrConnectWithoutStation_descriptionInput | station_desc_apiCreateOrConnectWithoutStation_descriptionInput[]
    createMany?: station_desc_apiCreateManyStation_descriptionInputEnvelope
    connect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
  }

  export type station_markerCreateNestedOneWithoutStation_descriptionInput = {
    create?: XOR<station_markerCreateWithoutStation_descriptionInput, station_markerUncheckedCreateWithoutStation_descriptionInput>
    connectOrCreate?: station_markerCreateOrConnectWithoutStation_descriptionInput
    connect?: station_markerWhereUniqueInput
  }

  export type commentsUncheckedCreateNestedManyWithoutStation_descriptionInput = {
    create?: XOR<commentsCreateWithoutStation_descriptionInput, commentsUncheckedCreateWithoutStation_descriptionInput> | commentsCreateWithoutStation_descriptionInput[] | commentsUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutStation_descriptionInput | commentsCreateOrConnectWithoutStation_descriptionInput[]
    createMany?: commentsCreateManyStation_descriptionInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type imagesUncheckedCreateNestedManyWithoutStation_descriptionInput = {
    create?: XOR<imagesCreateWithoutStation_descriptionInput, imagesUncheckedCreateWithoutStation_descriptionInput> | imagesCreateWithoutStation_descriptionInput[] | imagesUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutStation_descriptionInput | imagesCreateOrConnectWithoutStation_descriptionInput[]
    createMany?: imagesCreateManyStation_descriptionInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type station_connectorUncheckedCreateNestedManyWithoutStation_descriptionInput = {
    create?: XOR<station_connectorCreateWithoutStation_descriptionInput, station_connectorUncheckedCreateWithoutStation_descriptionInput> | station_connectorCreateWithoutStation_descriptionInput[] | station_connectorUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: station_connectorCreateOrConnectWithoutStation_descriptionInput | station_connectorCreateOrConnectWithoutStation_descriptionInput[]
    createMany?: station_connectorCreateManyStation_descriptionInputEnvelope
    connect?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
  }

  export type station_desc_apiUncheckedCreateNestedManyWithoutStation_descriptionInput = {
    create?: XOR<station_desc_apiCreateWithoutStation_descriptionInput, station_desc_apiUncheckedCreateWithoutStation_descriptionInput> | station_desc_apiCreateWithoutStation_descriptionInput[] | station_desc_apiUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: station_desc_apiCreateOrConnectWithoutStation_descriptionInput | station_desc_apiCreateOrConnectWithoutStation_descriptionInput[]
    createMany?: station_desc_apiCreateManyStation_descriptionInputEnvelope
    connect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type commentsUpdateManyWithoutStation_descriptionNestedInput = {
    create?: XOR<commentsCreateWithoutStation_descriptionInput, commentsUncheckedCreateWithoutStation_descriptionInput> | commentsCreateWithoutStation_descriptionInput[] | commentsUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutStation_descriptionInput | commentsCreateOrConnectWithoutStation_descriptionInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutStation_descriptionInput | commentsUpsertWithWhereUniqueWithoutStation_descriptionInput[]
    createMany?: commentsCreateManyStation_descriptionInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutStation_descriptionInput | commentsUpdateWithWhereUniqueWithoutStation_descriptionInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutStation_descriptionInput | commentsUpdateManyWithWhereWithoutStation_descriptionInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type imagesUpdateManyWithoutStation_descriptionNestedInput = {
    create?: XOR<imagesCreateWithoutStation_descriptionInput, imagesUncheckedCreateWithoutStation_descriptionInput> | imagesCreateWithoutStation_descriptionInput[] | imagesUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutStation_descriptionInput | imagesCreateOrConnectWithoutStation_descriptionInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutStation_descriptionInput | imagesUpsertWithWhereUniqueWithoutStation_descriptionInput[]
    createMany?: imagesCreateManyStation_descriptionInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutStation_descriptionInput | imagesUpdateWithWhereUniqueWithoutStation_descriptionInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutStation_descriptionInput | imagesUpdateManyWithWhereWithoutStation_descriptionInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type station_connectorUpdateManyWithoutStation_descriptionNestedInput = {
    create?: XOR<station_connectorCreateWithoutStation_descriptionInput, station_connectorUncheckedCreateWithoutStation_descriptionInput> | station_connectorCreateWithoutStation_descriptionInput[] | station_connectorUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: station_connectorCreateOrConnectWithoutStation_descriptionInput | station_connectorCreateOrConnectWithoutStation_descriptionInput[]
    upsert?: station_connectorUpsertWithWhereUniqueWithoutStation_descriptionInput | station_connectorUpsertWithWhereUniqueWithoutStation_descriptionInput[]
    createMany?: station_connectorCreateManyStation_descriptionInputEnvelope
    set?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
    disconnect?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
    delete?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
    connect?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
    update?: station_connectorUpdateWithWhereUniqueWithoutStation_descriptionInput | station_connectorUpdateWithWhereUniqueWithoutStation_descriptionInput[]
    updateMany?: station_connectorUpdateManyWithWhereWithoutStation_descriptionInput | station_connectorUpdateManyWithWhereWithoutStation_descriptionInput[]
    deleteMany?: station_connectorScalarWhereInput | station_connectorScalarWhereInput[]
  }

  export type station_desc_apiUpdateManyWithoutStation_descriptionNestedInput = {
    create?: XOR<station_desc_apiCreateWithoutStation_descriptionInput, station_desc_apiUncheckedCreateWithoutStation_descriptionInput> | station_desc_apiCreateWithoutStation_descriptionInput[] | station_desc_apiUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: station_desc_apiCreateOrConnectWithoutStation_descriptionInput | station_desc_apiCreateOrConnectWithoutStation_descriptionInput[]
    upsert?: station_desc_apiUpsertWithWhereUniqueWithoutStation_descriptionInput | station_desc_apiUpsertWithWhereUniqueWithoutStation_descriptionInput[]
    createMany?: station_desc_apiCreateManyStation_descriptionInputEnvelope
    set?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    disconnect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    delete?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    connect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    update?: station_desc_apiUpdateWithWhereUniqueWithoutStation_descriptionInput | station_desc_apiUpdateWithWhereUniqueWithoutStation_descriptionInput[]
    updateMany?: station_desc_apiUpdateManyWithWhereWithoutStation_descriptionInput | station_desc_apiUpdateManyWithWhereWithoutStation_descriptionInput[]
    deleteMany?: station_desc_apiScalarWhereInput | station_desc_apiScalarWhereInput[]
  }

  export type station_markerUpdateOneWithoutStation_descriptionNestedInput = {
    create?: XOR<station_markerCreateWithoutStation_descriptionInput, station_markerUncheckedCreateWithoutStation_descriptionInput>
    connectOrCreate?: station_markerCreateOrConnectWithoutStation_descriptionInput
    upsert?: station_markerUpsertWithoutStation_descriptionInput
    disconnect?: station_markerWhereInput | boolean
    delete?: station_markerWhereInput | boolean
    connect?: station_markerWhereUniqueInput
    update?: XOR<XOR<station_markerUpdateToOneWithWhereWithoutStation_descriptionInput, station_markerUpdateWithoutStation_descriptionInput>, station_markerUncheckedUpdateWithoutStation_descriptionInput>
  }

  export type commentsUncheckedUpdateManyWithoutStation_descriptionNestedInput = {
    create?: XOR<commentsCreateWithoutStation_descriptionInput, commentsUncheckedCreateWithoutStation_descriptionInput> | commentsCreateWithoutStation_descriptionInput[] | commentsUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutStation_descriptionInput | commentsCreateOrConnectWithoutStation_descriptionInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutStation_descriptionInput | commentsUpsertWithWhereUniqueWithoutStation_descriptionInput[]
    createMany?: commentsCreateManyStation_descriptionInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutStation_descriptionInput | commentsUpdateWithWhereUniqueWithoutStation_descriptionInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutStation_descriptionInput | commentsUpdateManyWithWhereWithoutStation_descriptionInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type imagesUncheckedUpdateManyWithoutStation_descriptionNestedInput = {
    create?: XOR<imagesCreateWithoutStation_descriptionInput, imagesUncheckedCreateWithoutStation_descriptionInput> | imagesCreateWithoutStation_descriptionInput[] | imagesUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutStation_descriptionInput | imagesCreateOrConnectWithoutStation_descriptionInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutStation_descriptionInput | imagesUpsertWithWhereUniqueWithoutStation_descriptionInput[]
    createMany?: imagesCreateManyStation_descriptionInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutStation_descriptionInput | imagesUpdateWithWhereUniqueWithoutStation_descriptionInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutStation_descriptionInput | imagesUpdateManyWithWhereWithoutStation_descriptionInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type station_connectorUncheckedUpdateManyWithoutStation_descriptionNestedInput = {
    create?: XOR<station_connectorCreateWithoutStation_descriptionInput, station_connectorUncheckedCreateWithoutStation_descriptionInput> | station_connectorCreateWithoutStation_descriptionInput[] | station_connectorUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: station_connectorCreateOrConnectWithoutStation_descriptionInput | station_connectorCreateOrConnectWithoutStation_descriptionInput[]
    upsert?: station_connectorUpsertWithWhereUniqueWithoutStation_descriptionInput | station_connectorUpsertWithWhereUniqueWithoutStation_descriptionInput[]
    createMany?: station_connectorCreateManyStation_descriptionInputEnvelope
    set?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
    disconnect?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
    delete?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
    connect?: station_connectorWhereUniqueInput | station_connectorWhereUniqueInput[]
    update?: station_connectorUpdateWithWhereUniqueWithoutStation_descriptionInput | station_connectorUpdateWithWhereUniqueWithoutStation_descriptionInput[]
    updateMany?: station_connectorUpdateManyWithWhereWithoutStation_descriptionInput | station_connectorUpdateManyWithWhereWithoutStation_descriptionInput[]
    deleteMany?: station_connectorScalarWhereInput | station_connectorScalarWhereInput[]
  }

  export type station_desc_apiUncheckedUpdateManyWithoutStation_descriptionNestedInput = {
    create?: XOR<station_desc_apiCreateWithoutStation_descriptionInput, station_desc_apiUncheckedCreateWithoutStation_descriptionInput> | station_desc_apiCreateWithoutStation_descriptionInput[] | station_desc_apiUncheckedCreateWithoutStation_descriptionInput[]
    connectOrCreate?: station_desc_apiCreateOrConnectWithoutStation_descriptionInput | station_desc_apiCreateOrConnectWithoutStation_descriptionInput[]
    upsert?: station_desc_apiUpsertWithWhereUniqueWithoutStation_descriptionInput | station_desc_apiUpsertWithWhereUniqueWithoutStation_descriptionInput[]
    createMany?: station_desc_apiCreateManyStation_descriptionInputEnvelope
    set?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    disconnect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    delete?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    connect?: station_desc_apiWhereUniqueInput | station_desc_apiWhereUniqueInput[]
    update?: station_desc_apiUpdateWithWhereUniqueWithoutStation_descriptionInput | station_desc_apiUpdateWithWhereUniqueWithoutStation_descriptionInput[]
    updateMany?: station_desc_apiUpdateManyWithWhereWithoutStation_descriptionInput | station_desc_apiUpdateManyWithWhereWithoutStation_descriptionInput[]
    deleteMany?: station_desc_apiScalarWhereInput | station_desc_apiScalarWhereInput[]
  }

  export type station_descriptionCreateNestedManyWithoutStation_markerInput = {
    create?: XOR<station_descriptionCreateWithoutStation_markerInput, station_descriptionUncheckedCreateWithoutStation_markerInput> | station_descriptionCreateWithoutStation_markerInput[] | station_descriptionUncheckedCreateWithoutStation_markerInput[]
    connectOrCreate?: station_descriptionCreateOrConnectWithoutStation_markerInput | station_descriptionCreateOrConnectWithoutStation_markerInput[]
    createMany?: station_descriptionCreateManyStation_markerInputEnvelope
    connect?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
  }

  export type SavedStationsCreateNestedManyWithoutMarkerInput = {
    create?: XOR<SavedStationsCreateWithoutMarkerInput, SavedStationsUncheckedCreateWithoutMarkerInput> | SavedStationsCreateWithoutMarkerInput[] | SavedStationsUncheckedCreateWithoutMarkerInput[]
    connectOrCreate?: SavedStationsCreateOrConnectWithoutMarkerInput | SavedStationsCreateOrConnectWithoutMarkerInput[]
    createMany?: SavedStationsCreateManyMarkerInputEnvelope
    connect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
  }

  export type station_descriptionUncheckedCreateNestedManyWithoutStation_markerInput = {
    create?: XOR<station_descriptionCreateWithoutStation_markerInput, station_descriptionUncheckedCreateWithoutStation_markerInput> | station_descriptionCreateWithoutStation_markerInput[] | station_descriptionUncheckedCreateWithoutStation_markerInput[]
    connectOrCreate?: station_descriptionCreateOrConnectWithoutStation_markerInput | station_descriptionCreateOrConnectWithoutStation_markerInput[]
    createMany?: station_descriptionCreateManyStation_markerInputEnvelope
    connect?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
  }

  export type SavedStationsUncheckedCreateNestedManyWithoutMarkerInput = {
    create?: XOR<SavedStationsCreateWithoutMarkerInput, SavedStationsUncheckedCreateWithoutMarkerInput> | SavedStationsCreateWithoutMarkerInput[] | SavedStationsUncheckedCreateWithoutMarkerInput[]
    connectOrCreate?: SavedStationsCreateOrConnectWithoutMarkerInput | SavedStationsCreateOrConnectWithoutMarkerInput[]
    createMany?: SavedStationsCreateManyMarkerInputEnvelope
    connect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type station_descriptionUpdateManyWithoutStation_markerNestedInput = {
    create?: XOR<station_descriptionCreateWithoutStation_markerInput, station_descriptionUncheckedCreateWithoutStation_markerInput> | station_descriptionCreateWithoutStation_markerInput[] | station_descriptionUncheckedCreateWithoutStation_markerInput[]
    connectOrCreate?: station_descriptionCreateOrConnectWithoutStation_markerInput | station_descriptionCreateOrConnectWithoutStation_markerInput[]
    upsert?: station_descriptionUpsertWithWhereUniqueWithoutStation_markerInput | station_descriptionUpsertWithWhereUniqueWithoutStation_markerInput[]
    createMany?: station_descriptionCreateManyStation_markerInputEnvelope
    set?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
    disconnect?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
    delete?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
    connect?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
    update?: station_descriptionUpdateWithWhereUniqueWithoutStation_markerInput | station_descriptionUpdateWithWhereUniqueWithoutStation_markerInput[]
    updateMany?: station_descriptionUpdateManyWithWhereWithoutStation_markerInput | station_descriptionUpdateManyWithWhereWithoutStation_markerInput[]
    deleteMany?: station_descriptionScalarWhereInput | station_descriptionScalarWhereInput[]
  }

  export type SavedStationsUpdateManyWithoutMarkerNestedInput = {
    create?: XOR<SavedStationsCreateWithoutMarkerInput, SavedStationsUncheckedCreateWithoutMarkerInput> | SavedStationsCreateWithoutMarkerInput[] | SavedStationsUncheckedCreateWithoutMarkerInput[]
    connectOrCreate?: SavedStationsCreateOrConnectWithoutMarkerInput | SavedStationsCreateOrConnectWithoutMarkerInput[]
    upsert?: SavedStationsUpsertWithWhereUniqueWithoutMarkerInput | SavedStationsUpsertWithWhereUniqueWithoutMarkerInput[]
    createMany?: SavedStationsCreateManyMarkerInputEnvelope
    set?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    disconnect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    delete?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    connect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    update?: SavedStationsUpdateWithWhereUniqueWithoutMarkerInput | SavedStationsUpdateWithWhereUniqueWithoutMarkerInput[]
    updateMany?: SavedStationsUpdateManyWithWhereWithoutMarkerInput | SavedStationsUpdateManyWithWhereWithoutMarkerInput[]
    deleteMany?: SavedStationsScalarWhereInput | SavedStationsScalarWhereInput[]
  }

  export type station_descriptionUncheckedUpdateManyWithoutStation_markerNestedInput = {
    create?: XOR<station_descriptionCreateWithoutStation_markerInput, station_descriptionUncheckedCreateWithoutStation_markerInput> | station_descriptionCreateWithoutStation_markerInput[] | station_descriptionUncheckedCreateWithoutStation_markerInput[]
    connectOrCreate?: station_descriptionCreateOrConnectWithoutStation_markerInput | station_descriptionCreateOrConnectWithoutStation_markerInput[]
    upsert?: station_descriptionUpsertWithWhereUniqueWithoutStation_markerInput | station_descriptionUpsertWithWhereUniqueWithoutStation_markerInput[]
    createMany?: station_descriptionCreateManyStation_markerInputEnvelope
    set?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
    disconnect?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
    delete?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
    connect?: station_descriptionWhereUniqueInput | station_descriptionWhereUniqueInput[]
    update?: station_descriptionUpdateWithWhereUniqueWithoutStation_markerInput | station_descriptionUpdateWithWhereUniqueWithoutStation_markerInput[]
    updateMany?: station_descriptionUpdateManyWithWhereWithoutStation_markerInput | station_descriptionUpdateManyWithWhereWithoutStation_markerInput[]
    deleteMany?: station_descriptionScalarWhereInput | station_descriptionScalarWhereInput[]
  }

  export type SavedStationsUncheckedUpdateManyWithoutMarkerNestedInput = {
    create?: XOR<SavedStationsCreateWithoutMarkerInput, SavedStationsUncheckedCreateWithoutMarkerInput> | SavedStationsCreateWithoutMarkerInput[] | SavedStationsUncheckedCreateWithoutMarkerInput[]
    connectOrCreate?: SavedStationsCreateOrConnectWithoutMarkerInput | SavedStationsCreateOrConnectWithoutMarkerInput[]
    upsert?: SavedStationsUpsertWithWhereUniqueWithoutMarkerInput | SavedStationsUpsertWithWhereUniqueWithoutMarkerInput[]
    createMany?: SavedStationsCreateManyMarkerInputEnvelope
    set?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    disconnect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    delete?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    connect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    update?: SavedStationsUpdateWithWhereUniqueWithoutMarkerInput | SavedStationsUpdateWithWhereUniqueWithoutMarkerInput[]
    updateMany?: SavedStationsUpdateManyWithWhereWithoutMarkerInput | SavedStationsUpdateManyWithWhereWithoutMarkerInput[]
    deleteMany?: SavedStationsScalarWhereInput | SavedStationsScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserPermissionsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPermissionsCreateWithoutUserInput, UserPermissionsUncheckedCreateWithoutUserInput> | UserPermissionsCreateWithoutUserInput[] | UserPermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionsCreateOrConnectWithoutUserInput | UserPermissionsCreateOrConnectWithoutUserInput[]
    createMany?: UserPermissionsCreateManyUserInputEnvelope
    connect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
  }

  export type UserActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
  }

  export type RecoveryTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RecoveryTokenCreateWithoutUserInput, RecoveryTokenUncheckedCreateWithoutUserInput> | RecoveryTokenCreateWithoutUserInput[] | RecoveryTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryTokenCreateOrConnectWithoutUserInput | RecoveryTokenCreateOrConnectWithoutUserInput[]
    createMany?: RecoveryTokenCreateManyUserInputEnvelope
    connect?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
  }

  export type commentsCreateNestedManyWithoutUserInput = {
    create?: XOR<commentsCreateWithoutUserInput, commentsUncheckedCreateWithoutUserInput> | commentsCreateWithoutUserInput[] | commentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUserInput | commentsCreateOrConnectWithoutUserInput[]
    createMany?: commentsCreateManyUserInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type SavedStationsCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedStationsCreateWithoutUserInput, SavedStationsUncheckedCreateWithoutUserInput> | SavedStationsCreateWithoutUserInput[] | SavedStationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedStationsCreateOrConnectWithoutUserInput | SavedStationsCreateOrConnectWithoutUserInput[]
    createMany?: SavedStationsCreateManyUserInputEnvelope
    connect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
  }

  export type UserPermissionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPermissionsCreateWithoutUserInput, UserPermissionsUncheckedCreateWithoutUserInput> | UserPermissionsCreateWithoutUserInput[] | UserPermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionsCreateOrConnectWithoutUserInput | UserPermissionsCreateOrConnectWithoutUserInput[]
    createMany?: UserPermissionsCreateManyUserInputEnvelope
    connect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
  }

  export type UserActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
  }

  export type RecoveryTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecoveryTokenCreateWithoutUserInput, RecoveryTokenUncheckedCreateWithoutUserInput> | RecoveryTokenCreateWithoutUserInput[] | RecoveryTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryTokenCreateOrConnectWithoutUserInput | RecoveryTokenCreateOrConnectWithoutUserInput[]
    createMany?: RecoveryTokenCreateManyUserInputEnvelope
    connect?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<commentsCreateWithoutUserInput, commentsUncheckedCreateWithoutUserInput> | commentsCreateWithoutUserInput[] | commentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUserInput | commentsCreateOrConnectWithoutUserInput[]
    createMany?: commentsCreateManyUserInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type SavedStationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedStationsCreateWithoutUserInput, SavedStationsUncheckedCreateWithoutUserInput> | SavedStationsCreateWithoutUserInput[] | SavedStationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedStationsCreateOrConnectWithoutUserInput | SavedStationsCreateOrConnectWithoutUserInput[]
    createMany?: SavedStationsCreateManyUserInputEnvelope
    connect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserPermissionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPermissionsCreateWithoutUserInput, UserPermissionsUncheckedCreateWithoutUserInput> | UserPermissionsCreateWithoutUserInput[] | UserPermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionsCreateOrConnectWithoutUserInput | UserPermissionsCreateOrConnectWithoutUserInput[]
    upsert?: UserPermissionsUpsertWithWhereUniqueWithoutUserInput | UserPermissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPermissionsCreateManyUserInputEnvelope
    set?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    disconnect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    delete?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    connect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    update?: UserPermissionsUpdateWithWhereUniqueWithoutUserInput | UserPermissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPermissionsUpdateManyWithWhereWithoutUserInput | UserPermissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPermissionsScalarWhereInput | UserPermissionsScalarWhereInput[]
  }

  export type UserActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    upsert?: UserActivityUpsertWithWhereUniqueWithoutUserInput | UserActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    set?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    disconnect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    delete?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    update?: UserActivityUpdateWithWhereUniqueWithoutUserInput | UserActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivityUpdateManyWithWhereWithoutUserInput | UserActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
  }

  export type RecoveryTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecoveryTokenCreateWithoutUserInput, RecoveryTokenUncheckedCreateWithoutUserInput> | RecoveryTokenCreateWithoutUserInput[] | RecoveryTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryTokenCreateOrConnectWithoutUserInput | RecoveryTokenCreateOrConnectWithoutUserInput[]
    upsert?: RecoveryTokenUpsertWithWhereUniqueWithoutUserInput | RecoveryTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecoveryTokenCreateManyUserInputEnvelope
    set?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
    disconnect?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
    delete?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
    connect?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
    update?: RecoveryTokenUpdateWithWhereUniqueWithoutUserInput | RecoveryTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecoveryTokenUpdateManyWithWhereWithoutUserInput | RecoveryTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecoveryTokenScalarWhereInput | RecoveryTokenScalarWhereInput[]
  }

  export type commentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<commentsCreateWithoutUserInput, commentsUncheckedCreateWithoutUserInput> | commentsCreateWithoutUserInput[] | commentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUserInput | commentsCreateOrConnectWithoutUserInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUserInput | commentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: commentsCreateManyUserInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUserInput | commentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUserInput | commentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type SavedStationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedStationsCreateWithoutUserInput, SavedStationsUncheckedCreateWithoutUserInput> | SavedStationsCreateWithoutUserInput[] | SavedStationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedStationsCreateOrConnectWithoutUserInput | SavedStationsCreateOrConnectWithoutUserInput[]
    upsert?: SavedStationsUpsertWithWhereUniqueWithoutUserInput | SavedStationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedStationsCreateManyUserInputEnvelope
    set?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    disconnect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    delete?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    connect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    update?: SavedStationsUpdateWithWhereUniqueWithoutUserInput | SavedStationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedStationsUpdateManyWithWhereWithoutUserInput | SavedStationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedStationsScalarWhereInput | SavedStationsScalarWhereInput[]
  }

  export type UserPermissionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPermissionsCreateWithoutUserInput, UserPermissionsUncheckedCreateWithoutUserInput> | UserPermissionsCreateWithoutUserInput[] | UserPermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionsCreateOrConnectWithoutUserInput | UserPermissionsCreateOrConnectWithoutUserInput[]
    upsert?: UserPermissionsUpsertWithWhereUniqueWithoutUserInput | UserPermissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPermissionsCreateManyUserInputEnvelope
    set?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    disconnect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    delete?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    connect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    update?: UserPermissionsUpdateWithWhereUniqueWithoutUserInput | UserPermissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPermissionsUpdateManyWithWhereWithoutUserInput | UserPermissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPermissionsScalarWhereInput | UserPermissionsScalarWhereInput[]
  }

  export type UserActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    upsert?: UserActivityUpsertWithWhereUniqueWithoutUserInput | UserActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    set?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    disconnect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    delete?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    update?: UserActivityUpdateWithWhereUniqueWithoutUserInput | UserActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivityUpdateManyWithWhereWithoutUserInput | UserActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
  }

  export type RecoveryTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecoveryTokenCreateWithoutUserInput, RecoveryTokenUncheckedCreateWithoutUserInput> | RecoveryTokenCreateWithoutUserInput[] | RecoveryTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecoveryTokenCreateOrConnectWithoutUserInput | RecoveryTokenCreateOrConnectWithoutUserInput[]
    upsert?: RecoveryTokenUpsertWithWhereUniqueWithoutUserInput | RecoveryTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecoveryTokenCreateManyUserInputEnvelope
    set?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
    disconnect?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
    delete?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
    connect?: RecoveryTokenWhereUniqueInput | RecoveryTokenWhereUniqueInput[]
    update?: RecoveryTokenUpdateWithWhereUniqueWithoutUserInput | RecoveryTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecoveryTokenUpdateManyWithWhereWithoutUserInput | RecoveryTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecoveryTokenScalarWhereInput | RecoveryTokenScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<commentsCreateWithoutUserInput, commentsUncheckedCreateWithoutUserInput> | commentsCreateWithoutUserInput[] | commentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUserInput | commentsCreateOrConnectWithoutUserInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUserInput | commentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: commentsCreateManyUserInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUserInput | commentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUserInput | commentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type SavedStationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedStationsCreateWithoutUserInput, SavedStationsUncheckedCreateWithoutUserInput> | SavedStationsCreateWithoutUserInput[] | SavedStationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedStationsCreateOrConnectWithoutUserInput | SavedStationsCreateOrConnectWithoutUserInput[]
    upsert?: SavedStationsUpsertWithWhereUniqueWithoutUserInput | SavedStationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedStationsCreateManyUserInputEnvelope
    set?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    disconnect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    delete?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    connect?: SavedStationsWhereUniqueInput | SavedStationsWhereUniqueInput[]
    update?: SavedStationsUpdateWithWhereUniqueWithoutUserInput | SavedStationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedStationsUpdateManyWithWhereWithoutUserInput | SavedStationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedStationsScalarWhereInput | SavedStationsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSavedStationsInput = {
    create?: XOR<UserCreateWithoutSavedStationsInput, UserUncheckedCreateWithoutSavedStationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedStationsInput
    connect?: UserWhereUniqueInput
  }

  export type station_markerCreateNestedOneWithoutSavedStationsInput = {
    create?: XOR<station_markerCreateWithoutSavedStationsInput, station_markerUncheckedCreateWithoutSavedStationsInput>
    connectOrCreate?: station_markerCreateOrConnectWithoutSavedStationsInput
    connect?: station_markerWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSavedStationsNestedInput = {
    create?: XOR<UserCreateWithoutSavedStationsInput, UserUncheckedCreateWithoutSavedStationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedStationsInput
    upsert?: UserUpsertWithoutSavedStationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedStationsInput, UserUpdateWithoutSavedStationsInput>, UserUncheckedUpdateWithoutSavedStationsInput>
  }

  export type station_markerUpdateOneRequiredWithoutSavedStationsNestedInput = {
    create?: XOR<station_markerCreateWithoutSavedStationsInput, station_markerUncheckedCreateWithoutSavedStationsInput>
    connectOrCreate?: station_markerCreateOrConnectWithoutSavedStationsInput
    upsert?: station_markerUpsertWithoutSavedStationsInput
    connect?: station_markerWhereUniqueInput
    update?: XOR<XOR<station_markerUpdateToOneWithWhereWithoutSavedStationsInput, station_markerUpdateWithoutSavedStationsInput>, station_markerUncheckedUpdateWithoutSavedStationsInput>
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type UserPermissionsCreateNestedManyWithoutRolePermissionInput = {
    create?: XOR<UserPermissionsCreateWithoutRolePermissionInput, UserPermissionsUncheckedCreateWithoutRolePermissionInput> | UserPermissionsCreateWithoutRolePermissionInput[] | UserPermissionsUncheckedCreateWithoutRolePermissionInput[]
    connectOrCreate?: UserPermissionsCreateOrConnectWithoutRolePermissionInput | UserPermissionsCreateOrConnectWithoutRolePermissionInput[]
    createMany?: UserPermissionsCreateManyRolePermissionInputEnvelope
    connect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
  }

  export type UserPermissionsUncheckedCreateNestedManyWithoutRolePermissionInput = {
    create?: XOR<UserPermissionsCreateWithoutRolePermissionInput, UserPermissionsUncheckedCreateWithoutRolePermissionInput> | UserPermissionsCreateWithoutRolePermissionInput[] | UserPermissionsUncheckedCreateWithoutRolePermissionInput[]
    connectOrCreate?: UserPermissionsCreateOrConnectWithoutRolePermissionInput | UserPermissionsCreateOrConnectWithoutRolePermissionInput[]
    createMany?: UserPermissionsCreateManyRolePermissionInputEnvelope
    connect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type UserPermissionsUpdateManyWithoutRolePermissionNestedInput = {
    create?: XOR<UserPermissionsCreateWithoutRolePermissionInput, UserPermissionsUncheckedCreateWithoutRolePermissionInput> | UserPermissionsCreateWithoutRolePermissionInput[] | UserPermissionsUncheckedCreateWithoutRolePermissionInput[]
    connectOrCreate?: UserPermissionsCreateOrConnectWithoutRolePermissionInput | UserPermissionsCreateOrConnectWithoutRolePermissionInput[]
    upsert?: UserPermissionsUpsertWithWhereUniqueWithoutRolePermissionInput | UserPermissionsUpsertWithWhereUniqueWithoutRolePermissionInput[]
    createMany?: UserPermissionsCreateManyRolePermissionInputEnvelope
    set?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    disconnect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    delete?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    connect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    update?: UserPermissionsUpdateWithWhereUniqueWithoutRolePermissionInput | UserPermissionsUpdateWithWhereUniqueWithoutRolePermissionInput[]
    updateMany?: UserPermissionsUpdateManyWithWhereWithoutRolePermissionInput | UserPermissionsUpdateManyWithWhereWithoutRolePermissionInput[]
    deleteMany?: UserPermissionsScalarWhereInput | UserPermissionsScalarWhereInput[]
  }

  export type UserPermissionsUncheckedUpdateManyWithoutRolePermissionNestedInput = {
    create?: XOR<UserPermissionsCreateWithoutRolePermissionInput, UserPermissionsUncheckedCreateWithoutRolePermissionInput> | UserPermissionsCreateWithoutRolePermissionInput[] | UserPermissionsUncheckedCreateWithoutRolePermissionInput[]
    connectOrCreate?: UserPermissionsCreateOrConnectWithoutRolePermissionInput | UserPermissionsCreateOrConnectWithoutRolePermissionInput[]
    upsert?: UserPermissionsUpsertWithWhereUniqueWithoutRolePermissionInput | UserPermissionsUpsertWithWhereUniqueWithoutRolePermissionInput[]
    createMany?: UserPermissionsCreateManyRolePermissionInputEnvelope
    set?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    disconnect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    delete?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    connect?: UserPermissionsWhereUniqueInput | UserPermissionsWhereUniqueInput[]
    update?: UserPermissionsUpdateWithWhereUniqueWithoutRolePermissionInput | UserPermissionsUpdateWithWhereUniqueWithoutRolePermissionInput[]
    updateMany?: UserPermissionsUpdateManyWithWhereWithoutRolePermissionInput | UserPermissionsUpdateManyWithWhereWithoutRolePermissionInput[]
    deleteMany?: UserPermissionsScalarWhereInput | UserPermissionsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRecoveryTokenInput = {
    create?: XOR<UserCreateWithoutRecoveryTokenInput, UserUncheckedCreateWithoutRecoveryTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRecoveryTokenNestedInput = {
    create?: XOR<UserCreateWithoutRecoveryTokenInput, UserUncheckedCreateWithoutRecoveryTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecoveryTokenInput
    upsert?: UserUpsertWithoutRecoveryTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecoveryTokenInput, UserUpdateWithoutRecoveryTokenInput>, UserUncheckedUpdateWithoutRecoveryTokenInput>
  }

  export type UserCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type RolePermissionCreateNestedOneWithoutUsersInput = {
    create?: XOR<RolePermissionCreateWithoutUsersInput, RolePermissionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolePermissionCreateOrConnectWithoutUsersInput
    connect?: RolePermissionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    upsert?: UserUpsertWithoutPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPermissionsInput, UserUpdateWithoutPermissionsInput>, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type RolePermissionUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RolePermissionCreateWithoutUsersInput, RolePermissionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolePermissionCreateOrConnectWithoutUsersInput
    upsert?: RolePermissionUpsertWithoutUsersInput
    connect?: RolePermissionWhereUniqueInput
    update?: XOR<XOR<RolePermissionUpdateToOneWithWhereWithoutUsersInput, RolePermissionUpdateWithoutUsersInput>, RolePermissionUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type station_desc_apiCreateWithoutApi_sourceInput = {
    og_api_pk?: number | null
    station_description?: station_descriptionCreateNestedOneWithoutStation_desc_apiInput
  }

  export type station_desc_apiUncheckedCreateWithoutApi_sourceInput = {
    id?: number
    og_api_pk?: number | null
    description_id?: number | null
  }

  export type station_desc_apiCreateOrConnectWithoutApi_sourceInput = {
    where: station_desc_apiWhereUniqueInput
    create: XOR<station_desc_apiCreateWithoutApi_sourceInput, station_desc_apiUncheckedCreateWithoutApi_sourceInput>
  }

  export type station_desc_apiCreateManyApi_sourceInputEnvelope = {
    data: station_desc_apiCreateManyApi_sourceInput | station_desc_apiCreateManyApi_sourceInput[]
    skipDuplicates?: boolean
  }

  export type station_desc_apiUpsertWithWhereUniqueWithoutApi_sourceInput = {
    where: station_desc_apiWhereUniqueInput
    update: XOR<station_desc_apiUpdateWithoutApi_sourceInput, station_desc_apiUncheckedUpdateWithoutApi_sourceInput>
    create: XOR<station_desc_apiCreateWithoutApi_sourceInput, station_desc_apiUncheckedCreateWithoutApi_sourceInput>
  }

  export type station_desc_apiUpdateWithWhereUniqueWithoutApi_sourceInput = {
    where: station_desc_apiWhereUniqueInput
    data: XOR<station_desc_apiUpdateWithoutApi_sourceInput, station_desc_apiUncheckedUpdateWithoutApi_sourceInput>
  }

  export type station_desc_apiUpdateManyWithWhereWithoutApi_sourceInput = {
    where: station_desc_apiScalarWhereInput
    data: XOR<station_desc_apiUpdateManyMutationInput, station_desc_apiUncheckedUpdateManyWithoutApi_sourceInput>
  }

  export type station_desc_apiScalarWhereInput = {
    AND?: station_desc_apiScalarWhereInput | station_desc_apiScalarWhereInput[]
    OR?: station_desc_apiScalarWhereInput[]
    NOT?: station_desc_apiScalarWhereInput | station_desc_apiScalarWhereInput[]
    id?: IntFilter<"station_desc_api"> | number
    api_id?: IntNullableFilter<"station_desc_api"> | number | null
    og_api_pk?: IntNullableFilter<"station_desc_api"> | number | null
    description_id?: IntNullableFilter<"station_desc_api"> | number | null
  }

  export type UserCreateWithoutCommentsInput = {
    name: string
    email?: string | null
    passwordHash?: string | null
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    permissions?: UserPermissionsCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    name: string
    email?: string | null
    passwordHash?: string | null
    roleId: number
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenUncheckedCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type station_descriptionCreateWithoutCommentsInput = {
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    images?: imagesCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiCreateNestedManyWithoutStation_descriptionInput
    station_marker?: station_markerCreateNestedOneWithoutStation_descriptionInput
  }

  export type station_descriptionUncheckedCreateWithoutCommentsInput = {
    description_id?: number
    station_id?: number | null
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    images?: imagesUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiUncheckedCreateNestedManyWithoutStation_descriptionInput
  }

  export type station_descriptionCreateOrConnectWithoutCommentsInput = {
    where: station_descriptionWhereUniqueInput
    create: XOR<station_descriptionCreateWithoutCommentsInput, station_descriptionUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    permissions?: UserPermissionsUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: UserPermissionsUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUncheckedUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type station_descriptionUpsertWithoutCommentsInput = {
    update: XOR<station_descriptionUpdateWithoutCommentsInput, station_descriptionUncheckedUpdateWithoutCommentsInput>
    create: XOR<station_descriptionCreateWithoutCommentsInput, station_descriptionUncheckedCreateWithoutCommentsInput>
    where?: station_descriptionWhereInput
  }

  export type station_descriptionUpdateToOneWithWhereWithoutCommentsInput = {
    where?: station_descriptionWhereInput
    data: XOR<station_descriptionUpdateWithoutCommentsInput, station_descriptionUncheckedUpdateWithoutCommentsInput>
  }

  export type station_descriptionUpdateWithoutCommentsInput = {
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    images?: imagesUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUpdateManyWithoutStation_descriptionNestedInput
    station_marker?: station_markerUpdateOneWithoutStation_descriptionNestedInput
  }

  export type station_descriptionUncheckedUpdateWithoutCommentsInput = {
    description_id?: IntFieldUpdateOperationsInput | number
    station_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    images?: imagesUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUncheckedUpdateManyWithoutStation_descriptionNestedInput
  }

  export type station_descriptionCreateWithoutImagesInput = {
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiCreateNestedManyWithoutStation_descriptionInput
    station_marker?: station_markerCreateNestedOneWithoutStation_descriptionInput
  }

  export type station_descriptionUncheckedCreateWithoutImagesInput = {
    description_id?: number
    station_id?: number | null
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiUncheckedCreateNestedManyWithoutStation_descriptionInput
  }

  export type station_descriptionCreateOrConnectWithoutImagesInput = {
    where: station_descriptionWhereUniqueInput
    create: XOR<station_descriptionCreateWithoutImagesInput, station_descriptionUncheckedCreateWithoutImagesInput>
  }

  export type station_descriptionUpsertWithoutImagesInput = {
    update: XOR<station_descriptionUpdateWithoutImagesInput, station_descriptionUncheckedUpdateWithoutImagesInput>
    create: XOR<station_descriptionCreateWithoutImagesInput, station_descriptionUncheckedCreateWithoutImagesInput>
    where?: station_descriptionWhereInput
  }

  export type station_descriptionUpdateToOneWithWhereWithoutImagesInput = {
    where?: station_descriptionWhereInput
    data: XOR<station_descriptionUpdateWithoutImagesInput, station_descriptionUncheckedUpdateWithoutImagesInput>
  }

  export type station_descriptionUpdateWithoutImagesInput = {
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUpdateManyWithoutStation_descriptionNestedInput
    station_marker?: station_markerUpdateOneWithoutStation_descriptionNestedInput
  }

  export type station_descriptionUncheckedUpdateWithoutImagesInput = {
    description_id?: IntFieldUpdateOperationsInput | number
    station_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUncheckedUpdateManyWithoutStation_descriptionNestedInput
  }

  export type station_descriptionCreateWithoutStation_connectorInput = {
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsCreateNestedManyWithoutStation_descriptionInput
    images?: imagesCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiCreateNestedManyWithoutStation_descriptionInput
    station_marker?: station_markerCreateNestedOneWithoutStation_descriptionInput
  }

  export type station_descriptionUncheckedCreateWithoutStation_connectorInput = {
    description_id?: number
    station_id?: number | null
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsUncheckedCreateNestedManyWithoutStation_descriptionInput
    images?: imagesUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiUncheckedCreateNestedManyWithoutStation_descriptionInput
  }

  export type station_descriptionCreateOrConnectWithoutStation_connectorInput = {
    where: station_descriptionWhereUniqueInput
    create: XOR<station_descriptionCreateWithoutStation_connectorInput, station_descriptionUncheckedCreateWithoutStation_connectorInput>
  }

  export type station_descriptionUpsertWithoutStation_connectorInput = {
    update: XOR<station_descriptionUpdateWithoutStation_connectorInput, station_descriptionUncheckedUpdateWithoutStation_connectorInput>
    create: XOR<station_descriptionCreateWithoutStation_connectorInput, station_descriptionUncheckedCreateWithoutStation_connectorInput>
    where?: station_descriptionWhereInput
  }

  export type station_descriptionUpdateToOneWithWhereWithoutStation_connectorInput = {
    where?: station_descriptionWhereInput
    data: XOR<station_descriptionUpdateWithoutStation_connectorInput, station_descriptionUncheckedUpdateWithoutStation_connectorInput>
  }

  export type station_descriptionUpdateWithoutStation_connectorInput = {
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUpdateManyWithoutStation_descriptionNestedInput
    images?: imagesUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUpdateManyWithoutStation_descriptionNestedInput
    station_marker?: station_markerUpdateOneWithoutStation_descriptionNestedInput
  }

  export type station_descriptionUncheckedUpdateWithoutStation_connectorInput = {
    description_id?: IntFieldUpdateOperationsInput | number
    station_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUncheckedUpdateManyWithoutStation_descriptionNestedInput
    images?: imagesUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUncheckedUpdateManyWithoutStation_descriptionNestedInput
  }

  export type api_sourceCreateWithoutStation_desc_apiInput = {
    link: string
    detailed_link: string
    last_update?: bigint | number | null
    next_update?: bigint | number | null
    update_interval_ms?: bigint | number | null
    comments_link?: string | null
  }

  export type api_sourceUncheckedCreateWithoutStation_desc_apiInput = {
    api_id?: number
    link: string
    detailed_link: string
    last_update?: bigint | number | null
    next_update?: bigint | number | null
    update_interval_ms?: bigint | number | null
    comments_link?: string | null
  }

  export type api_sourceCreateOrConnectWithoutStation_desc_apiInput = {
    where: api_sourceWhereUniqueInput
    create: XOR<api_sourceCreateWithoutStation_desc_apiInput, api_sourceUncheckedCreateWithoutStation_desc_apiInput>
  }

  export type station_descriptionCreateWithoutStation_desc_apiInput = {
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsCreateNestedManyWithoutStation_descriptionInput
    images?: imagesCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorCreateNestedManyWithoutStation_descriptionInput
    station_marker?: station_markerCreateNestedOneWithoutStation_descriptionInput
  }

  export type station_descriptionUncheckedCreateWithoutStation_desc_apiInput = {
    description_id?: number
    station_id?: number | null
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsUncheckedCreateNestedManyWithoutStation_descriptionInput
    images?: imagesUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorUncheckedCreateNestedManyWithoutStation_descriptionInput
  }

  export type station_descriptionCreateOrConnectWithoutStation_desc_apiInput = {
    where: station_descriptionWhereUniqueInput
    create: XOR<station_descriptionCreateWithoutStation_desc_apiInput, station_descriptionUncheckedCreateWithoutStation_desc_apiInput>
  }

  export type api_sourceUpsertWithoutStation_desc_apiInput = {
    update: XOR<api_sourceUpdateWithoutStation_desc_apiInput, api_sourceUncheckedUpdateWithoutStation_desc_apiInput>
    create: XOR<api_sourceCreateWithoutStation_desc_apiInput, api_sourceUncheckedCreateWithoutStation_desc_apiInput>
    where?: api_sourceWhereInput
  }

  export type api_sourceUpdateToOneWithWhereWithoutStation_desc_apiInput = {
    where?: api_sourceWhereInput
    data: XOR<api_sourceUpdateWithoutStation_desc_apiInput, api_sourceUncheckedUpdateWithoutStation_desc_apiInput>
  }

  export type api_sourceUpdateWithoutStation_desc_apiInput = {
    link?: StringFieldUpdateOperationsInput | string
    detailed_link?: StringFieldUpdateOperationsInput | string
    last_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    next_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    update_interval_ms?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type api_sourceUncheckedUpdateWithoutStation_desc_apiInput = {
    api_id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    detailed_link?: StringFieldUpdateOperationsInput | string
    last_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    next_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    update_interval_ms?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comments_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type station_descriptionUpsertWithoutStation_desc_apiInput = {
    update: XOR<station_descriptionUpdateWithoutStation_desc_apiInput, station_descriptionUncheckedUpdateWithoutStation_desc_apiInput>
    create: XOR<station_descriptionCreateWithoutStation_desc_apiInput, station_descriptionUncheckedCreateWithoutStation_desc_apiInput>
    where?: station_descriptionWhereInput
  }

  export type station_descriptionUpdateToOneWithWhereWithoutStation_desc_apiInput = {
    where?: station_descriptionWhereInput
    data: XOR<station_descriptionUpdateWithoutStation_desc_apiInput, station_descriptionUncheckedUpdateWithoutStation_desc_apiInput>
  }

  export type station_descriptionUpdateWithoutStation_desc_apiInput = {
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUpdateManyWithoutStation_descriptionNestedInput
    images?: imagesUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUpdateManyWithoutStation_descriptionNestedInput
    station_marker?: station_markerUpdateOneWithoutStation_descriptionNestedInput
  }

  export type station_descriptionUncheckedUpdateWithoutStation_desc_apiInput = {
    description_id?: IntFieldUpdateOperationsInput | number
    station_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUncheckedUpdateManyWithoutStation_descriptionNestedInput
    images?: imagesUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUncheckedUpdateManyWithoutStation_descriptionNestedInput
  }

  export type commentsCreateWithoutStation_descriptionInput = {
    comment_href?: string | null
    author_name?: string | null
    rating?: number | null
    comment_text?: string | null
    user?: UserCreateNestedOneWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutStation_descriptionInput = {
    comment_id?: number
    comment_href?: string | null
    author_name?: string | null
    user_id?: number | null
    rating?: number | null
    comment_text?: string | null
  }

  export type commentsCreateOrConnectWithoutStation_descriptionInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutStation_descriptionInput, commentsUncheckedCreateWithoutStation_descriptionInput>
  }

  export type commentsCreateManyStation_descriptionInputEnvelope = {
    data: commentsCreateManyStation_descriptionInput | commentsCreateManyStation_descriptionInput[]
    skipDuplicates?: boolean
  }

  export type imagesCreateWithoutStation_descriptionInput = {
    image_href?: string | null
  }

  export type imagesUncheckedCreateWithoutStation_descriptionInput = {
    image_id?: number
    image_href?: string | null
  }

  export type imagesCreateOrConnectWithoutStation_descriptionInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutStation_descriptionInput, imagesUncheckedCreateWithoutStation_descriptionInput>
  }

  export type imagesCreateManyStation_descriptionInputEnvelope = {
    data: imagesCreateManyStation_descriptionInput | imagesCreateManyStation_descriptionInput[]
    skipDuplicates?: boolean
  }

  export type station_connectorCreateWithoutStation_descriptionInput = {
    connector_type_id?: number | null
    connector_status_id?: number | null
    connector_name?: string | null
    power_kw?: number | null
    current_amp?: number | null
    price_per_start?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    free_min_after_charging?: number | null
    price_per_min_after_charging?: Decimal | DecimalJsLike | number | string | null
  }

  export type station_connectorUncheckedCreateWithoutStation_descriptionInput = {
    connector_id?: number
    connector_type_id?: number | null
    connector_status_id?: number | null
    connector_name?: string | null
    power_kw?: number | null
    current_amp?: number | null
    price_per_start?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    free_min_after_charging?: number | null
    price_per_min_after_charging?: Decimal | DecimalJsLike | number | string | null
  }

  export type station_connectorCreateOrConnectWithoutStation_descriptionInput = {
    where: station_connectorWhereUniqueInput
    create: XOR<station_connectorCreateWithoutStation_descriptionInput, station_connectorUncheckedCreateWithoutStation_descriptionInput>
  }

  export type station_connectorCreateManyStation_descriptionInputEnvelope = {
    data: station_connectorCreateManyStation_descriptionInput | station_connectorCreateManyStation_descriptionInput[]
    skipDuplicates?: boolean
  }

  export type station_desc_apiCreateWithoutStation_descriptionInput = {
    og_api_pk?: number | null
    api_source?: api_sourceCreateNestedOneWithoutStation_desc_apiInput
  }

  export type station_desc_apiUncheckedCreateWithoutStation_descriptionInput = {
    id?: number
    api_id?: number | null
    og_api_pk?: number | null
  }

  export type station_desc_apiCreateOrConnectWithoutStation_descriptionInput = {
    where: station_desc_apiWhereUniqueInput
    create: XOR<station_desc_apiCreateWithoutStation_descriptionInput, station_desc_apiUncheckedCreateWithoutStation_descriptionInput>
  }

  export type station_desc_apiCreateManyStation_descriptionInputEnvelope = {
    data: station_desc_apiCreateManyStation_descriptionInput | station_desc_apiCreateManyStation_descriptionInput[]
    skipDuplicates?: boolean
  }

  export type station_markerCreateWithoutStation_descriptionInput = {
    longitude: Decimal | DecimalJsLike | number | string
    latitude: Decimal | DecimalJsLike | number | string
    savedStations?: SavedStationsCreateNestedManyWithoutMarkerInput
  }

  export type station_markerUncheckedCreateWithoutStation_descriptionInput = {
    station_id?: number
    longitude: Decimal | DecimalJsLike | number | string
    latitude: Decimal | DecimalJsLike | number | string
    savedStations?: SavedStationsUncheckedCreateNestedManyWithoutMarkerInput
  }

  export type station_markerCreateOrConnectWithoutStation_descriptionInput = {
    where: station_markerWhereUniqueInput
    create: XOR<station_markerCreateWithoutStation_descriptionInput, station_markerUncheckedCreateWithoutStation_descriptionInput>
  }

  export type commentsUpsertWithWhereUniqueWithoutStation_descriptionInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutStation_descriptionInput, commentsUncheckedUpdateWithoutStation_descriptionInput>
    create: XOR<commentsCreateWithoutStation_descriptionInput, commentsUncheckedCreateWithoutStation_descriptionInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutStation_descriptionInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutStation_descriptionInput, commentsUncheckedUpdateWithoutStation_descriptionInput>
  }

  export type commentsUpdateManyWithWhereWithoutStation_descriptionInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutStation_descriptionInput>
  }

  export type commentsScalarWhereInput = {
    AND?: commentsScalarWhereInput | commentsScalarWhereInput[]
    OR?: commentsScalarWhereInput[]
    NOT?: commentsScalarWhereInput | commentsScalarWhereInput[]
    comment_id?: IntFilter<"comments"> | number
    description_id?: IntNullableFilter<"comments"> | number | null
    comment_href?: StringNullableFilter<"comments"> | string | null
    author_name?: StringNullableFilter<"comments"> | string | null
    user_id?: IntNullableFilter<"comments"> | number | null
    rating?: FloatNullableFilter<"comments"> | number | null
    comment_text?: StringNullableFilter<"comments"> | string | null
  }

  export type imagesUpsertWithWhereUniqueWithoutStation_descriptionInput = {
    where: imagesWhereUniqueInput
    update: XOR<imagesUpdateWithoutStation_descriptionInput, imagesUncheckedUpdateWithoutStation_descriptionInput>
    create: XOR<imagesCreateWithoutStation_descriptionInput, imagesUncheckedCreateWithoutStation_descriptionInput>
  }

  export type imagesUpdateWithWhereUniqueWithoutStation_descriptionInput = {
    where: imagesWhereUniqueInput
    data: XOR<imagesUpdateWithoutStation_descriptionInput, imagesUncheckedUpdateWithoutStation_descriptionInput>
  }

  export type imagesUpdateManyWithWhereWithoutStation_descriptionInput = {
    where: imagesScalarWhereInput
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyWithoutStation_descriptionInput>
  }

  export type imagesScalarWhereInput = {
    AND?: imagesScalarWhereInput | imagesScalarWhereInput[]
    OR?: imagesScalarWhereInput[]
    NOT?: imagesScalarWhereInput | imagesScalarWhereInput[]
    image_id?: IntFilter<"images"> | number
    description_id?: IntNullableFilter<"images"> | number | null
    image_href?: StringNullableFilter<"images"> | string | null
  }

  export type station_connectorUpsertWithWhereUniqueWithoutStation_descriptionInput = {
    where: station_connectorWhereUniqueInput
    update: XOR<station_connectorUpdateWithoutStation_descriptionInput, station_connectorUncheckedUpdateWithoutStation_descriptionInput>
    create: XOR<station_connectorCreateWithoutStation_descriptionInput, station_connectorUncheckedCreateWithoutStation_descriptionInput>
  }

  export type station_connectorUpdateWithWhereUniqueWithoutStation_descriptionInput = {
    where: station_connectorWhereUniqueInput
    data: XOR<station_connectorUpdateWithoutStation_descriptionInput, station_connectorUncheckedUpdateWithoutStation_descriptionInput>
  }

  export type station_connectorUpdateManyWithWhereWithoutStation_descriptionInput = {
    where: station_connectorScalarWhereInput
    data: XOR<station_connectorUpdateManyMutationInput, station_connectorUncheckedUpdateManyWithoutStation_descriptionInput>
  }

  export type station_connectorScalarWhereInput = {
    AND?: station_connectorScalarWhereInput | station_connectorScalarWhereInput[]
    OR?: station_connectorScalarWhereInput[]
    NOT?: station_connectorScalarWhereInput | station_connectorScalarWhereInput[]
    connector_id?: IntFilter<"station_connector"> | number
    description_id?: IntNullableFilter<"station_connector"> | number | null
    connector_type_id?: IntNullableFilter<"station_connector"> | number | null
    connector_status_id?: IntNullableFilter<"station_connector"> | number | null
    connector_name?: StringNullableFilter<"station_connector"> | string | null
    power_kw?: IntNullableFilter<"station_connector"> | number | null
    current_amp?: IntNullableFilter<"station_connector"> | number | null
    price_per_start?: DecimalNullableFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    price?: DecimalNullableFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"station_connector"> | string | null
    free_min_after_charging?: IntNullableFilter<"station_connector"> | number | null
    price_per_min_after_charging?: DecimalNullableFilter<"station_connector"> | Decimal | DecimalJsLike | number | string | null
  }

  export type station_desc_apiUpsertWithWhereUniqueWithoutStation_descriptionInput = {
    where: station_desc_apiWhereUniqueInput
    update: XOR<station_desc_apiUpdateWithoutStation_descriptionInput, station_desc_apiUncheckedUpdateWithoutStation_descriptionInput>
    create: XOR<station_desc_apiCreateWithoutStation_descriptionInput, station_desc_apiUncheckedCreateWithoutStation_descriptionInput>
  }

  export type station_desc_apiUpdateWithWhereUniqueWithoutStation_descriptionInput = {
    where: station_desc_apiWhereUniqueInput
    data: XOR<station_desc_apiUpdateWithoutStation_descriptionInput, station_desc_apiUncheckedUpdateWithoutStation_descriptionInput>
  }

  export type station_desc_apiUpdateManyWithWhereWithoutStation_descriptionInput = {
    where: station_desc_apiScalarWhereInput
    data: XOR<station_desc_apiUpdateManyMutationInput, station_desc_apiUncheckedUpdateManyWithoutStation_descriptionInput>
  }

  export type station_markerUpsertWithoutStation_descriptionInput = {
    update: XOR<station_markerUpdateWithoutStation_descriptionInput, station_markerUncheckedUpdateWithoutStation_descriptionInput>
    create: XOR<station_markerCreateWithoutStation_descriptionInput, station_markerUncheckedCreateWithoutStation_descriptionInput>
    where?: station_markerWhereInput
  }

  export type station_markerUpdateToOneWithWhereWithoutStation_descriptionInput = {
    where?: station_markerWhereInput
    data: XOR<station_markerUpdateWithoutStation_descriptionInput, station_markerUncheckedUpdateWithoutStation_descriptionInput>
  }

  export type station_markerUpdateWithoutStation_descriptionInput = {
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    savedStations?: SavedStationsUpdateManyWithoutMarkerNestedInput
  }

  export type station_markerUncheckedUpdateWithoutStation_descriptionInput = {
    station_id?: IntFieldUpdateOperationsInput | number
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    savedStations?: SavedStationsUncheckedUpdateManyWithoutMarkerNestedInput
  }

  export type station_descriptionCreateWithoutStation_markerInput = {
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsCreateNestedManyWithoutStation_descriptionInput
    images?: imagesCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiCreateNestedManyWithoutStation_descriptionInput
  }

  export type station_descriptionUncheckedCreateWithoutStation_markerInput = {
    description_id?: number
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
    comments?: commentsUncheckedCreateNestedManyWithoutStation_descriptionInput
    images?: imagesUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_connector?: station_connectorUncheckedCreateNestedManyWithoutStation_descriptionInput
    station_desc_api?: station_desc_apiUncheckedCreateNestedManyWithoutStation_descriptionInput
  }

  export type station_descriptionCreateOrConnectWithoutStation_markerInput = {
    where: station_descriptionWhereUniqueInput
    create: XOR<station_descriptionCreateWithoutStation_markerInput, station_descriptionUncheckedCreateWithoutStation_markerInput>
  }

  export type station_descriptionCreateManyStation_markerInputEnvelope = {
    data: station_descriptionCreateManyStation_markerInput | station_descriptionCreateManyStation_markerInput[]
    skipDuplicates?: boolean
  }

  export type SavedStationsCreateWithoutMarkerInput = {
    user: UserCreateNestedOneWithoutSavedStationsInput
  }

  export type SavedStationsUncheckedCreateWithoutMarkerInput = {
    userId: number
  }

  export type SavedStationsCreateOrConnectWithoutMarkerInput = {
    where: SavedStationsWhereUniqueInput
    create: XOR<SavedStationsCreateWithoutMarkerInput, SavedStationsUncheckedCreateWithoutMarkerInput>
  }

  export type SavedStationsCreateManyMarkerInputEnvelope = {
    data: SavedStationsCreateManyMarkerInput | SavedStationsCreateManyMarkerInput[]
    skipDuplicates?: boolean
  }

  export type station_descriptionUpsertWithWhereUniqueWithoutStation_markerInput = {
    where: station_descriptionWhereUniqueInput
    update: XOR<station_descriptionUpdateWithoutStation_markerInput, station_descriptionUncheckedUpdateWithoutStation_markerInput>
    create: XOR<station_descriptionCreateWithoutStation_markerInput, station_descriptionUncheckedCreateWithoutStation_markerInput>
  }

  export type station_descriptionUpdateWithWhereUniqueWithoutStation_markerInput = {
    where: station_descriptionWhereUniqueInput
    data: XOR<station_descriptionUpdateWithoutStation_markerInput, station_descriptionUncheckedUpdateWithoutStation_markerInput>
  }

  export type station_descriptionUpdateManyWithWhereWithoutStation_markerInput = {
    where: station_descriptionScalarWhereInput
    data: XOR<station_descriptionUpdateManyMutationInput, station_descriptionUncheckedUpdateManyWithoutStation_markerInput>
  }

  export type station_descriptionScalarWhereInput = {
    AND?: station_descriptionScalarWhereInput | station_descriptionScalarWhereInput[]
    OR?: station_descriptionScalarWhereInput[]
    NOT?: station_descriptionScalarWhereInput | station_descriptionScalarWhereInput[]
    description_id?: IntFilter<"station_description"> | number
    station_id?: IntNullableFilter<"station_description"> | number | null
    station_name?: StringNullableFilter<"station_description"> | string | null
    description_string?: StringNullableFilter<"station_description"> | string | null
    location_type?: StringNullableFilter<"station_description"> | string | null
    country_code?: StringNullableFilter<"station_description"> | string | null
    support_phone?: StringNullableFilter<"station_description"> | string | null
    is_support_charging?: BoolNullableFilter<"station_description"> | boolean | null
    is_support_reservation?: BoolNullableFilter<"station_description"> | boolean | null
    location_name?: StringNullableFilter<"station_description"> | string | null
    last_charging?: BigIntNullableFilter<"station_description"> | bigint | number | null
    is_public?: BoolNullableFilter<"station_description"> | boolean | null
    is_fast_charger?: BoolNullableFilter<"station_description"> | boolean | null
    is_open_24x7?: BoolNullableFilter<"station_description"> | boolean | null
    min_power_kw?: IntNullableFilter<"station_description"> | number | null
    max_power_kw?: IntNullableFilter<"station_description"> | number | null
    last_status_update?: BigIntNullableFilter<"station_description"> | bigint | number | null
    network_id?: IntNullableFilter<"station_description"> | number | null
    status_id?: IntNullableFilter<"station_description"> | number | null
    station_flags?: BytesNullableFilter<"station_description"> | Uint8Array | null
  }

  export type SavedStationsUpsertWithWhereUniqueWithoutMarkerInput = {
    where: SavedStationsWhereUniqueInput
    update: XOR<SavedStationsUpdateWithoutMarkerInput, SavedStationsUncheckedUpdateWithoutMarkerInput>
    create: XOR<SavedStationsCreateWithoutMarkerInput, SavedStationsUncheckedCreateWithoutMarkerInput>
  }

  export type SavedStationsUpdateWithWhereUniqueWithoutMarkerInput = {
    where: SavedStationsWhereUniqueInput
    data: XOR<SavedStationsUpdateWithoutMarkerInput, SavedStationsUncheckedUpdateWithoutMarkerInput>
  }

  export type SavedStationsUpdateManyWithWhereWithoutMarkerInput = {
    where: SavedStationsScalarWhereInput
    data: XOR<SavedStationsUpdateManyMutationInput, SavedStationsUncheckedUpdateManyWithoutMarkerInput>
  }

  export type SavedStationsScalarWhereInput = {
    AND?: SavedStationsScalarWhereInput | SavedStationsScalarWhereInput[]
    OR?: SavedStationsScalarWhereInput[]
    NOT?: SavedStationsScalarWhereInput | SavedStationsScalarWhereInput[]
    userId?: IntFilter<"SavedStations"> | number
    markerId?: IntFilter<"SavedStations"> | number
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserPermissionsCreateWithoutUserInput = {
    rolePermission: RolePermissionCreateNestedOneWithoutUsersInput
  }

  export type UserPermissionsUncheckedCreateWithoutUserInput = {
    rolePermissionId: number
  }

  export type UserPermissionsCreateOrConnectWithoutUserInput = {
    where: UserPermissionsWhereUniqueInput
    create: XOR<UserPermissionsCreateWithoutUserInput, UserPermissionsUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionsCreateManyUserInputEnvelope = {
    data: UserPermissionsCreateManyUserInput | UserPermissionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserActivityCreateWithoutUserInput = {
    ip: string
    lastActivityAt?: Date | string
  }

  export type UserActivityUncheckedCreateWithoutUserInput = {
    ip: string
    lastActivityAt?: Date | string
  }

  export type UserActivityCreateOrConnectWithoutUserInput = {
    where: UserActivityWhereUniqueInput
    create: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput>
  }

  export type UserActivityCreateManyUserInputEnvelope = {
    data: UserActivityCreateManyUserInput | UserActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RecoveryTokenCreateWithoutUserInput = {
    tokenHash: string
    expiresAt: Date | string
  }

  export type RecoveryTokenUncheckedCreateWithoutUserInput = {
    tokenHash: string
    expiresAt: Date | string
  }

  export type RecoveryTokenCreateOrConnectWithoutUserInput = {
    where: RecoveryTokenWhereUniqueInput
    create: XOR<RecoveryTokenCreateWithoutUserInput, RecoveryTokenUncheckedCreateWithoutUserInput>
  }

  export type RecoveryTokenCreateManyUserInputEnvelope = {
    data: RecoveryTokenCreateManyUserInput | RecoveryTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type commentsCreateWithoutUserInput = {
    comment_href?: string | null
    author_name?: string | null
    rating?: number | null
    comment_text?: string | null
    station_description?: station_descriptionCreateNestedOneWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutUserInput = {
    comment_id?: number
    description_id?: number | null
    comment_href?: string | null
    author_name?: string | null
    rating?: number | null
    comment_text?: string | null
  }

  export type commentsCreateOrConnectWithoutUserInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutUserInput, commentsUncheckedCreateWithoutUserInput>
  }

  export type commentsCreateManyUserInputEnvelope = {
    data: commentsCreateManyUserInput | commentsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SavedStationsCreateWithoutUserInput = {
    marker: station_markerCreateNestedOneWithoutSavedStationsInput
  }

  export type SavedStationsUncheckedCreateWithoutUserInput = {
    markerId: number
  }

  export type SavedStationsCreateOrConnectWithoutUserInput = {
    where: SavedStationsWhereUniqueInput
    create: XOR<SavedStationsCreateWithoutUserInput, SavedStationsUncheckedCreateWithoutUserInput>
  }

  export type SavedStationsCreateManyUserInputEnvelope = {
    data: SavedStationsCreateManyUserInput | SavedStationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserPermissionsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPermissionsWhereUniqueInput
    update: XOR<UserPermissionsUpdateWithoutUserInput, UserPermissionsUncheckedUpdateWithoutUserInput>
    create: XOR<UserPermissionsCreateWithoutUserInput, UserPermissionsUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPermissionsWhereUniqueInput
    data: XOR<UserPermissionsUpdateWithoutUserInput, UserPermissionsUncheckedUpdateWithoutUserInput>
  }

  export type UserPermissionsUpdateManyWithWhereWithoutUserInput = {
    where: UserPermissionsScalarWhereInput
    data: XOR<UserPermissionsUpdateManyMutationInput, UserPermissionsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPermissionsScalarWhereInput = {
    AND?: UserPermissionsScalarWhereInput | UserPermissionsScalarWhereInput[]
    OR?: UserPermissionsScalarWhereInput[]
    NOT?: UserPermissionsScalarWhereInput | UserPermissionsScalarWhereInput[]
    userId?: IntFilter<"UserPermissions"> | number
    rolePermissionId?: IntFilter<"UserPermissions"> | number
  }

  export type UserActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: UserActivityWhereUniqueInput
    update: XOR<UserActivityUpdateWithoutUserInput, UserActivityUncheckedUpdateWithoutUserInput>
    create: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput>
  }

  export type UserActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: UserActivityWhereUniqueInput
    data: XOR<UserActivityUpdateWithoutUserInput, UserActivityUncheckedUpdateWithoutUserInput>
  }

  export type UserActivityUpdateManyWithWhereWithoutUserInput = {
    where: UserActivityScalarWhereInput
    data: XOR<UserActivityUpdateManyMutationInput, UserActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type UserActivityScalarWhereInput = {
    AND?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
    OR?: UserActivityScalarWhereInput[]
    NOT?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
    userId?: IntFilter<"UserActivity"> | number
    ip?: StringFilter<"UserActivity"> | string
    lastActivityAt?: DateTimeFilter<"UserActivity"> | Date | string
  }

  export type RecoveryTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RecoveryTokenWhereUniqueInput
    update: XOR<RecoveryTokenUpdateWithoutUserInput, RecoveryTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RecoveryTokenCreateWithoutUserInput, RecoveryTokenUncheckedCreateWithoutUserInput>
  }

  export type RecoveryTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RecoveryTokenWhereUniqueInput
    data: XOR<RecoveryTokenUpdateWithoutUserInput, RecoveryTokenUncheckedUpdateWithoutUserInput>
  }

  export type RecoveryTokenUpdateManyWithWhereWithoutUserInput = {
    where: RecoveryTokenScalarWhereInput
    data: XOR<RecoveryTokenUpdateManyMutationInput, RecoveryTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RecoveryTokenScalarWhereInput = {
    AND?: RecoveryTokenScalarWhereInput | RecoveryTokenScalarWhereInput[]
    OR?: RecoveryTokenScalarWhereInput[]
    NOT?: RecoveryTokenScalarWhereInput | RecoveryTokenScalarWhereInput[]
    userId?: IntFilter<"RecoveryToken"> | number
    tokenHash?: StringFilter<"RecoveryToken"> | string
    expiresAt?: DateTimeFilter<"RecoveryToken"> | Date | string
  }

  export type commentsUpsertWithWhereUniqueWithoutUserInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutUserInput, commentsUncheckedUpdateWithoutUserInput>
    create: XOR<commentsCreateWithoutUserInput, commentsUncheckedCreateWithoutUserInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutUserInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutUserInput, commentsUncheckedUpdateWithoutUserInput>
  }

  export type commentsUpdateManyWithWhereWithoutUserInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedStationsUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedStationsWhereUniqueInput
    update: XOR<SavedStationsUpdateWithoutUserInput, SavedStationsUncheckedUpdateWithoutUserInput>
    create: XOR<SavedStationsCreateWithoutUserInput, SavedStationsUncheckedCreateWithoutUserInput>
  }

  export type SavedStationsUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedStationsWhereUniqueInput
    data: XOR<SavedStationsUpdateWithoutUserInput, SavedStationsUncheckedUpdateWithoutUserInput>
  }

  export type SavedStationsUpdateManyWithWhereWithoutUserInput = {
    where: SavedStationsScalarWhereInput
    data: XOR<SavedStationsUpdateManyMutationInput, SavedStationsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutSavedStationsInput = {
    name: string
    email?: string | null
    passwordHash?: string | null
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    permissions?: UserPermissionsCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenCreateNestedManyWithoutUserInput
    comments?: commentsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedStationsInput = {
    id?: number
    name: string
    email?: string | null
    passwordHash?: string | null
    roleId: number
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenUncheckedCreateNestedManyWithoutUserInput
    comments?: commentsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedStationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedStationsInput, UserUncheckedCreateWithoutSavedStationsInput>
  }

  export type station_markerCreateWithoutSavedStationsInput = {
    longitude: Decimal | DecimalJsLike | number | string
    latitude: Decimal | DecimalJsLike | number | string
    station_description?: station_descriptionCreateNestedManyWithoutStation_markerInput
  }

  export type station_markerUncheckedCreateWithoutSavedStationsInput = {
    station_id?: number
    longitude: Decimal | DecimalJsLike | number | string
    latitude: Decimal | DecimalJsLike | number | string
    station_description?: station_descriptionUncheckedCreateNestedManyWithoutStation_markerInput
  }

  export type station_markerCreateOrConnectWithoutSavedStationsInput = {
    where: station_markerWhereUniqueInput
    create: XOR<station_markerCreateWithoutSavedStationsInput, station_markerUncheckedCreateWithoutSavedStationsInput>
  }

  export type UserUpsertWithoutSavedStationsInput = {
    update: XOR<UserUpdateWithoutSavedStationsInput, UserUncheckedUpdateWithoutSavedStationsInput>
    create: XOR<UserCreateWithoutSavedStationsInput, UserUncheckedCreateWithoutSavedStationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedStationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedStationsInput, UserUncheckedUpdateWithoutSavedStationsInput>
  }

  export type UserUpdateWithoutSavedStationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    permissions?: UserPermissionsUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUpdateManyWithoutUserNestedInput
    comments?: commentsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedStationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: UserPermissionsUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUncheckedUpdateManyWithoutUserNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type station_markerUpsertWithoutSavedStationsInput = {
    update: XOR<station_markerUpdateWithoutSavedStationsInput, station_markerUncheckedUpdateWithoutSavedStationsInput>
    create: XOR<station_markerCreateWithoutSavedStationsInput, station_markerUncheckedCreateWithoutSavedStationsInput>
    where?: station_markerWhereInput
  }

  export type station_markerUpdateToOneWithWhereWithoutSavedStationsInput = {
    where?: station_markerWhereInput
    data: XOR<station_markerUpdateWithoutSavedStationsInput, station_markerUncheckedUpdateWithoutSavedStationsInput>
  }

  export type station_markerUpdateWithoutSavedStationsInput = {
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    station_description?: station_descriptionUpdateManyWithoutStation_markerNestedInput
  }

  export type station_markerUncheckedUpdateWithoutSavedStationsInput = {
    station_id?: IntFieldUpdateOperationsInput | number
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    station_description?: station_descriptionUncheckedUpdateManyWithoutStation_markerNestedInput
  }

  export type RolePermissionCreateWithoutRoleInput = {
    permission: PermissionCreateNestedOneWithoutRolesInput
    users?: UserPermissionsCreateNestedManyWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: number
    permissionId: number
    users?: UserPermissionsUncheckedCreateNestedManyWithoutRolePermissionInput
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRoleInput = {
    name: string
    email?: string | null
    passwordHash?: string | null
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: UserPermissionsCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenCreateNestedManyWithoutUserInput
    comments?: commentsCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: number
    name: string
    email?: string | null
    passwordHash?: string | null
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenUncheckedCreateNestedManyWithoutUserInput
    comments?: commentsUncheckedCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    roleId?: IntFilter<"User"> | number
    isBanned?: BoolFilter<"User"> | boolean
    emailVerificationKey?: StringNullableFilter<"User"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    role: RoleCreateNestedOneWithoutPermissionsInput
    users?: UserPermissionsCreateNestedManyWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    roleId: number
    users?: UserPermissionsUncheckedCreateNestedManyWithoutRolePermissionInput
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    name: string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: number
    name: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    resource: string
    action: string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: number
    resource: string
    action: string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type UserPermissionsCreateWithoutRolePermissionInput = {
    user: UserCreateNestedOneWithoutPermissionsInput
  }

  export type UserPermissionsUncheckedCreateWithoutRolePermissionInput = {
    userId: number
  }

  export type UserPermissionsCreateOrConnectWithoutRolePermissionInput = {
    where: UserPermissionsWhereUniqueInput
    create: XOR<UserPermissionsCreateWithoutRolePermissionInput, UserPermissionsUncheckedCreateWithoutRolePermissionInput>
  }

  export type UserPermissionsCreateManyRolePermissionInputEnvelope = {
    data: UserPermissionsCreateManyRolePermissionInput | UserPermissionsCreateManyRolePermissionInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type UserPermissionsUpsertWithWhereUniqueWithoutRolePermissionInput = {
    where: UserPermissionsWhereUniqueInput
    update: XOR<UserPermissionsUpdateWithoutRolePermissionInput, UserPermissionsUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<UserPermissionsCreateWithoutRolePermissionInput, UserPermissionsUncheckedCreateWithoutRolePermissionInput>
  }

  export type UserPermissionsUpdateWithWhereUniqueWithoutRolePermissionInput = {
    where: UserPermissionsWhereUniqueInput
    data: XOR<UserPermissionsUpdateWithoutRolePermissionInput, UserPermissionsUncheckedUpdateWithoutRolePermissionInput>
  }

  export type UserPermissionsUpdateManyWithWhereWithoutRolePermissionInput = {
    where: UserPermissionsScalarWhereInput
    data: XOR<UserPermissionsUpdateManyMutationInput, UserPermissionsUncheckedUpdateManyWithoutRolePermissionInput>
  }

  export type UserCreateWithoutRecoveryTokenInput = {
    name: string
    email?: string | null
    passwordHash?: string | null
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    permissions?: UserPermissionsCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    comments?: commentsCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecoveryTokenInput = {
    id?: number
    name: string
    email?: string | null
    passwordHash?: string | null
    roleId: number
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    comments?: commentsUncheckedCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecoveryTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecoveryTokenInput, UserUncheckedCreateWithoutRecoveryTokenInput>
  }

  export type UserUpsertWithoutRecoveryTokenInput = {
    update: XOR<UserUpdateWithoutRecoveryTokenInput, UserUncheckedUpdateWithoutRecoveryTokenInput>
    create: XOR<UserCreateWithoutRecoveryTokenInput, UserUncheckedCreateWithoutRecoveryTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecoveryTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecoveryTokenInput, UserUncheckedUpdateWithoutRecoveryTokenInput>
  }

  export type UserUpdateWithoutRecoveryTokenInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    permissions?: UserPermissionsUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    comments?: commentsUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecoveryTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: UserPermissionsUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPermissionsInput = {
    name: string
    email?: string | null
    passwordHash?: string | null
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenCreateNestedManyWithoutUserInput
    comments?: commentsCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPermissionsInput = {
    id?: number
    name: string
    email?: string | null
    passwordHash?: string | null
    roleId: number
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenUncheckedCreateNestedManyWithoutUserInput
    comments?: commentsUncheckedCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type RolePermissionCreateWithoutUsersInput = {
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutUsersInput = {
    id?: number
    roleId: number
    permissionId: number
  }

  export type RolePermissionCreateOrConnectWithoutUsersInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutUsersInput, RolePermissionUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutPermissionsInput = {
    update: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUpdateManyWithoutUserNestedInput
    comments?: commentsUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUncheckedUpdateManyWithoutUserNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolePermissionUpsertWithoutUsersInput = {
    update: XOR<RolePermissionUpdateWithoutUsersInput, RolePermissionUncheckedUpdateWithoutUsersInput>
    create: XOR<RolePermissionCreateWithoutUsersInput, RolePermissionUncheckedCreateWithoutUsersInput>
    where?: RolePermissionWhereInput
  }

  export type RolePermissionUpdateToOneWithWhereWithoutUsersInput = {
    where?: RolePermissionWhereInput
    data: XOR<RolePermissionUpdateWithoutUsersInput, RolePermissionUncheckedUpdateWithoutUsersInput>
  }

  export type RolePermissionUpdateWithoutUsersInput = {
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutActivitiesInput = {
    name: string
    email?: string | null
    passwordHash?: string | null
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    permissions?: UserPermissionsCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenCreateNestedManyWithoutUserInput
    comments?: commentsCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: number
    name: string
    email?: string | null
    passwordHash?: string | null
    roleId: number
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    RecoveryToken?: RecoveryTokenUncheckedCreateNestedManyWithoutUserInput
    comments?: commentsUncheckedCreateNestedManyWithoutUserInput
    savedStations?: SavedStationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    permissions?: UserPermissionsUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUpdateManyWithoutUserNestedInput
    comments?: commentsUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: UserPermissionsUncheckedUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUncheckedUpdateManyWithoutUserNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type station_desc_apiCreateManyApi_sourceInput = {
    id?: number
    og_api_pk?: number | null
    description_id?: number | null
  }

  export type station_desc_apiUpdateWithoutApi_sourceInput = {
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
    station_description?: station_descriptionUpdateOneWithoutStation_desc_apiNestedInput
  }

  export type station_desc_apiUncheckedUpdateWithoutApi_sourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type station_desc_apiUncheckedUpdateManyWithoutApi_sourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type commentsCreateManyStation_descriptionInput = {
    comment_id?: number
    comment_href?: string | null
    author_name?: string | null
    user_id?: number | null
    rating?: number | null
    comment_text?: string | null
  }

  export type imagesCreateManyStation_descriptionInput = {
    image_id?: number
    image_href?: string | null
  }

  export type station_connectorCreateManyStation_descriptionInput = {
    connector_id?: number
    connector_type_id?: number | null
    connector_status_id?: number | null
    connector_name?: string | null
    power_kw?: number | null
    current_amp?: number | null
    price_per_start?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    free_min_after_charging?: number | null
    price_per_min_after_charging?: Decimal | DecimalJsLike | number | string | null
  }

  export type station_desc_apiCreateManyStation_descriptionInput = {
    id?: number
    api_id?: number | null
    og_api_pk?: number | null
  }

  export type commentsUpdateWithoutStation_descriptionInput = {
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutStation_descriptionInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentsUncheckedUpdateManyWithoutStation_descriptionInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type imagesUpdateWithoutStation_descriptionInput = {
    image_href?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type imagesUncheckedUpdateWithoutStation_descriptionInput = {
    image_id?: IntFieldUpdateOperationsInput | number
    image_href?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type imagesUncheckedUpdateManyWithoutStation_descriptionInput = {
    image_id?: IntFieldUpdateOperationsInput | number
    image_href?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type station_connectorUpdateWithoutStation_descriptionInput = {
    connector_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_status_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_name?: NullableStringFieldUpdateOperationsInput | string | null
    power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    current_amp?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_start?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    free_min_after_charging?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_min_after_charging?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type station_connectorUncheckedUpdateWithoutStation_descriptionInput = {
    connector_id?: IntFieldUpdateOperationsInput | number
    connector_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_status_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_name?: NullableStringFieldUpdateOperationsInput | string | null
    power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    current_amp?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_start?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    free_min_after_charging?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_min_after_charging?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type station_connectorUncheckedUpdateManyWithoutStation_descriptionInput = {
    connector_id?: IntFieldUpdateOperationsInput | number
    connector_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_status_id?: NullableIntFieldUpdateOperationsInput | number | null
    connector_name?: NullableStringFieldUpdateOperationsInput | string | null
    power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    current_amp?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_start?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    free_min_after_charging?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_min_after_charging?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type station_desc_apiUpdateWithoutStation_descriptionInput = {
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
    api_source?: api_sourceUpdateOneWithoutStation_desc_apiNestedInput
  }

  export type station_desc_apiUncheckedUpdateWithoutStation_descriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    api_id?: NullableIntFieldUpdateOperationsInput | number | null
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type station_desc_apiUncheckedUpdateManyWithoutStation_descriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    api_id?: NullableIntFieldUpdateOperationsInput | number | null
    og_api_pk?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type station_descriptionCreateManyStation_markerInput = {
    description_id?: number
    station_name?: string | null
    description_string?: string | null
    location_type?: string | null
    country_code?: string | null
    support_phone?: string | null
    is_support_charging?: boolean | null
    is_support_reservation?: boolean | null
    location_name?: string | null
    last_charging?: bigint | number | null
    is_public?: boolean | null
    is_fast_charger?: boolean | null
    is_open_24x7?: boolean | null
    min_power_kw?: number | null
    max_power_kw?: number | null
    last_status_update?: bigint | number | null
    network_id?: number | null
    status_id?: number | null
    station_flags?: Uint8Array | null
  }

  export type SavedStationsCreateManyMarkerInput = {
    userId: number
  }

  export type station_descriptionUpdateWithoutStation_markerInput = {
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUpdateManyWithoutStation_descriptionNestedInput
    images?: imagesUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUpdateManyWithoutStation_descriptionNestedInput
  }

  export type station_descriptionUncheckedUpdateWithoutStation_markerInput = {
    description_id?: IntFieldUpdateOperationsInput | number
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    comments?: commentsUncheckedUpdateManyWithoutStation_descriptionNestedInput
    images?: imagesUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_connector?: station_connectorUncheckedUpdateManyWithoutStation_descriptionNestedInput
    station_desc_api?: station_desc_apiUncheckedUpdateManyWithoutStation_descriptionNestedInput
  }

  export type station_descriptionUncheckedUpdateManyWithoutStation_markerInput = {
    description_id?: IntFieldUpdateOperationsInput | number
    station_name?: NullableStringFieldUpdateOperationsInput | string | null
    description_string?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    support_phone?: NullableStringFieldUpdateOperationsInput | string | null
    is_support_charging?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_support_reservation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_charging?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_fast_charger?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_open_24x7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    min_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    max_power_kw?: NullableIntFieldUpdateOperationsInput | number | null
    last_status_update?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    network_id?: NullableIntFieldUpdateOperationsInput | number | null
    status_id?: NullableIntFieldUpdateOperationsInput | number | null
    station_flags?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type SavedStationsUpdateWithoutMarkerInput = {
    user?: UserUpdateOneRequiredWithoutSavedStationsNestedInput
  }

  export type SavedStationsUncheckedUpdateWithoutMarkerInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type SavedStationsUncheckedUpdateManyWithoutMarkerInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPermissionsCreateManyUserInput = {
    rolePermissionId: number
  }

  export type UserActivityCreateManyUserInput = {
    ip: string
    lastActivityAt?: Date | string
  }

  export type RecoveryTokenCreateManyUserInput = {
    tokenHash: string
    expiresAt: Date | string
  }

  export type commentsCreateManyUserInput = {
    comment_id?: number
    description_id?: number | null
    comment_href?: string | null
    author_name?: string | null
    rating?: number | null
    comment_text?: string | null
  }

  export type SavedStationsCreateManyUserInput = {
    markerId: number
  }

  export type UserPermissionsUpdateWithoutUserInput = {
    rolePermission?: RolePermissionUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserPermissionsUncheckedUpdateWithoutUserInput = {
    rolePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPermissionsUncheckedUpdateManyWithoutUserInput = {
    rolePermissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserActivityUpdateWithoutUserInput = {
    ip?: StringFieldUpdateOperationsInput | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateWithoutUserInput = {
    ip?: StringFieldUpdateOperationsInput | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateManyWithoutUserInput = {
    ip?: StringFieldUpdateOperationsInput | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryTokenUpdateWithoutUserInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryTokenUncheckedUpdateWithoutUserInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecoveryTokenUncheckedUpdateManyWithoutUserInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsUpdateWithoutUserInput = {
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
    station_description?: station_descriptionUpdateOneWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutUserInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentsUncheckedUpdateManyWithoutUserInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    description_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_href?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SavedStationsUpdateWithoutUserInput = {
    marker?: station_markerUpdateOneRequiredWithoutSavedStationsNestedInput
  }

  export type SavedStationsUncheckedUpdateWithoutUserInput = {
    markerId?: IntFieldUpdateOperationsInput | number
  }

  export type SavedStationsUncheckedUpdateManyWithoutUserInput = {
    markerId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: number
    permissionId: number
  }

  export type UserCreateManyRoleInput = {
    id?: number
    name: string
    email?: string | null
    passwordHash?: string | null
    isBanned?: boolean
    emailVerificationKey?: string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
    users?: UserPermissionsUpdateManyWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    users?: UserPermissionsUncheckedUpdateManyWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: UserPermissionsUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUpdateManyWithoutUserNestedInput
    comments?: commentsUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: UserPermissionsUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    RecoveryToken?: RecoveryTokenUncheckedUpdateManyWithoutUserNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUserNestedInput
    savedStations?: SavedStationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationKey?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: number
    roleId: number
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    users?: UserPermissionsUpdateManyWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    users?: UserPermissionsUncheckedUpdateManyWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPermissionsCreateManyRolePermissionInput = {
    userId: number
  }

  export type UserPermissionsUpdateWithoutRolePermissionInput = {
    user?: UserUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type UserPermissionsUncheckedUpdateWithoutRolePermissionInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPermissionsUncheckedUpdateManyWithoutRolePermissionInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}